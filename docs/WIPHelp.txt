                    @1                   
                    @1  ~fM ~bE G ~3A Z ~bE U ~fX  
                    @1                   

:072:                     ~9Table of Contents

>#FAQ.HLP:1st:FREQUENTLY ASKED QUESTIONS.
>#CONFGINI.HLP:1st:The Config File
>#HELPONHE.HLP:000:Help on Help (Press F1 Within Help to Read This)
>#MOUSESUP.HLP:1st:Mouse Support in MegaZeux
>#1ST_TIME.HLP:071:Overview of MegaZeux - First Time Users Read This!
>#ZZT.HLP:zzt:A ZZTer's Guide to MegaZeux
>#DIABOX.HLP:098:Dialog Boxes
>#CONTROLS.HLP:ctr:Controls
>#NONDESCR.HLP:091:Nondescript Play Tips
>#BUILTINS.HLP:1st:The Mirth of Built-ins
>#CONFGINI.HLP:1st:MegaZeux Options
>#THEWORLD.HLP:1st:The World Editor
>#GENERALE.HLP:1st:General Editing Tips
>#EDITINGK.HLP:080:Editing Keys and Options Reference
>#CHAREDIT.HLP:079:The Character Editor
>#PALEEDIT.HLP:093:The Palette Editor
>#SMZXMODE.HLP:095:Super MegaZeux Modes
>#GLOBALIN.HLP:086:Global Info Options
>#BOARDINF.HLP:085:Board Info Options
>#SOUNDEFX.HLP:1st:MegaZeux's Sound System
>#TOVERLAY.HLP:081:Editing and Using the Overlay
>#SCROLLSS.HLP:1st:Signs and Scrolls in the Editor
>#SENSORSW.HLP:094:Sensors - What They Are and How to Use Them
>#ROBOTSWH.HLP:1st:Robots - What They Are and How to Use Them
>#ROBOTICT.HLP:1st:Robotic Tutorial
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#DBGMODE.HLP:dbg:Debug Mode
>#ERRORMES.HLP:1st:Error Messages
>#MEGAZEUX.HLP:1st:MegaZeux Limitations
>#IFYOUFIN.HLP:1st:If You Find a Bug...
>#NEWINVER.HLP:1st:NEW in MegaZeux!

$** Credits and Acknowledgments **

$MegaZeux SDL Thanks & Beta Testers:
$Exophase
$ZoMbIeGuY
$Wervyn
$Quasar84
$Lancer-X
$KenOhki2112
$Terryn
$Inuchance (Macintosh testing)
$Everyone who submitted a bug report

$Programming and Overall Design by Gilead Kutnick (Exophase)
$Based off of original program and source code by Gregory Janson
$Music/Sound code by modplug with patch by Alistair Strachan
$GDM conversion by Alistair Strachan (ajs) and MadBrain
$Help file by Terryn
$Pack-in SMZX utility and default SMZX palette by LogiCow
$Other past contributors: Spider124, Koji, MadBrain, JZig,
$Akwende, MenTaLguY, CapnKev.

>072:Table of Contents
#HELPONHE.HLP
:000: 
$~9Help on Help

Using MegaZeux's help system is very simple. Press F1 at
almost any time to bring up help relating to the current
situation. Within help, use the arrow keys to Scroll the
current section. Press PageUp and PageDown to Scroll faster.
Many sections of help contain selections, like this:

>sl:Selection
:sl:
Scroll the section until the pointer is aligned with the arrows
on the edges of the help box, and press Enter. You will jump to
a help section indicated by the selection. Example: If a
selection says "Controls", scroll until the word is aligned
with the arrows on the left and right, and press Enter. You
should now be reading help on Controls.

Press F1 within help to jump to this section. Press Alt+F1
within help to jump to the Table of Contents. (Table of Major
Help Topics) Press ESC to exit the help system.

>#MAIN.HLP:072:Table of Contents
#1ST_TIME.HLP
:071: 
$~9Overview of MegaZeux

$Welcome to MegaZeux! Use the arrow keys to scroll
$this text, and ESC when you are done reading.

$Press END to learn about the NEW FEATURES in
$MegaZeux!

As you may already know, MegaZeux is a game system which
allows you to play almost limitless worlds in dated yet
charming graphics and with excellent digitized music and sound.
Not only are there several MZX worlds out there already, but
new worlds are being uploaded to large websites like
DigitalMZX. However, the best feature of MegaZeux is the World
Editor.

Using the World Editor, ANYONE can create the world of their
dreams. Make it as simple or complex (well, almost), as easy
or difficult, as long or short as you please. We aren't just
talking about worlds made up of petty, pre-programmed enemies
and objects; MegaZeux has its own, easy-to-use PROGRAMMING
LANGUAGE called Robotic that allows you to create objects,
engines and worlds that do almost anything you desire.

For the newest user, it's recommended that you play Caverns,
the first ever MegaZeux game, to get the feel of simple yet
well-designed games in MegaZeux. You may wish to read the help
section entitled "Controls" to learn how to play MegaZeux.

If you're more adventurous, start with a more complex game like
Demon Earth or Bernard the Bard, or a prettier game like & or
Fritz Blitz to see what kind of graphics functions, bells and
whistles MZX can offer.

Once you have the feel for the game, feel free to dive into the
World Editor and get messy! You should probably read the help
section entitled "The World Editor" first.

To go to one of these sections now, hit Enter after aligning
the arrows with one of these choices. Press ESC now to exit to
the game.

>#MAIN.HLP:072:Table of Contents
>#CONTROLS.HLP:ctr:Controls
>#THEWORLD.HLP:1st:The World Editor

>#NEWINVER.HLP:1st:NEW in MegaZeux!
#ZZT.HLP
:zzt: 
$~9A ZZTer's Guide to MegaZeux

ZZT and MegaZeux are worlds apart, although one can convert
from making ZZT games to making basic MegaZeux games with
(mostly) minimal effort. This section is to help seasoned
ZZTers adjust to MegaZeux.

Firstly, some mechanistic differences exist.

-MegaZeux uses counters instead of flags; however, counters
can easily be used as flags if set only to 1 and 0.
-MegaZeux has an incredibly high amount of available counters.
-There is no default mechanism for torches.
-No equivalent of centipedes exists as a default enemy.
-Multiple MegaZeux keys of the same color can be picked up at
 once.
-There is no board setting controlling the amount of player
shots that can be on a given board.
-Cloning the player has no use in MZX; uses of player clones
need simulated in Robotic.
-The Shift-? hotkey (often used for inventory engines) does not
exist in MegaZeux but can be emulated with Robotic.
-Bomb explosions are not instantaneous but instead radiate out
from the center. They are also diamond-shaped as opposed to
a flattened oval shape.
-MegaZeux uses cycle 1 as default (as opposed to ZZT's cycle
3).
-No equivalent of duplicators exists.
-Seekers (aka "stars") do not destroy Breakaway territories in
MegaZeux.
-MZX Sharks do not swim in water, and can be shot. They can
also shoot any type of projectile.
-MZX Scrolls cannot execute code. Use a Robot ending with the
"die" command for ZZT scrolls with code instead. 
-Terrains that give out a distinctive message on first touch
(fakes, forests) give out no such message in MZX.
-There are two types of Gems; the one that best emulates ZZT
gems is the Magic Gem.
-Lasers will not push the player into other objects. This makes
some ZZT laser configurations a lot less deadly.
-Scrolls with only one line launch a message box (instead of
using the message row for the line).
-ZZT has one less bullet type than MZX; shift MZX types one
tier of "friendliness" for each typical shooter to get
ZZT-equivalent bullets.
-Putting in fake commands for comedic effect (e.g. putting in 
~A#GOSUCKANEGG~F to make ZZT beep and go "ERR: Bad command
GOSUCKANEGG") does not work in MegaZeux and has to be emulated.
-Special exploits (e.g. black holes, monitors, speed-up
exploit, flag overloading) have no direct MZX equivalent.
-Other, extremely minor, differences best left for total wonks
or for ZZT port authors, while others are implicitly understood
and do not require spelling out.

Secondly, here is how the ZZT-OOP commands convert to Robotic.

---------------------------------------------------------------

Key:

[*] = There's no direct (i.e. one-line) way to make Robots do
commands on IF statements. A label pointing to the command will
have to do.

[+] = There is no good analogue for this command, due to
bound objects sharing zap/restore settings in ZZT. Without
these concerns, COPYROBOT is the closest match.

[#] = You need to manually add a label at the top of the Robot
for this in MZX.

---------------------------------------------------------------

~A@@object_name = . "@@Robot_name"

~A/direction/direction = PERSISTENT GO (works only for cardinal
~Adirections and idle: n s e w i)

~A?direction =  / "directions"

~A'comment = . "comment"

~Aone line of text = * "text"

~Amultiple lines of text = % "text"

~A!label;text = ? "label" "text"

~A$ text = % "~~ftext" (by default palette)

~A#BECOME thing = BECOME color thing param

~A#BIND object_name = COPYROBOT "Robot" [+]

~A#CHANGE thing newthing = CHANGE color thing param newcolor
~Anewthing newparam

~A#CHAR # = CHAR #

~A#CLEAR flag = SET "counter" 0

~A#CYCLE # = CYCLE #

~A#DIE = DIE

~A#END = END

~A#ENDGAME = ENDGAME

~A#GIVE item # = GIVE # item

~A#GO direction = GO direction #

~A#IDLE = WAIT #

~A#IF flag label;text = ? "counter" "label" "text"

~A#IF flag THEN command = IF "counter" = 1 THEN "label" 
~F[*]

~A#IF ANY object THEN command = IF ANY color thing param "label"
~F[*]

~A#IF NOT flag THEN command = IF "counter" = 0 THEN "label" 
~F[*]

~A#IF condition THEN command = IF condition THEN "label" 
~F[*]

~A#IF NOT condition THEN command = IF NOT condition THEN "label"
~F[*]

~A#LOCK = LOCKSELF

~A#PLAY notes = PLAY "notes"

~A#PUT direction thing = PUT color thing param direction

~A#RESTART 
~F[#]

~A#RESTORE label = RESTORE "label" #

~A#SEND label = GOTO "label"

~A#SEND Objectname:"label" = SEND "Robotname" "label"

~A#SEND ALL:command  = SEND "All" "label" 
~F[*]

~A#SET flag = SET "counter" 1

~A#SHOOT direction = SHOOT direction

~A#TAKE item # failure_label = TAKE # item "failure_label"
~A(failure label optional)

~A#THROWSTAR direction = SHOOTSEEKER direction

~A#TRY direction label = TRY direction "label"

~A#UNLOCK = UNLOCKSELF

~A#WALK direction = WALK direction

~A#ZAP label = ZAP "label" #

---------------------------------------------------------------

As for conditions, a few are changed:

~AALLIGNED~F is now ~AALIGNED~F

~ACONTACT~F is now ~ATOUCHING ANYDIR~F

~AENERGIZED~F is no longer a condition but the "invinco" label.

---------------------------------------------------------------

This should be all one needs to make most ZZT-style games for
MegaZeux, except for a little Robotic knowledge to replicate
things like torches and duplicators. Of course, much more
powerful games can be made with MegaZeux; see corresponding
help for details.

>#MAIN.HLP:072:Table of Contents
#DIABOX.HLP
:098: 
$~9Dialog Boxes

Much of MegaZeux's interface is made of dialog boxes. They
are simple and intuitive to use, but instructions for the
uninformed are included here.

A dialog box is a form of inputting various information. An
example of a dialog box is the Save Game box or the Settings
box, both in-game. To use a box is simple - Use TAB and
SHIFT+TAB to highlight an element, and type or use the cursor
keys to change the value. Press ENTER on a button (Rectangle
with a label) to exit the dialog or produce an effect.

MZX also utilizes mouse control. You can click on a dialog box
element to select it, or click on a selected element to change
it. Click on a selected button to activate it.

You can usually use HOME to jump to the first section of the
dialog box, and END to jump to the OK or NEXT button. TAB jumps
forward a section, while SHIFT+TAB goes backwards a section.

The different dialog box elements and special related keys
are explained in detail for the remainder of this section.

INPUT - This is where you type in a series of characters,
usually letters and numbers. You can move the cursor around
within the line, type to insert characters, move to the start
with Home, and move to the end with End. Alt + Backspace
deletes the entire line, while Ctrl + Backspace deletes the
last typed word.

NUMBER - This is where you have a number and you change it
with the arrow keys or mouse clicks on buttons. Up and Down
will change it by 1, Alt+Up and Alt+Down will change it by
10, and PageUp and PageDown will change it by 100. You can
also hold the mouse button down on one of the arrows to
change the number or press 0-9 to set the last digit.
Pressing 0-9 on the keypad changes the current digit to that
value. Finally, Backspace deletes the last digit.

NUMBER LINE - This is a line of numbers, with one highlighted.
It functions in a manner similar to the above, but in a limited
range.

CHARACTER - This is where you can select a single character.
Press a character to use that character; click on it or press
Enter to get a large menu of characters to select from.

COLOR - This is where you can select a single color. Press
Enter or click on it to get a large menu of colors to choose
from.

CHECK BOXES - These are On/Off switches. Use Up/Down to move
within the list of choices, and use Space, Enter, or mouse
clicks to toggle choices on and off. Press Tab to jump out of
a check box section. An [X] means the option is currently on.

RADIO BUTTONS - These are similar to Check Boxes, but are
mutually exclusive. The mouse or arrow keys will select the
current and ONLY option that is on. The ( ) shows the current
option.

BUTTON - These are rectangles with labels. When selected,
press Enter or click to activate. OK or Done will verify the
contents of the dialog box. Cancel will cancel any changes
you've made. (ESC will usually do this as well.) Next and
Previous move between multiple dialog boxes. Other buttons
do what their label signifies and are explained in the
appropriate help section.

LISTS - These show a selection from a list of choices. The
current selection is shown. Press Enter or click on it to
bring up a list of choices from which you can select a new
choice.

>#MAIN.HLP:072:Table of Contents
#CONTROLS.HLP
:ctr: 
$~9Controls

Universal controls are as follows:

-Tab goes forward one section; Shift+Tab goes backward one
section.

-Esc cancels.

-Enter selects.

-Alt+Backspace deletes the entire line.

-Ctrl+Backspace deletes the last typed word.

-Ctrl+Left jumps to the previous word; Ctrl+Right jumps to the
next word.

-0 thru 9 sets the last digit in a number box (such as setting
amounts of items in a chest); backspace deletes the last digit.

File access controls are as follows:

-(0-9 and A-Z) will jump to the first file/directory starting
with that character. More specific seeking can be done by
typing characters in quick succession (for instance, s+e+c
would jump to the first file starting with sec).

-Del will delete the highlighted file/directory. You will be
asked for confirmation.

-Alt+R will rename the highlighted file/directory.

-Alt+N will create a new directory.

In-game controls are as follows:

F1 - Help
Use this at any time to bring up help relating to the current
situation. Within the game, you will go to the Controls
section. Some games may have this menu disabled or replaced
with their own help menus.

Enter - Menu/Status
Use this to bring up a menu of options and a list of your
current stats, such as Score, Gems, any custom-defined status
counters, etc. Some games may have this key do nothing, or even
something different entirely.

ESC - Exit to Title
This will quit the current game and return to its title
screen. In yes/no dialog boxes, this selects the "no" option.

F2 - Settings
:092:This will bring up a dialog box where you can change the
current game settings: Game Speed (if allowed), Music toggle,
Sound toggle, and Audio Volumes (Overall Volume, SoundFX
volume, and PC Speaker SFX). Speed 1 is the fastest; speed 16
is the slowest. A speed of 1 will run MZX as fast as possible
and as such acts differently between computers; it will also
cause flicker in fullscreen mode, so it is not recommended
unless it is your only option. Please note that some games may
have the speed change by itself; the next load will change to
the default speed unless otherwise prompted. Some games may
block access to the F2 menu entirely.

F3 - Save Game
This will prompt you for a filename, allowing the saving of the
exact state of the current game. Some games may not allow
saving on some or all of its screens, or will only allow saving
in certain spots of a board. Saving lets you quit your game in
the middle or take precautions against unknown dangers.

F4 - Restore Game
This will let you select a saved game from a list of filenames.
The game will then be reloaded from the same point you left
off. While most games will allow loading anywhere, some will
restrict loading to certain times or will use a custom
mechanism for loading games instead.

NOTE: A few games may save or load automatically, and
high-caliber games may have completely different methods of
saving and loading games.

F5 or Ins - Toggle Bomb Type
This will switch your current bomb type between High Strength
and Low Strength.

F6 - Debug Window
This will bring up a small box in the lower left corner of the
screen, detailing your position, board number, the currently
playing module and the amount of memory used by Robots. It is
generally only necessary when testing and fixing your own
games. Press F6 again to turn the box off. This will only work
during playtesting in the editor.

F7 - Items Cheat

This will give the player one key of each color, full ammo,
full coins, full gems, full bombs, full health (set to
maxhealth) and full lives (set to maxlives). This is a cheating
function, so do not use unless fully necessary; a few games
punish the player for using this function. This will only work
during playtesting in the editor, or in MZXRun builds.

F8 - Zap Cheat

This will destroy everything all in eight directions directly
around the player, replacing all eight squares with spaces.
This is a cheating function, so do not use unless fully
necessary; a few games punish the player for using this
function. This will only work during playtesting in
the editor, or in MZXRun builds.

F9 - Quicksave
This will save the game, like F3, but to the last filename you
used without prompting you for a filename. The old file will
be overwritten. If no game has been saved since MegaZeux was
started, the save will have the default filename listed in the
config.txt file.

>#CONFGINI.HLP:1st:The Config File

F10 - Quickload
This will reload the last game saved using F3 or F9. If no
game has been saved since MegaZeux was started, the default
save filename will be used.

F11 - Debug Mode
This will load a screen listing which counters and strings
have been set, as well as values for default counters and
strings. Debug mode allows considerable manipulation of
counters and strings, among other things. For more detail, go
to its specific section.

>#DBGMODE.HLP:dbg:Debug Mode

F12 - Take Screenshot
Pressing F12 will make a 640x350 screenshot (in PNG format by
default) in the working directory, using the software renderer.
The file naming starts from "screen0".

Arrows - Move
The arrow keys will move your character and allow him/her/it to
interact with most objects in most games.

Space - Shoot
By default, one uses this key in conjunction with an arrow
key to fire a weapon in the selected direction. Weapons and
spacebar uses vary from world to world.

Del - Bomb
By default, this will drop a bomb of the current type BENEATH
the player. Move out of the way to activate it, then run before
it explodes! Uses of the del key vary from game to game.

Tab / Left Arrow / Right Arrow - Select Option
In yes/no dialog boxes, these keys toggle between yes and no.

Other games may have other controls, such as 'S' to cast a
spell or 'A' to jump, but they should be detailed within the
game.

The following keys are active at the title screen:

F1 - Help (see above)

Enter - Menu
This is similar to default Enter within the game. However,
it brings up a list of key bindings instead.

ESC - Exit MegaZeux
Pressing ESC will exit MegaZeux.

F2 or S - Settings (see above)

F3 or L - Load World
This will allow you to load up the title screen of any MegaZeux
world. A list of choices will be presented to you to select
from. After the world is loaded, you may watch the title
screen, then press 'P' to play.

F4 or R - Restore Game (see above)

F5 or P - Play Game
This will stop the title screen and actually begin game play.

F7 or U - Updater
This will load the updater. The updater will connect to an
online repository and check if a new MegaZeux version is
available. If so, the user gets the option to update MegaZeux.
MZX will then list the files added/changed/deleted in the
update, and if the user decides to update, MZX will restart
when the update is finished.
WARNING: This will most likely replace your config.txt file, so
if you want to keep your settings, make a backup first so you
can apply your settings to the new file!

F8 or N - New World
This will quit the gaming portion of MegaZeux and enter the
integrated World Editor, set to an empty MZX world.

F9 or E - Edit World
This will quit the gaming portion of MegaZeux and enter the
integrated World Editor, set to edit the currently-loaded
world. Note that "MZXRun" builds of MegaZeux will disallow
using the editor. For detailed info on using the World Editor,
view the appropriate help sections.

>#THEWORLD.HLP:1st:The World Editor

F10 - Quickload (see above)

>#MAIN.HLP:072:Table of Contents
#NONDESCR.HLP
:091: 
$~9Nondescript Play Tips

Some basic play tips:

First, let me warn you that many worlds you get from archives
or (especially) from personal webpages may not be of acceptable
quality. They may be unfair, boring, have numerous bugs, and/or
not give proper instructions. My advice is to email the
author(s) and politely tell him/her/them what you think of poor
quality MegaZeux games. There is no problem in MAKING poor
games, but PLEASE think before uploading them, even in these
days where games are fewer and farther between. Really old
games of bad quality, on the other hand, are tolerated somewhat
better. Don't let a few dull games ruin the fun.

~A*~F RTFM (Read the Flipping Manual). Whatever information
 the game has to give is probably important. Some authors
 include info files in their distributions; make sure these
 are read. It saves everybody time and effort. To authors, it
 saves time and effort to include such files in your
 submissions.

~A*~F Make sure you visit every screen possible.

~A*~F Touch everything! Even things of seemingly little value
 may prove worthy of your attention. If it kills you, then...
 well... hope you saved. Yell at the programmer who thought an
 instant kill was worth using regardless!

~A*~F Save your game! It is rather simple - in most games,
 Press F3 to save your game to disk at the EXACT point you are
 [if allowed]. Press F4 to reload a saved game. You can use F9
 and F10 to quick-save and quick-load, which work on the last
 game you saved. Remember to save often - If something ends
 your game, you'll want to lose as little progress as possible.

~A*~F Collect supplies! Make sure you grab every coin, gem,
 ammo dump, bomb, chest, pouch, and foobar you see! You will
 often be in want of supplies, so don't push things.

~A*~F Remember how things work. Most things in MegaZeux have
 patterns, even Robots, and the same object will usually do the
 same thing all the time. (However, two objects may look alike
 and not really be the same thing.)

~A*~F Don't take anything for granted. If it looks like a spike,
 it probably is. _Probably_. Although it is rare that these
 types of puzzles must be solved to complete a game, there
 are often bonuses, hidden rooms, etc. behind illusions.

~A*~F Try things twice, even thrice. Sometimes objects respond
 differently at other times. If you get a new treasure, go
 talk to all the citizens - maybe one of them will say
 something new.  If some place seems inaccessible, come back
 later!

~A*~F If doing the same thing over and over keeps failing, try
 something else. It helps to look at new methods and to put
 distance between yourself and the problem.

~A*~F If all else fails, look in the game with the editor. This
 depends on the clarity of the author(s)'s code, but looking in
 the editor can help if all other solutions have been
 exhausted.

>#MAIN.HLP:072:Table of Contents
#MOUSESUP.HLP
:1st: 
$~9Mouse Support in MegaZeux

Use of the mouse is very simple. Move the mouse to move the
mouse cursor. Press the Left mouse button to select something,
activate something, etc. Press the Right mouse button to grab
whatever's under the cursor in the World Editor. Certain games
may make use of the mouse during gameplay; the scroll wheel,
while unused in games, emulates up/down presses in dialog boxes
and the list menu.

>#MAIN.HLP:072:Table of Contents
#BUILTINS.HLP
:1st: 
$~9The Mirth of Built-ins

The following help section contains a list of the different
objects, enemies, items, and terrains you will find within
the different MegaZeux worlds. Outside of a select few
built-ins, such as certain terrains, Robots and items, heavy
usage of these built-ins is suited for beginners and savants
only.

$@0~8± ~FTerrains~8 ±@8

~BSpace

This is the simplest terrain; it does absolutely nothing!

~BNormal         ~A@0²
~BSolid          ~EÛ
~BTree           ~A
~BLine           ~FÍÍÍÍÍ
~BCustom Block   ~7?

These are all basic walls; they just get in the way. Sometimes
trees can be burned down.

~BBreakaway      ~C@0±
~BCustom Break   ~7?

These block movement as well, but they can be destroyed with
most weapons (such as bullets or bombs). Certain other things
can destroy them as well.

~BFake           ~A²
~BCarpet         ~4@0±
~BFloor          ~9@0°
~BTiles          ~0@Fþ
~BCustom Floor   ~7?

These are all treated as flooring, or "background". Anything,
including yourself, can move onto and over these. They are
primarily for decoration.

~BWeb            ~7Å
~BThick Web      ~7Î

These are another type of flooring. However, webs are often
the home for spiders, so watch your step!

~BForest         ~2@0²

This terrain will block the path of almost any built-in. You,
however, can move through it with ease, clearing a pathway.
Enemies can move along a cleared path.

~BInvis. Wall

This LOOKS like just an empty space... until you bump into it.
Then it becomes a normal wall, blocking your path.

$@0~8± ~FItems~8 ±@8

~BGem            
~BMagic Gem      

Your total number of gems is shown on the status screen, and
each gem gives you one point. Many older games also use them as
a type of currency, where you can trade gems for stuff like
food, ammo, weapons, or hints. Magic Gems also give you one
health point apiece when taken.

~BHealth         ~C

This will improve your outlook dramatically. Your health is
increased by a certain amount. The amount varies for different
hearts. Keep in mind that if you're currently at your maximum
health, running into a heart will still collect it.

~BEnergizer      ~1›

After grabbing an energizer, you will flash colors for a
limited time. During this period, you are invincible against
enemies, bullets, fire, and most other built-in forms of pain.
Be careful not to get into a dangerous situation as your energy
runs out!

~BAmmo           ~3£ ¤

When you grab ammunition, it will add a certain amount of
ammo to your supplies. The amount may be different for
different piles.

~BBomb           ~0

Each bomb you grab adds another to your supply. The sound made
when you grab the bomb will be high-pitched for a high strength
bomb and low-pitched for the rare low strength bomb.

~BKey            ~A

Collect keys to open locks, doors, and gates later on. The key
and the lock/etc. must match colors, and a key will only work
once. You can carry up to sixteen keys at once. The default
status screen, if viewable, will show your current supply of
keys.

If you've played ZZT games, you'll be interested to know that
you can carry multiple keys of the same color.

~BLock           ~A

A lock will only open if you have a key of the same color to
unlock it. The key can only be used once and will disappear
along with the lock.

~BCoin           ~E
Collecting coins is a good idea- they not only increase your
score, but can usually be used to purchase valuable items or
services from vendors.

~BLife           ~B›

A life orb will give you yet another chance for survival in
MegaZeux. Keep in mind that if you're currently at your maximum
amount of lives, running into a life orb will still collect it.

~BPouch          ~7Ÿ

A pouch is usually filled with coins and gems. The amount
varies, but often you will find yourself pleasantly rich....

~BChest          ~6 

A chest can contain numerous things. The contents will be one
of the following: Empty, a Key, Coins, Lives, Ammo, Health,
a Potion or Ring, Bombs, or Gems. Once you grab the contents,
the chest itself will remain, but be empty.

~BRing           ~Eo
~BPotion         –

These mystical items will bestow a magical effect on you when
you wear or drink them. The effect, however, is unknown to
you until you try it... and some effects aren't so nice.
:prx:
$@0~8± ~FPotion and Ring Effects~8 ±@8

Effects are limited to the current room only, except for
healing, hurting, and invinco.

~BNo Effect

This effect does absolutely nothing.

~BInvinco

Just like an energizer, you will become invulnerable to most
forms of pain until you stop flashing.

~BBlast

Scatters plentiful, random explosions around the screen.

~BHealth x10
~BHealth x50

Gives the player 10 or 50 additional health points.

~BPoison

Reduces the player's health by 10.

~BBlind

Temporarily blinds the player. The viewport will appear in
dark gray. You can still move and interact, but you won't be
able to see anything but yourself.

~BKill Enemies

Kills all enemies in the room, including "Invincible" enemies.

~BLava Walker

Allows the player to temporarily walk on lava and fire.

~BDetonate

Explodes all bombs and lit bombs in the room.

~BBanish (Dragons)

Turns all dragons into ghosts.

~BSummon (Dragons)

Turns all enemies into dragons.

~BAvalanche

Scatters boulders randomly around the screen.

~BFreeze Time

Freezes ALL on-screen objects (including Robots) except for
the player, for a short time.

~BWind

The player retains normal control but will also move around
a bit randomly for a while; the wind will blow the player in
all directions.

~BSlow Time

Slows ALL on-screen objects (including Robots) except for the
player, for a short time. The resulting speed is approximately
half normal speed.


$@0~8± ~FCreatures~8 ±@8

~BSnake          ~2ë

~BRunner         ~C

A snake moves in a straight line until it hits an obstruction,
then aims itself in another direction and continues. Hitting a
snake (like all enemies hereafter unless noted) will cause you
to lose 10 health, then kill the snake. Runners act like snakes
and will take up to four hits, but will only go the opposite
direction when obstructed.

~BEye            ~Fì

An eye chases you down like any ordinary enemy, but when it
catches you or dies, it explodes! The size of the explosion
varies with each eye.

~BGhost          ~7ê
~BThief          ~C

A ghost is the simplest enemy, simply chasing you. While some
of them are invincible, most can be killed. Thieves chase but
don't do damage. They steal your gems on touch instead, and can
do so multiple times until killed.

                ~A*
~BSlime Blob     ~A*±*
                ~A*

A slime blob usually doesn't hurt you, but it can quickly
become incredibly annoying because of its habit of dividing
into more slime blobs, then hardening into "solid slime"
(i.e. breakables), quickly filling rooms.... You can often
kill slime by touching or shooting it, but some slimes can be
invincible.

~BDragon         ~4 ~C ~E*~C

Some dragons move around slowly, but their main advantage is
their offense - they can shoot barrages of scorching flame.
Dragons also have a strong defense, taking up to eight hits to
kill. Touching them will take 10 health, but will NOT hurt the
dragon.

~BFish           ~Eà
~BShark          ~7
~BSpitting Tiger ~Bã  ~Fù  ù ù

Fish have to stay in the water and often won't hurt you. Those
that can, however, will hurt you if you're adjacent to them,
even if you're not in water. Some fish take two hits to kill.
Sharks, however, swim in lava or goop, are always hostile, and
can attempt to shoot you with fire, bullets or seekers.
Spitting Tigers are landborne versions of sharks.

                ~0ÚÅ¿
~BSpider         ~0ÄÅ~7•~0ÅÄ
                ~0ÀÅÙ

Spiders, although eager to catch you, are usually restricted to
movement on webs. Certain spiders, however, can actually leave
the webs. Some spiders take two hits to kill.

~BGoblin         ~2

Goblins chase but periodically stop, making them an easy
built-in villain.

~BBear           ~6¬

Bears only move if you get too close, then they lumber over for
the attack. Many require 2 hits to kill.

~BBear Cub       ~6­

Bear cubs are very lively, rushing all over the place. Since
they move so fast in a seemingly random manner, they are often
hard to kill.

~BBullet Gun     ~F” ” 
~BSpinning Gun   ~C~E* ~F

Bullet and spinning guns, both indestructible, fire any type of
normal projectile (bullets, fire or seekers); the bullet gun,
however, is fixed while the spinning gun can fire from all
cardinal directions.

~BLazer Gun      ~0Î~1‚~9‚~3‚~B‚~F‚‚‚‚~7‚

The indestructible lazer guns fire off lazer walls at regular
intervals, and sustain these walls for a specific length of
time. Unlike in ZZT, getting hit by a laser does not push the
player into objects, though it will push the player if a space
is open. The beam can be obstructed by nearly anything not a
ground type, even including a bullet.

~BMissile Gun    ~0

Missile guns fire missiles in one direction. Some fire just
once while others can fire missiles indefinitely. The gun
itself is indestructible.

$@0~8± ~FPuzzle Pieces~8 ±@8

The following objects are often used to create mind-twisting
puzzles requiring you to push objects all over the place to
reach a goal. Be warned.

~BBoulder        ~7é
~BCrate          ~6þ
~BCustom Push    ~7?

Boulders and crates can be pushed in any direction, with any
number of pushable things in a row. They can be blown up.

~BBox            ~Fþ
~BCustom Box     ~7?

Boxes can also be pushed in any direction, but cannot be blown
up.

~BPusher         ~0 ~7þþþ

Pushers cannot hurt you, but they constantly move in one given
direction, pushing almost anything in their path - Boxes,
crates, and even you!

~BSlider NS      ~E
~BSlider EW      ~E

Sliders can be pushed also, but ONLY in the pointed direction,
Slider NS can only be pushed north/south, while slider EW can
only be pushed east/west.

$@0~8± ~FTransport~8 ±@8

~BStairs         ~F¢
~BCave (or door) ~0¡
~BWhirlpool      ~9@1—

When you enter any one of these, you are transported to another
location within the current world. These are not always
two-way connections.

~BCW             ~A/
~BCCW            ~A\

These rotate in the given direction (ClockWise or
CounterClockWise) rotating everything around them at the same
time. Walls and other solid objects will not be affected.

                ~Fv
~BTransport      ~F} {
                ~F~~

Most transporters face a single direction. Entering these on
the "open" side, or pushing other things into them, will
transport to another location. Some transporters rotate 360
degrees and can be entered from any side.

The destination of your transport is somewhat complex, but the
search pattern is as follows:

1. If the other side of the entered transport is empty, move
  there. If there is something there that can be pushed out
  of the way, move there and push it out of the way.
2. If the other side is blocked, continue in that direction
  looking for the first non-blocked transporter facing the
  OPPOSITE direction, or an "any-direction" transport.
3. If neither condition can be met, no transport takes place.

$@0~8± ~FElements~8 ±@8

~BStill Water    ~9@1°
~BN Water        ~9@1
~BS Water        ~9@1
~BE Water        ~9@1
~BW Water        ~9@1

Water is a type of floor that can be moved onto by you, some
enemies, and certain other objects. Often water has a current,
moving you constantly in a certain direction.

~BIce            @3\

Ice is another type of floor. However, you slip on it,
constantly moving in the last direction you moved.

~BLava           @4~C±²°±²

Lava is another floor. However, it is (almost always) very
deadly. Only a few things can survive over it.

~BFire           @0~C±°~E²±~C²

Fire is yet another type of floor. It often will spread across
the floor, enveloping trees, chests, and sometimes even empty
space. It is painful to stand near (or worse, on), but usually
it does not mean instantaneous death. Most fires will
eventually burn out.

~BLit Bomb       ~0«
~BMine           ~4

A lit bomb is an explosion on a fuse. You DON'T want to be
nearby when the fuse runs out... mines, on the other hand, only
blow up when touched or exploded.

                 ~F@E±
                ~F@E±~C±~F±
~BExplosion      ~F@E±~C±@4±@E±~F±
                ~F@E±~C±~F±
                 ~F@E±

An explosion starts at a certain point, quickly spreading
outward, wreaking havoc in its wake. Some explosions are
smaller than others. Explosions will also cause explosives
such as bombs to explode, leading to some very cool chain
reactions.

~BGoop           ~8@1°°°

Goop is pretty much non-traversable terrain to anything,
although sharks may occasionally inhabit it. Bullets, lazers,
and other projectiles will traverse it freely. Goop may also be
treated as water or other terrains in certain worlds.

$@0~8± ~FMiscellaneous~8 ±@8

~BDoor           ~2±²Û~AÄ~2Û²±
~BGate           ~7±²ÛÛ²±

A door is what you would expect - When you touch it, it will
open itself, pushing obstacles in its path out of the way, and
then closing after a brief pause. Doors require two free spaces
in the direction it moves to open fully. Certain doors are
locked and require you to use a key to open them. They then
remain unlocked. Gates act similarly, but do not move; they can
be crossed directly when open.

~BRicochet Panel ~0/
~BRicochet       ~A*

When a bullet hits a ricochet panel, it is reflected to travel
in a new direction, depending upon the way the panel is facing.
When a bullet hits a ricochet, it is reflected back in the
original direction. Any bullet that hits a ricochet panel or a
ricochet will have its type set to neutral when reflected.

~BSpike          ~7
~BCustom Hurt    ~7?

Spikes and other painful devices will simply hurt you if you
touch them. These are often used in conjunction with ice or
with sidescroller engines.

~BText           ~7?

Another type of wall. Cannot be walked on, but can provide
hints or other enlightening messages.

~BMoving Wall N  ~7?
~BMoving Wall S  ~7?
~BMoving Wall E  ~7?
~BMoving Wall W  ~7?

Moving walls are like Runners - They just move back and forth,
to and fro... they can't hurt you by touch, but can get in the
way very easily.

$@0~8± ~FObjects~8 ±@8

~BPlayer         @1~B

This is you. Really. Well, sometimes. The player is often
locked, with a Robot or sprite representing the player
character, but the player object is always present.

~BScroll         ~Fä
~BSign           ~6â

Touch this to read a message. A Scroll will disappear after
you finish reading it; signs will not.

Unlike in ZZT, scrolls and signs are text-only: they cannot
execute any commands.

~BMissile        ~0

Missiles fly around the room, turning at obstructions. They
will explode if they hit you or when they cannot turn.

~BBullet         ~F“

Bullets will fly in a straight line until they hit something
(and disappear) or do damage to someone or something. Ricochets
can change the direction a bullet is traveling in, as well as
change its type to neutral. There are three types of bullets:
Player (the player shoots these by default), Neutral (Robots
shoot these in a default shoot command), and Enemy (built-in
enemies shoot these by default). Player bullets cannot harm the
player; Enemy bullets cannot harm default enemies; Neutral
bullets can harm both the player and default enemies.

~BSeeker         ~A|

A seeker, thrown by a Tiger, Shark, or other enemy, will chase
you all over the screen until they collide and do 10 damage.
They have a limited life, however, and will expire after a
certain amount of time. They are still, however, one of the
deadliest weapons you will face, enough so that more than only
a few at once can easily ruin a game.

~BShooting Fire  ~C ~E*~C

Shooting fire will continue in a straight line until it hits
you, resulting in pain, or a wall, resulting in a small fire.
The fire may quickly spread out of control in some areas, or
just burn out in others. Bullets can sometimes destroy shooting
fire, but other times the shooting fire simply absorbs the
bullet.

~BSensor         ~7?

Sensors are a form of floor that only you can move onto. They
will usually then produce some form of effect, by interacting
with a Robot; other times they act as "save points".

~BRobot          ~7?
~BPushable Robot ~7?

Robots are the workhorses, the artisans, the... nearly
everythings of MegaZeux. They are highly flexible objects
which can do almost anything. They utilize their own full-scale
programming language, dubbed Robotic. If another object can
do something, a Robot can almost always do it better. They can
show messages, fight the player, play music or sound, set the
entire gameplay structure, and do countless other things. See
the appropriate help sections for more information.

>#ROBOTSWH.HLP:1st:Robots - What They Are and How to Use Them
>#MAIN.HLP:072:Table of Contents
#CONFGINI.HLP
:1st: 
$~9MegaZeux Options

Now you should be familiar with MegaZeux enough to where you
might want to change some of its options. Go open config.txt in
any text editor.  There is ample commentary to let the user
know how to change the options.  Make sure to remove the # sign
from any option you want set!

Editing the options can result in better sound, better / more
customizable graphics, more fitting defaults, a more
personalized Robotic editor, joystick support, extended macros, 
automated backup and much more.

>#MAIN.HLP:072:Table of Contents
#IFYOUFIN.HLP
:1st: 
$~9If You Find a Bug...

...we want to know! We're very interested in any problems or
bugs you find in MegaZeux. We also welcome any comments,
criticism, or suggestions. We especially appreciate QUALITY
MegaZeux worlds. Here's the contact information as of this
writing:

Check the reports on DigitalMZX's Bug Tracker
(http://www.digitalmzx.net/forums/index.php?app=tracker) to see
if your problem has already been addressed. Active problems are
listed, as of this writing, in the "MegaZeux" category, while
the fixed bugs are in the "Closed MegaZeux Bugs" category.

To make things sane for all parties, do this before submitting:
  1) Make sure you have the most current version of MegaZeux.
  2) Make sure that the Bug Tracker doesn't address your bug.
  3) Try to write down what specifically happens.
  4) List what platform(s) you know show this problem.
  5) Try to pinpoint the problem to a specific Robotic line or
     MZX function; at the very least, try to narrow it down. 
     Pinpointing which version introduced the bug is very
     helpful, if possible.
  6) If it is a crash, try to run a debug build through GDB and
     post a backtrace of the crash.
  7) If you're unsure if the bug's been addressed, try to build
     a version from GitHub's GIT repository and see if the bug
     is still present in the test build.
  8) Optimally, if the problem is a regression caused by the
     port, upload a world made in 2.70 that works in 2.70 but
     does not in the current version to best isolate the
     problem.

>#MAIN.HLP:072:Table of Contents
#FAQ.HLP
:1st: 
$~9Frequently Asked Questions

The following is a list of questions that have been received
through mail, E-mail, or message board posts about MegaZeux
innumerable times..

Q: I hate that MegaZeux is always windowed! Could you change
  this?

A: There's already a way to switch between fullscreen and
  windowed modes - press Ctrl+Alt+ENTER.

Q: How can I get option (foobar) in the config file to work?

A: Make sure the pound / hash sign in front of the command is
  deleted. Otherwise, the option is treated as a comment and
  ignored.
  
Q: Are there any MZX-specific tools that can make developing an
  MZX game easier?

A: Yes, plenty! MegaZeux comes with two helpful tools: 
  "Checkres" will detect what files referenced by an MZX world
  are present, and "downver" can change the given MZX world's
  version to its preceding version. There are several graphical
  conversion programs such as CharCon, and SMZX palette tools
  such as Palzor and PalMaster.  
  MZX has natural time-savers, of course. Automated backups,
  macros, Robotic code import/export, expressions, repeated
  block copying and other features can help speed up
  development time.
  
Q: This MZX game has some neat things in it! Can I use some of
  these things in my own game?
  
A: It's usually okay to do this, as long as you give definite
  credit to the original creator(s). Unless MZXers made it,
  music and sound generally don't need direct attribution, but
  re-used artwork and code definitely should get attribution.
  If you're unsure whether the original creator(s) would like
  you using their work in your own game, ask! What we don't
  want to see, though, is passing other's work, especially
  graphics and code, as your own. DON'T PLAGIARIZE. JUST
  BECAUSE THEY DID NOT EXPLICITLY FORBID YOU FROM USING THEIR
  WORK DOES NOT MEAN YOU CAN PASS IT OFF AS YOUR OWN.

Q: Can I distribute a world I made with MegaZeux? Is it legal?
  Must I/can I include MegaZeux with it? Can they be shareware
  worlds?

A: Of course you can distribute your worlds! That is what
  MegaZeux is for! Please refrain from uploading worlds that
  you made as a novice user if they contain only built-in
  enemies, items, no plot, etc. and ESPECIALLY if only you
  (and/or a best friend) have tested it. People will likely
  yell at you, especially if the game is buggy. Get creative
  and make your game worth playing! Please include any WAV,
  module, OGG, CHR, MZM, PAL and all other files with the
  games, as well as a cohesive and helpful TXT description
  file. Make sure that you include MegaZeux on your website if
  you're posting your game there, or make sure to post to a
  large MegaZeux archive. Typically, MegaZeux worlds are
  freeware, but if you've made an assuredly epic and
  ground-breaking game, then you can attempt to ask for
  registration money in a shareware demo version. Just don't
  get your hopes up.

Q: I WANT FUNCTION (FOOBAR) ADDED OR I LEAVE THE COMMUNITY
  FOREVER :<

A: Before you go bugging the maintainer(s) of MegaZeux to add
  new functions, consider these things:
  1) Some things require massive work to implement. These
     things require changing the world, save or board format,
     and format changes are explicitly reserved for version
     number changes.
  2) Some things have been purposely ignored because the
     maintainer(s) deems these things not worth including. In
     this case, it's probably best to pick up the source and
     figure out how to add this function yourself.
  3) You may not be the first to ask for any certain feature.
     Current feature requests are listed in DMZX's Bug Tracker.
     If you are not the first, then you'll often find out why a
     feature is not implemented or, better, you'll end up
     finding out that it is going to be implemented after all!
     Either way, you learn more about the feature and what
     would need to be done to include it.
  4) It's technically possible to add new commands, but
     currently the method of storing Robotic severely limits
     the amount of new commands. Until this system is retooled,
     there will be no new commands.
     
Q: Is adding network capabilities to MegaZeux planned?

A: Short answer: Not really. This has been discussed at-length;
  the biggest problems with adding these to GAMES are thorny
  implementation issues (how the MZX programmer would insert
  network capabilities into a MegaZeux world, as well as the
  structure in general). It's definitely possible, and possible
  to do soundly, but developers don't have netplay as a high
  priority. As for other networking capabilities and MZX, this
  has already been done to some extent (starting with 2.82b,
  MZX ships with an updater program). Implementing tools and
  aids for MZX relying on networking is a lot less thorny of an
  issue, and might be considered.

Q: Will MegaZeux games ever be playable without MegaZeux
  itself?

A: Likely not. It's a consensus among most developers that the
  possible hassle saved for newbies and for those who would
  instantly refuse to play a game because it can't be launched
  directly is not worth implementing this feature.

Q: I need more than 256 characters! Could you help with this?

A: Then you'll need to carefully utilize the Robot command
  LOAD CHAR SET and ration your characters carefully. The
  256-char limit is set within the world format and will
  currently be left alone. Also, you might not REALLY
  need 256 characters at once. If you're wanting more
  characters because of heavy character use in animation,
  partial character set loading will probably be the best
  solution. Otherwise, find out which characters will never be
  shown when other characters are and replace them with
  characters you WILL use (such as the alphanumeric
  characters).
  
>#PARTIAL.HLP:par:Partial Character Sets
  
Q: Why is my MegaZeux world starting on the title screen?

A: The first board has to be set. Press 'G' in the editor, then
  set the board using the "First board" field at the top left.
  
Q: Whenever I place a string on the overlay, the spaces aren't
  acting like overlay at all! Is this a bug?

A: No, it's not. Char 32 (the natural space) is never part of
  the overlay. You have to reserve an extra character or use
  the solid character for spaces, or otherwise convert spaces
  to useable replacements during run-time.

Q: How can I input a number over 32767 or under -32768 in
  Robotic?

A: You must use an expression. Encase the number in
  parentheses, as shown here:
  ~Eset "largesse" to "(2000000000)"
  
Q: My Robot can't change its/the player's characters! I
  use CHAR "A" but it turns invisible! What am I doing wrong?

A: Use CHAR 'A' instead. You MUST use single quotes
  (apostrophes) or it will use the value of the COUNTER
  A, which is probably 0.

Q: Can I use the music from Caverns in my games? How about
  the music from the registered games? How about the SAM
  files?

A: It'd be preferred if you did not use Caverns music in any
  games you distribute, because Caverns music was ancient aeons
  ago. The music from the registered games was illegal to
  distribute; it's now under the GPL, but should be avoided for
  the same reasons Caverns music should. The SAM files are
  public domain and may be used as you please.

Q: Where can I get module files?

A: If you can't make them, search webpages for good ones.
  http://www.modarchive.com has a very large tracked music
  library, as do many older CD-ROM collections. Another popular
  option is to employ a friend to do it for you. If your game
  shows exceptional promise, then an established tracker in the
  community might make music for you. You will actually have
  to... show real evidence that your game is as good as its
  hype in most cases, however. In any case, remember to give
  credit where it is due (yes, even to yourself). Be careful
  when inserting OGG files into your game. OGG files often
  present considerable bloat to a game if used as music. Also,
  not only may you be chided for putting in a popular song if
  you do so, but you could be violating copyright law. Chances
  are that if you can make a coherent argument on "fair use" of
  copyrighted songs, you will be far less likely to be in this
  position to begin with. <3

Q: What is some good software to create module files?

A: It's a matter of personal preference. Many people prefer
  OpenMPT because it works well with Windows. Others prefer to
  work with Schism Tracker. Finally, a few are still fond of
  Fast Tracker II, and therefore use the similar MilkyTracker.
  Be advised that DOS-based trackers like IT and FT2 might not
  work well with an NT-based Windows system, and will likely
  not work at all with a 64-bit OS.

  If you don't mind pumping up your game's filesize, you could
  use any normal composition software (like FL Studio) and
  convert your wave to ogg format.

Q: How do I make WAV files?

A: There are three easy ways to create WAV files. First, you
  get recording software, a sound card, and a mike. Hook 'em
  all up (read the instructions) and go for it. Second, you can
  download them or get them from outside sources (such as The
  Freesound Project). Third, you can take existing files and
  change them with effects like echo. Converting .wav files
  intended for sound effects into OGG format is a worthwhile
  idea; the drop in file size compared to the drop in quality
  is huge.

Q: Why do I get garbage when I try reading a file?

A: You likely have it open for writing. To close a file, use
  the command SET "" to "FWRITE_OPEN".

Q: Why does MegaZeux slow to a crawl or even lock up completely
  when I set the "commands" counter to a high value?

A: You're likely using an idle loop without a CYCLE 1 or WAIT 1
  command inserted. Add one; if you're wary about possible
  delay effects, rest assured that adding either of these will
  not unnecessarily add delays. It will simply end a cycle.
  
Q: I heard only certain graphics cards can properly show Super
  MZX mode games. Is this true?

A: Not anymore. Any computer that can display normal games in
  MegaZeux can now display Super MZX mode games.

Q: How can I get "mod *" to work?

A: Alt+8 and Alt+*, the old "mod *" keys, have a new function
  now. To "mod *" in the port, use either Shift+8 or the
  asterisk (*) on the numpad.

Q: What's with these "~~roboclp.tmp" files packed with so many
  games?

A: Those held clipboard information in DOS versions of MegaZeux.
  They are useless and should be freely deleted.
  
Q: Why doesn't [ work for taking screenshots?

A: It has been changed to F12 and now works in any area in MZX,
  including any part of the editor. It currently outputs PNG
  files by default, but will output MS BMP format files on
  platforms unable to support PNG.

>#MAIN.HLP:072:Table of Contents
#MEGAZEUX.HLP
:1st: 
$~9MegaZeux Limitations

MegaZeux has to impose a number of limitations to insure
worldfile compatibility with MZX 2.x worldfiles.

$Memory Limitations

No single Robot, sign, or Scroll can exceed 64k in size
(including the global).

$Quantity Limitations

Item:           Largest number allowed:

Robots              255 per board plus Global Robot
Scrolls/Signs       255 per board
Sensors             255 per board
Boards              250 per world
Local Counters      32 per Robot plus specialized local counters
                    (loopcount, lava_walk, bullettype)

$Length Limitations
                
Robot Name Length   14 characters
String Length       4,194,304 characters (4 megabytes)
Editor Line Length  241 characters (INCLUDING "extra" words)
* Message Length    512 characters
Input String Length 512 characters
Mod Filename Length 512 characters (including subdirectories,
                    if applicable)

$Theoretical Limitations

Board size maximum is roughly 16.7 million characters (2^24).
Vlayer size maximum is roughly 16.7 million characters (2^24).
Board width or height maximum is 32767.
The maximum number of counters and strings depends on
the platform (e.g. between 32 or 64-bit) but is sufficiently
large. You should be fine putting this into the hundreds of
thousands if not millions.

These limitations are mostly theoretical because of the utter
improbability of meeting these limits and the amount of RAM (up
to gigabytes if fully utilized) they consume.

$Other Limitations

Numbers less than -32768 or more than 32767 cannot be directly
used in Robotic. This problem is a worldfile issue and can be
circumvented by using a constant expression (parentheses).

No board can have a width of a multiple of 256 chars because
this corrupts the board if it lacks an overlay. This problem is
a worldfile issue and widths set to a multiple of 256 will
increased by one more horizontal character regardless of the
status of the board's overlay.

>#EXPRESS.HLP:exp:Expressions
>#MAIN.HLP:072:Table of Contents
#THEWORLD.HLP
:1st: 
$~9The World Editor

Ready to start creating your own worlds? Then, let's get
started! This section is a short editor tutorial. It will
teach you the basics of creating your own worlds.

To get into the editor, press E from the title screen. You
will be presented with a blank board with a small menu at the
bottom. You can use PageUp and PageDown to change the
currently shown menu, and you will be presented with various
keys and options. The mouse also works here. Feel free to
fool around with these various options. Press Alt+R to restart
and clear everything.

For your first world, you should start simple. The screen you
begin on is your title screen, so pick a simple name for your
game, such as "Redolent Obsequience". Press I for board info.
This screen will display a bunch of options; the important
option is the "Board name" option. Type in the name of your
game and then click on "OK" or press Tab until OK is
highlighted and press Enter. Now that the title screen is
named, its design begins... or is put aside for later (or even
the end).

Now you need to create the first playable board, or location,
of your game. Press A to add a board, then type in a short
description of the board, such as "Starting Board". Press Enter
to go to this new board.

Now you are free to doodle around. Use C to change the active
color. Use F3 through F9 to bring up menus of items, terrains,
and creatures. Selecting one with the arrows and Enter will
allow you to place it using arrow keys and space.

For example, press F3 for terrains, and select Line. (This is
a form of wall.) Now move around, placing walls. To ease
this, you can press Tab to toggle draw mode. When draw mode is
active, every move of the cursor will place the current
item/color. The current item and color is shown on the top
line of the menu.

Try to create a pleasing-looking screen, regardless of its
planned function. Some items will require that you set settings
to determine their behavior. To place the player's starting
position, move the cursor to the destination, press F10, and
select Player. Alternatively, press Enter while highlighting
the Player and press Space on the desired destination.

When you are done, press G to go to the Global Info screen.
TAB to the Next button and press Enter. You will now be
highlighting the option "First Board". Press Enter, and select
the starting board (this is where gameplay starts... NOT the
title screen in the vast majority of cases) from the list and
press Enter. Then TAB to OK and press Enter.

You could now press Alt+N to select a module (music) file for
the board, if you wish. Then press S to save the world, and
type in a filename. (The extension of .MZX will automatically
be added.) Press Enter to save the world. Press ESC to exit the
editor, and now you can play your game! You can use L to reload
your world in the editor to make changes, if necessary. See
General Editing Tips for more advanced editing info.

New in the 2.8+ line of MegaZeux is the protection of colors
and characters the editor uses. The editor uses sets outside of
the currently used sets. The character set for the editor is
mzx_edit.chr; edit if you want to change the editor's
appearance. Colors revert to the current colors in SMZX modes,
however.

>#GENERALE.HLP:1st:General Editing Tips
>#MAIN.HLP:072:Table of Contents
#GENERALE.HLP
:1st: 
$~9General Editing Tips

The following is a list of important editing tips. They assume
you are familiar with MegaZeux's dialog box system, and that
you can navigate the editor's menus.

$Linking Boards

Simple, one-board games can get boring REALLY fast. There are
four ways to connect multiple boards.

A simple method of connecting boards is with X, the Board Exits
dialog. Here, you can select boards that you will reach if you
walk off of the screen in a given direction. The destination
board shouldn't have anything in the way, and will not
automatically lead back- you must set the exit on that board
too.

Another way is to use a Robot to teleport a player with the
~Ateleport player "boardname" X Y~F command.  This assumes that you
are familiar with using Robots, but is the only way to go to
another board without having the player walk off-screen, into a
teleport or by reloading the current world. Robots can also
dynamically set board exits using the ~ABOARD [dir] "boardname"~F
command, where and even disable board exits.

>#COMMAND2.HLP:_t5:TELEPORT PLAYER "string" # #
>#COMMAND2.HLP:_b7:BOARD [dir] "string"
>#COMMAND2.HLP:_b8:BOARD [dir] NONE

The third way is to add stairs, caves and whirlpools using the
Transport (F7) menu. Then you select a destination board. The
destination board should contain a similar transport, leading
back. The two entrances will now lead to each other.

The last way, the most kludge-like, is to load the current
world in a 'swap world' command. This will send the player to
the starting board of the current world, but will restore the
world to its original state. Set counters and strings will be
preserved. This method is used for its powerful restorative
properties.

To switch to other boards, use B. To add boards, press A, or
press B and select (new board) from the board list.

$Board Sizes
:sizepos:
You can change the maximum size, and the view position, of a
board with Alt+P. Here you can move and re-size the view, or
center it on-screen.

You can also change the actual size of the board. The highest
possible size is 16.7 million tiles, though a board that size
would require unreasonably high RAM requirements (128MB). Note
that reducing the size of a board will permanently destroy
anything outside of the new limits.

$Other Important Editing Keys

You can use Ins to "grab" the object beneath the cursor, or
Enter to edit it and then grab it as well. Use P to modify the
settings of the object in the buffer. Use Alt+N to select music
for the current board, or turn the music off if it is already
selected. Use Alt+Z to clear the current board entirely (you
will be asked for confirmation). You can edit important Board
Options with I, and important Global (world) Options with G.

$The Mouse in the Editor
The left mouse button acts like space; it places a copy of the
current item over the mouse cursor. The right mouse button acts
like insert; it grabs the current thing over the mouse cursor.

>#EDITINGK.HLP:080:Editing Keys and Options Reference
>#MAIN.HLP:072:Table of Contents
#EDITINGK.HLP
:080: 
$~9Editing Keys and Options Reference

The following is an alphabetical listing of keys within the
World editor. This is followed by a detailed description of
what each one does.

>_A:A                    - Add (board)
>_B:B                    - Select Board
>_C:C                    - Color
>_D:D                    - Delete (board)
>_F:F                    - Fill
>_G:G                    - Global Info
>_I:I                    - Info (board)
>_L:L                    - Load
>_M:M                    - Move Board
>_P:P                    - Parameter
>076:S                    - Save
>_V:V                    - View
>083:X                    - Exits
>min:-                    - Goto Previous Board
>plu:+                    - Goto Next Board
>075:Alt+A                - Select Char Set
>073:Alt+B                - Block
>AltC:Alt+C                - Char Edit
>AltD:Alt+D                - Default Colors
>AltE:Alt+E                - Palette
>097:Alt+F                - Sound Effects
>AltG:Alt+G                - Edit Global Robot
>AltH:Alt+H                - Hotkey Toggle
>078:Alt+I                - Import
>AltL:Alt+L                - Test WAV
>AltM:Alt+M                - Modify
>AltN:Alt+N                - Music
>AltO:Alt+O                - Edit Overlay
>084:Alt+P                - Size/Pos
>AltR:Alt+R                - Restart
>082:Alt+S                - Status Info
>AltS2:Alt+S                - Show Level
>AltT:Alt+T                - Test
>077:Alt+X                - Export
>AltY:Alt+Y                - Debug Window
>AltZ:Alt+Z                - Clear (Board)
>AltNu:Alt+Number           - Load Editor Position
>CtrG:Ctrl+G               - Goto Position
>CtrN:Ctrl+N               - Test Music
>CtrNu:Ctrl+Number          - Save Editor Position
>Sft8:Shift+8 OR Numpad *  - Mod Wildcard
>SftAr:Shift+Arrow         - Goto Linked Board

>F1:F1  - Help
>F2:F2  - Text
>F3:F3  - Terrain
>F4:F4  - Item
>F5:F5  - Creature
>F6:F6  - Puzzle
>F7:F7  - Transport
>F8:F8  - Element
>F9:F9  - Misc. (thing)
>F10:F10 - Objects
>F11:F11 - Toggle Super MZX Mode
>F12:F12 - Take Screenshot

>ShF1:Shift+F1 - Show InvisWalls
>ShF2:Shift+F2 - Show Robots
>ShF3:Shift+F3 - Show Fakes
>ShF4:Shift+F4 - Show Spaces

>Ar:Arrow     - Move
>AltAr:Alt+Arrow - Move 10
>BkSp:BackSpace - Delete
>Del:Delete    - Delete
>End:End       - L/R Corner
>En:Enter     - Modify+Grab [Board Mode]
>Enter2:Enter     - Character [Overlay Mode]
>ESC:Escape    - Exit/Cancel Mode
>Home:Home      - U/L Corner
>Ins:Insert    - Grab
>Sp:Spacebar  - Place
>Tab:Tab       - Draw
>PgDn:PageDown  - Next Menu
>PgUp:PageUp    - Previous Menu

:_A:~EA - Add (Board)

Press A to add another board to the current world. You will be
asked for the name of the new board, and then a new board will
be created. The settings for the new board will be copied from
the current board: music, size, view, and the board info menu.
If you used A, you will now be spirited to the new board. There
is a limit of 250 unique boards per world.

:075:~EAlt+A - Select Char Set

Press Alt+A and select one of the four different character
sets. This will change the character set to one of the four
defaults. ASCII is the default EGA ASCII character set.
MegaZeux default is the default MegaZeux character set. Blank
is the MegaZeux default, but with most graphical characters
blank instead. Text, lines, arrows, blocks, and certain other
symbols are not affected. SMZX set is the default character set
for SMZX modes.

:_B:~EB - Select Board

Press B to change the current board by selecting from a list.
Selecting (new board) will create a new board and then select
it. Unlike A, the current board will stay the same once a new
board is created.

:073:~EAlt+B - Block

Press Alt+B to start block mode. Then move the cursor to the
opposite corner of a rectangular block, and press Alt+B again.
You can then select an action to perform upon the block. Copy
will allow you to duplicate the block by moving the cursor to
a destination and pressing Enter. The cursor marks the new
UPPER LEFT corner. Copy (repeated) will allow same as Copy,
but will allow copying the same block several times. Move will
allow you to move the block to a new location. Clear will
erase the contents of the block. Flip will flip the block
upside down. Mirror will flip the block left to right. Paint
will change the entire block to the current color. Copy
to/from overlay will copy the block to or from the overlay,
depending on where it currently is. Destinations for Move and
Copy can overlap the original block safely. Save as MZM will
save the block as a "board" type MZM.

You can block copy to other boards now by going to the desired
board when prompted to pick the destination of the block. Just
press B and pick the desired board.

:_C:~EC - Color

Press C to select a new current color from a menu. The thing
under the cursor is not affected.

:AltC:~EAlt+C - Char Edit

Press Alt+C to edit the character set. The character editor is
a separate section of the world editor and is discussed in
another section.

>#CHAREDIT.HLP:079:The Character Editor

:_D:~ED - Delete (board)

Press D to select a board from a list to be deleted. You cannot
delete the first board (the title screen). A deleted board will
be pruned out, with the next actual board taking its place. A
deleted board cannot be recovered, so make sure this is the
desired action.

:AltD:~EAlt+D - Default Colors

Press Alt+D to revert to the default colors. The palette prior
to the switch will be destroyed, so save the current palette if
keeping it is necessary. You will be asked for confirmation.

:AltE:~EAlt+E - Palette

Press Alt+E to edit the palette (colors). The palette editor
is a separate section of the world editor and is discussed in
another section.

>#PALEEDIT.HLP:093:The Palette Editor

:_F:~EF - Fill

Press F to fill in an enclosed area with the current thing and
color. The area must be completely surrounded by things other
than the thing beneath the cursor. For example, you can fill
over a solid square of Fakes with something else. The current
fill command may not work right for very large and complex
areas- in this case, you must move to the unfilled areas and
press F to continue filling. This happens very rarely,
however.  Also, beware of trying to fill an area with an item
with limited placements, such as a Robot.

:097:~EAlt+F - Sound Effects

Press Alt+F to enter the sound effects editor. This editor
affects all triggered sounds resulting from built-in actions,
such as getting hit and shooting. First you must decide whether
to use the default set of sound effects, or whether to edit
your own. You can't edit the default set. If you edit your own,
you will be in a series of three editing screens. Use the Next
and Previous buttons to move between screens. Sound effects,
and the format used to represent them, are described in detail
in another section. The format is the same as used for the
Robotic command PLAY. (Like with PLAY, digitized sounds are
allowed here.)

>#SOUNDEFX.HLP:1st:MegaZeux's Sound System

:AltG:~EAlt+G - Edit Global Robot

Alt+G will start editing the Global Robot, starting at its name
field.

:CtrG:~ECtrl+G - Goto Position

Ctrl+G will pop up a window, displaying target {x,y}
coordinates. Set the coordinates by either typing in or
selecting the desired X and Y values, and select OK to go to
those coordinates on the current board. Choosing Cancel or
pressing Escape cancels. 

:_G:~EG - Global Info

Press G to enter the global info dialog boxes. The global info
options are covered in another section.

>#GLOBALIN.HLP:086:Global Info Options

:AltH:~EAlt+H - Hotkey Toggle

Press Alt+H to toggle display of the hotkeys and horizontal
border. The default state of the hotkeys can be changed in the
config file.

>#CONFGINI.HLP:1st:The Config File

:_I:~EI - Info (board)

Press I to enter the board info dialog box. The board info
options are covered in another section.

>#BOARDINF.HLP:085:Board Info Options

:078:~EAlt+I - Import

Alt+I allows you to import a number of different file types
into the current board or world. You can import a board file
(.MZB) unique to MegaZeux. You can import a character set file
(.CHR). You can import another world (.MZX), which is appended
to the end of the list of boards. The global of the imported
world will be ignored. (Unlike old versions of MegaZeux, all
exits in an imported world will work.) You can import a palette
(.PAL) file or a sound effects (.SFX) file, both unique to
MegaZeux. Finally, you can import an MZM file at a given
position.

:_L:~EL - Load

L brings up a list of worlds in the current directory and allows
you to select one to load. You will be warned if the current
world as-is has not been saved yet.

:AltL:~EAlt+L - Test WAV

Alt+L brings up a list of WAV/SAM/OGG files in the current
directory. Selecting one will play it at its natural frequency.
This has no effect on the actual board or world.

:_M:~EM - Move Board

M moves the current board to the desired place on the board
list. The title screen cannot be moved, and other boards cannot
be moved to the title screen position.

:AltM:~EAlt+M - Modify

Alt+M allows you to modify the settings of the thing under the
cursor without changing the item in the buffer.

:AltN:~EAlt+N - Music

Alt+N brings up a list of module files in the current directory.
Selecting one will select it as the default music for the
current board. If music is already playing, Alt+N will turn it
off.

:CtrN:~ECtrl+N - Test Music

Ctrl+N does the same as Alt+N, except it only plays the
selected module. It does not set the board module to the
selected module. It also remembers the last-used directory to
maintain a current listening directory. If a GDM is tested, 
it will be auto-converted to an S3M (unless MZX is built with
MikMod). A tested module will continue to play even if the
current board is set to play music, and even if the current
world file is changed.

:AltO:~EAlt+O - Edit Overlay

Alt+O enters overlay editing mode. The overlay is on normal  
overlay mode by default. The overlay editing mode is similar to
the normal editing mode, except that only certain keys are
active, and the Enter and Alt+S keys have new purposes. The
overlay is explained in further detail in another section.

>#TOVERLAY.HLP:081:Editing and Using the Overlay

:_P:~EP - Parameter

P allows you to change the settings of the current object in
the buffer. The object under the cursor is not affected.

:084:~EAlt+P - Size/Pos

Alt+P allows you to change the size of the current board, the
viewport size, and location. See another section for details.

>#GENERALE.HLP:sizepos:Board Sizes

:AltR:~EAlt+R - Restart

Alt+R will clear the entire world. You will be asked for
confirmation.

:076:~ES - Save

S will prompt you for a filename, then save the current world
as a MZX file. The save option will be highlighted if the
world has changed since the last save or load.

:082:~EAlt+S - Status Info

Alt+S will allow you to type in six different counters that
can be shown on the default status screen within the game. This
allows you to easily display your own items that the player can
collect, and see how many are currently held. Counters are
discussed in further detail with Robots.

:AltS2:~EAlt+S - Show Level

Alt+S while editing the overlay will toggle whether the level
beneath the overlay is shown in overlay editing mode (defaults
to YES).

>#TOVERLAY.HLP:081:Editing and Using the Overlay

:AltT:~EAlt+T - Test

Alt+T will allow you to test the current world, starting on the
current board. Games CAN be loaded and saved in this mode,
making it especially helpful for debugging. Quitting will
return to the editor.

:_V:~EV - View

V will allow you to see the current board as it would appear in
the game. Use the arrows to Scroll the view, and ESC to return
to the editor.

:083:~EX - Exits

X will bring up a menu where you can select exits for each
board direction. For example, selecting a destination board of
"City" for north will cause the player to go to that board when
pressing against the north edge of the current board. Boards
are not automatically back-linked - to make "City" lead back
here, you must go to that board and make a south exit back.
Make sure the linked boards don't obstruct each other's exits,
and that their linking boundaries are of the same size.

:077:~EAlt+X - Export

Alt+X will allow you to export a number of different file types.
You can export a board file (MZB) unique to MegaZeux, good for
giving single boards to others. (The character set, palette,
and global info aren't included!) You can export the character
set (CHR) for later game use or to edit in Fontutil or another
third party app. Finally, you can export palettes (PAL) [full,
partial, and SMZX] and sound effect settings (SFX) for
transportation. Both are file formats unique to MegaZeux.

Files like MZMs and SAVs can be exported with Robotic code. See
their respective areas for details. Other file types such as
character sets can be exported generically through file writing
facilities and charset counters.

:AltY:~EAlt+Y - Debug Window

Alt+Y will toggle a red box in the lower corner of the screen.
This box shows (on labeled lines) the current position of the
cursor, the current Robot memory situation, and the presently
playing module. This is the same as F6 in-game.

:AltZ:~EAlt+Z - Clear (board)

Alt+Z will clear the current board entirely. You will be asked
for confirmation.

:CtrNu:~ECtrl+Number - Save Editor Position
:AltNu:~EAlt+Number  - Load Editor Position

These save and load up to 10 cursor positions in the editor
(0 thru 9). These positions save boards, so one can save
position on one board and load position from another board.
These positions are not saved with the MZX file.

:Sft8:~EShift+8 OR Numpad * - Mod Wildcard

This sets the board's current mod to play whatever played in
the last-visited board (i.e. the mod playing on that board
differs if entering that board from a board using different
music; it does not stick with the first such mod and play that
from then on).

:SftAr:~EShift+Arrow - Goto Linked Board

This goes to the board linked in the given direction, if it
exists. For example, pressing shift+up would go to the board
linked to the North exit, provided there is a board linked to
that exit.

:min:~E- - Goto Previous Board

This moves the editor to the previous board in the board list,
if it exists.

:plu:~E+ - Goto Next Board

This moves the editor to the next board in the board list, if
it exists.

:F1:~EF1 - Help

F1 will bring up help on the current action. You can press F1
at almost any time.

:F2:~EF2 - Text

F2 will toggle text mode on and off. When text mode is on,
Enter will go to the next line, and Backspace will delete going
backwards. All printable characters will type in as text,
including pressing the Spacebar.

:F3:~EF3  - Terrain
:F4:~EF4  - Item
:F5:~EF5  - Creature
:F6:~EF6  - Puzzle
:F7:~EF7  - Transport
:F8:~EF8  - Element
:F9:~EF9  - Misc. (thing)
:F10:~EF10 - Objects

The above eight keys will bring up a menu of things to select
from. Selecting one will ask you to enter settings (if
appropriate) or choose a character for that thing. Then a copy
of that thing will be placed at the cursor's location, and will
also become the current object in the buffer. Scrolls, Signs,
Sensors, Robots, and Pushable Robots (all in the Objects menu)
will be discussed in another section. The current thing, color,
and settings parameter (p##) is shown in the upper left corner
of the menu. Knowing the settings parameter isn't important
except for certain Robotic programming situations.

>#SCROLLSS.HLP:1st:Signs and Scrolls in the Editor
>#SENSORSW.HLP:094:Sensors - What They Are and How to Use Them
>#ROBOTSWH.HLP:1st:Robots - What They Are and How to Use Them
>#ROBOTICT.HLP:1st:Robotic Tutorial
>#ROBOTICR.HLP:087:Robotic Reference Manual

:F11:~EF11 - Toggle Super MZX Mode

Pressing F11 will change the currently set SMZX mode, in this
order: From OFF to Mode 1; From Mode 1 to Mode 2; From Mode 2
to Mode 3; From Mode 3 to OFF. This setting only holds for the
editor; it will not carry into games by itself.

:F12:~EF12 - Take Screenshot

Pressing F12 will make a 640x350 screenshot (in PNG format by
default) in the working directory, using the software renderer.
The file naming starts from "screen0".

:ShF1:~ESh+F1 - Show InvisWalls
:ShF2:~ESh+F2 - Show Robots
:ShF3:~ESh+F3 - Show Fakes
:ShF4:~ESh+F4 - Show Spaces

These four keys will cause the given things onscreen to flash
(as the exclamation point character, char #33). They are good
for locating "hidden" or camouflaged Robots, passages, and the
like.

:Ar:~EArrow - Move

The arrow keys will move the cursor. The edit window will
scroll when necessary.

:AltAr:~EAlt+Arrow - Move 10

Alt plus the arrow keys will move the cursor ten spaces at a
time, or up to the board's edge if under ten spaces away. These
also jump numbers by 10 in dialog boxes.

:BkSp:~EBackspace - Delete
:Del:~EDel - Delete

These two keys will delete everything under the cursor. The
current thing is not affected.

:End:~EEnd - L/R Corner

End will jump the cursor to the lower-right corner of the
entire board.

:En:~EEnter - Modify+Grab [Board Mode]

Enter will modify the settings of the thing under the cursor,
if applicable, then select that thing as the current thing. It
is just like pressing Alt+M and then Ins.

:Enter2:~EEnter - Character [Overlay Mode]

Enter during Overlay editing mode will change the current
character. Select it from a menu and then press Enter to
confirm your choice.

:ESC:~EESC - Exit/Cancel Mode

ESC will exit the editor, asking for confirmation if your world
has not been saved. If you are in block, overlay, text, or
draw mode, ESC will instead cancel the current mode and return
to normal editing.

:Home:~EHome - U/L Corner

Home will jump the cursor to the upper-left corner of the
entire board.

:Ins:~EIns - Grab

Ins will select the thing under the cursor as the current
thing. The actual thing is not affected.

:Sp:~ESpacebar - Place

Spacebar will copy the current thing to the location under the
cursor. Trying to place something over a similar thing will
instead replace the object under the cursor by default. (Robots
and Pushable Robots are the exception; they will never be
replaced.) Placing something over a floor type will actually
place it OVER the floor, not replace the floor. Other things
will be deleted if they are in the way.
Spacebar can also replace similar objects under the cursor with
a space; this can be set in the configuration file.

>#CONFGINI.HLP:1st:The Config File

:Tab:~ETab - Draw

Tab will toggle the current draw mode. When drawing is on, you
will place a copy of the current object in the buffer every
time you move the cursor.

:PgDn:~EPageDown - Next Menu
:PgUp:~EPageUp - Previous Menu

These two keys will cycle through the different menus. The
menu bar can wrap around. You do not have to be viewing the
menu with an option before you can use that option - the menus
are purely for reference. These also jump numbers by 100 in
dialog boxes.

>#THEWORLD.HLP:1st:The World Editor
>#GENERALE.HLP:1st:General Editing Tips
>#MAIN.HLP:072:Table of Contents
#CHAREDIT.HLP
:079: 
$~9The Character Editor

The character editor is an important part of MegaZeux. With
it, you can change the appearance of the character set. For
example, one can make bricks, rockets, stones, and demons;
using multiple characters, one can make much grander things.
The default pixel resolution is fair - 8x14 per character for a
total of 640x350 for the entire screen. Other modes (known as
Super MZX modes) increase colors at a cost of halving
horizontal resolution, but the difficulties of character
editing in those modes are best covered elsewhere.

To use the character editor, press Alt+C in the editor. You
will be shown a zoomed version of the current character, a menu
of options, a list of numbers, and a row of characters. The
numbers are only important for certain Robotic programming
situations.

To edit the character, move the cursor with the keys and use
Spacebar to toggle pixels on and off (or left-click and
right-click, respectively). Use + and - to move one character
(or character block) up or down through the character set. Use
Enter to select the current character (or block) from the
entire set. The current character(s) are highlighted on the row
in the upper right corner.

Use Del to clear the character. Use N to make a "negative", or
inverse, of the character, turning all on pixels off and all
off pixels on. Use Alt with the arrow keys to shift the entire
character to one direction. Pixels shifted off of one edge
wraparound to the other edge.

Use M to mirror the character, flipping it left to right. Use
F to flip the character top to bottom. F2 will copy the current
character to an internal buffer, while F3 will paste the buffer
contents to the current character. The buffer is retained
between uses of the character editor.

Hold Shift to select multiple pixels at a time. The selection
box will vanish once Shift is released. Alt+B will also create
a similar selection box, but will not vanish until the Escape
key is pressed.

Alt+U will undo actions done in the editor (up to the limit
defined in the config file). Keep in mind that the current
frame is counted in the amount of undo actions.

Alt+R will redo any undone actions.

Alt+F will flood fill any highlighted area.

Tab will toggle mode (set) on and off. (set) mode will turn all
pixels crossed to ON.

Shift+Tab will turn toggle (clear) mode. (clear) mode will turn
all pixels crossed OFF.

Multiple characters can be edited at one time. To select a
group of characters, press and hold Enter in the character
editor while highlighting the desired group of characters. If
more than one viable block can be made from the selected
characters, the user can choose the desired block (e.g. six
characters can be 3x2, 2x3 or 6x1). The largest block one can
edit is 6x3.

Alt+I will import character sets while in the character editor;
Alt+X will export. This can be done with one full set or series
of partials. For a full set, simply select the desired set and
click OK. For saving a series of partials, insert a hash sign
in the set name then choose the Offset (starting character).
Then choose the First number of the series (e.g. char#.chr with
a First value of 5 would start from char5.chr). Then choose the
Count value to indicate how many sets will be saved. Loading is
simpler; simply choose the starting character set, the Offset
value and the Count value. Importing and exporting partials
will, however, only work with a block one character in height.

The character editor is a key element in creating decent games
with MegaZeux. If you can't seem to draw well with it, that's
okay, since it has some limitations. You can keep practicing
at it, or you can get an MZXer friend to draw characters for
you.

The character editor changes somewhat in Super MZX modes - go
to the Super MZX Modes section for more information on this.

>#SMZXMODE.HLP:095:Super MZX Modes
>#EDITINGK.HLP:080:Editing Keys and Options Reference
>#MAIN.HLP:072:Table of Contents
#PALEEDIT.HLP
:093: 
$~9The Palette Editor

The built-in palette editor can certainly spruce up a game. It
allows you to change the appearance of the 16 different
available colors. It is the only way to get a decent orange
color, for example.

To use it, press Alt+E in the editor. The palette editing screen
will appear. The current palette will be shown along the top,
with the current color marked. The RGB values of the current
color are shown along the right side of the screen, and the menu
is shown on the lower half.

Some color theory is in order here. Computer monitors display
colors by projecting various amounts of Red, Green, and Blue
light. Combined, these three colors can produce almost any shade
and hue of color. This is how colors are represented in MegaZeux
as well. Each color has a Red, Green, and Blue value, each
ranging from 0 to 63. 0 is off, 63 is full brightness, and the
other values range in shade.

To make colors other than red, green, and blue, you must mix
them. Purple is red plus blue, cyan is green plus blue, and
yellow is red plus green. (Really.) Whites and grays are made
from equal amounts of all three. For example, red 42 blue 42
green 0 would be a deep purple, and all as 20 would be a dark
gray. To brighten a color, raise all the numbers, or lower them
to darken it. Orange is made with full red and 31 green.

Anyway, back to the editor. Use the arrow keys to select the
current color. R, G, B, and A will increase Red, Green, Blue,
and All, respectively. Alt+RGBA will decrease the same values.
Alt+D will reset the palette to its default colors (you will
NOT be asked for confirmation). 0 will blacken the current
color. Finally, F2 will store the current color to an internal
buffer, while F3 will paste the buffer color to the current
color.

The default MZX palette editor will be unhelpful for Super MZX
modes; see the Super MZX section for details on working with
SMZX modes.

>#EDITINGK.HLP:080:Editing Keys and Options Reference
>#SMZXMODE.HLP:095:Super MZX Modes
>#MAIN.HLP:072:Table of Contents
#GLOBALIN.HLP
:086: 
$~9Global Info Options

To edit the Global Info options, press G within the editor.
This will bring up various dialogs where you can edit options
that affect the entire world. The first dialog you see has the
following options:

$First Board

Here is where you select which board will be the starting board
for the game. The player will start on this board. This
defaults to the title screen.

$Edging Color

This is the color of the border around the entire screen, where
the viewport does not extend. It defaults to dark gray.

$Starting/Maximum Lives

This is where you set the number of lives the player starts
with, and how many lives the player can accumulate at any one
time.

$Starting/Maximum Health

Same as above, but for health points.

$Enemies' Bullets Hurt Other Enemies

If this is on, then bullets shot by enemies, such as tigers,
will destroy other enemies that they hit. It basically turns
all Enemy bullets into Neutral bullets.

$Clear Messages and Projectiles on Exit

If this is on, the current message and all projectiles (stars,
bullets, missiles, shooting fire) are cleared whenever the
player leaves the screen.

$Can Only Play World from a 'SWAP WORLD'

If this is on, then the current world is unplayable in a normal
fashion. The only way to play it is to swap to it from another
world, using the Robotic command SWAP WORLD.

$More

This button leads to another screen of settings.

$Edit Chars

:089:This button leads to a series of dialogs where you can edit the
characters and colors used to represent various internal things.

$Edit Dmg

:090:This button leads to a dialog where you can edit the amount of
damage done by various internal things.

$Edit Global Robot

This button allows you to edit the global Robot, which is a
very special Robot that is present at all times, although it is
not physically on every board. It is a very important part of
MegaZeux. See the section on The Global for more information.

>#THEGLOBL.HLP:gbl:The Global
>#ROBOTICR.HLP:087:Robotic Reference Manual

:088:The second dialog of settings for global info has the
following options:

$Death Board/Death X/Death Y/Mode

This tells MegaZeux what happens when the player dies. If the
mode is Same Position, then the player will simply lose a life.
If it is Restart Board, then the player will also teleport to
the location on the board where the player entered. If it is
Teleport, the player will instead teleport to the board and
{x,y} coordinates stated in the above three settings.

$Endgame Board/Endgame X/Endgame Y/Mode

This tells MegaZeux what happens when the player runs out of
lives. If mode is Game Over, then the game will simply end. If
it is Teleport, the player will be given one last life and then
will be teleported to the board and {x,y} coordinates stated in
the above three settings. The next time the player dies, the
game will end.

$Play Game Over SFX

If this option is on, the game over sound effect will be looped
when the game has ended and the Game Over message will flash
along the bottom of the screen.

$Previous

This will go to the previous global settings dialog.

The character editing dialogs (eight in total) are screens of
characters and colors used to represent internal things. Select
one to change the color or character used. Use Next and
Previous to move between the screens, and Done when you are
finished. Lit Bomb Anim 1 is special; setting it will set the
other 6 frames of Lit Bomb Animation to the succeeding
characters.

The damage editing dialog allows you to change the amount of
damage dealt by various things within the game. Select one and
use the usual dialog keys to change the values, which can range
from 0 to 255. 0 will leave the player invincible versus that
thing.

Editing the global Robot is covered in the Robot tutorials, as
it is (mostly) the same as editing any other Robot. The actual
use of a global Robot is covered in its own section.

>#THEGLOBL.HLP:gbl:The Global
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#EDITINGK.HLP:080:Editing Keys and Options Reference
>#MAIN.HLP:072:Table of Contents
#BOARDINF.HLP
:085:
$~9Board Info Options

To edit Board options, press I within the editor. This will
bring up a dialog where you can edit options pertaining to the
current board. The options are as follows:

$Board Name

This is the name of the board. It is mainly for internal
reference; however, the name of the first board (the title
screen) is also used to represent the entire world on a file
listing, and its value can be accessed through the BOARD_NAME
string in Robotic.

$Can Shoot/Bomb

These options determine whether or not the player can shoot or
bomb normally. If off, then the player cannot perform the
noted action. (Other ways of doing this in Robotic may replace
the default ways of shooting/bombing and are unimpeded by this
setting.)

$Fire Burns Space/Fakes/Trees/Brown

These options determine what fire will and will not burn
through. Space is empty space, NOT floors; Fakes include fakes,
floors, carpets, and tiles. Trees are self-explanatory. Brown
is anything other than the player or a Robot/sign/Scroll that
is colored brown (that is, anything with a color of cX6).

$Forest to Floor

If on, when the player moves through forest, it will become
floor. If off, the forest will simply be replaced by a space.

$Collect Bombs

If on, the player will collect bombs normally. If off, bombs
will be instantly lit when touched.

$Fire Burns Forever

If on, fire will never burn out. If off, fire will eventually
turn into ash, which is actually a dark gray (c08) floor. Of
course, if fire is set to burn fakes, the ash will probably
re-light immediately.

$Restart if Hurt

When on, the player will be teleported to the place on the
current board that it originally entered every time it loses
health.

$Player Locked N/S

When on, the player cannot move north or south until unlocked
with the UNLOCKPLAYER command. (Other ways of doing this, in
Robotic, are unimpeded by this setting.)

$Player Locked E/W

When on, the player cannot move east or west until unlocked
with the UNLOCKPLAYER command. (Other ways of doing this, in
Robotic, are unimpeded by this setting.)

$Player Attack Locked

When on, the player cannot shoot bullets or bomb until unlocked
with the UNLOCKPLAYER command. (Other ways of doing this, in
Robotic, are unimpeded by this setting.)

$Time Limit

If greater than zero, the player has the noted amount of time
to complete the board. The current time is shown in the lower
left corner during gameplay. If time runs out, the player loses
ten health and the time limit is reset. This option is most
useful with the "Restart if Hurt" option. The time is in units
considerably faster than seconds; test the board to get a feel
for the amount of time needed. The current time is reset if the
player exits and re-enters the board.

$Explosions to Space/Ash/Fire

This determines what explosions will leave in their wake: Empty
space, ash (dark gray floors - in other words, floors colored
c08), or burning fire.

$Can Save/Can't Save/Can Save on Sensors

This determines when the player can save his game. The first
two options are self-explanatory. Can save on Sensors allows
the player to only save if it is standing directly over a
Sensor. Sensors are explained in another section.

>#SENSORSW.HLP:094:Sensors - What They Are and How to Use Them

$No/Normal/Static/Transparent Overlay

This sets the type of overlay for the current board. No Overlay
means just that - overlay mode is completely off. Normal
Overlay is a normal overlay that scrolls with the board. Static
Overlay is a normal overlay that remains in a fixed position
even when the board scrolls. A Transparent Overlay is similar
to no overlay in that none is shown, but it allows you to edit
it so that one may appear later. Overlays are discussed in full
in another section.

One can set the current board's settings as the default
settings for all new boards made for this world file. Select
the "Set as defaults" button at the bottom and click or press
Space/Enter. This will save a .cnf file for the current world.
There will be no confirmation. The current world must have been
saved in order to do this.

>#TOVERLAY.HLP:081:Editing and Using the Overlay
>#EDITINGK.HLP:080:Editing Keys and Options Reference
>#MAIN.HLP:072:Table of Contents
#SOUNDEFX.HLP
:1st: 
$~9MegaZeux's Sound System

MegaZeux has two types of sound: Digitized sound, played
through a sound card, and sound effects, which are emulated PCS
effects.

MegaZeux's many sound options can be accessed through the
config.txt file. Please see this section for details.

>#CONFGINI.HLP:1st:The Config File

$Music Files

Music files, referred to as MODULES, can be any one of the
following formats:

* MOD (or NST/WOW/OCT)
* GDM
* S3M
* XM
* IT
* WAV
* OGG
* Other formats {STM, MTM, 669, ULT, FAR, MED (MMD0), DSM, OKT,
  AMF}
* MT2, AMS, MDL, DMF, PTM, DBM, PSM, J2B, UMX, MID, ABC and PAT
  are in ModPlug, but not supported in MZX.

MZX does not support GDMs natively. Instead, when a GDM is
loaded, it is converted to an S3M file. The S3M file is loaded
in all future incidences. To discourage loading of GDMs, it is
impossible to select a GDM file from the board's music
selection menu (ALT+N). Thus, if you want to use a GDM in your
game, you should instead use one of the following:
 * The original audio file prior to conversion, if you have it.
 * The GDM converted to S3M - this can be done by using ajs's
   convertor or by using a Robot in MZX to load the GDM, which
   will automatically make the S3M appear. You can then select
   it normally.

NOTE: The above text only applies to ModPlug (the default
module engine). It is now possible to build using MikMod, to
support platforms that cannot handle ModPlug. It can play these
formats: {669, AMF, APUN, DSM, FAR, GDM, IT, IMF, MOD, MED,
MTM, OKT, S3M, STM, STX, ULT, UNI, XM}, while MZX will natively
play the WAV and OGG formats. GDMs load natively in MikMod, in
contrast to ModPlug.

Formats common to both engines are MOD, S3M, XM, IT, STM, MTM,
669, ULT, FAR, MED, DSM, OKT and AMF. All other formats 
(excluding WAV/OGG/SAM/GDM) are locked out of MZX by default.

MZX supports loop markers for WAVE and OGG files. WAVE formats
with the "smpl" marker will be recognized, and forward loop
only; OGG loops are supported with the LOOPSTART and LOOPLENGTH
tags.

$Using Sound and Music in Your Own Games

There are three ways to utilize sound and music in your own
games:

 1- Select the default modules for each board (or mod *).
 2- Edit the built-in speaker sfx tables.
 3- Use Robots to play modules, SAMs/WAVs/OGGs, and speaker
   sfx.

$Selecting Default Modules for Each Board

This is perhaps the easiest method to get music in your games.
Simply make sure that the proper module files are in the
current directory, or in a subdirectory of the current
directory, and use Alt+N to select music for a board. Press
Alt+N to turn it back off again. To set it to play the same
music as the last board (mod *), press Shift+8.

>#EDITINGK.HLP:AltN:Details on Alt+N

$Editing the Built-in Speaker SFX

To edit the built-in speaker sound effect tables, use Alt+F.
The format for them is discussed later in this section.

>#EDITINGK.HLP:097:Details on Alt+F

$Using Robots

Robotic has a large number of commands for playing modules,
SAMs/WAVs/OGGs, and speaker sfx. A knowledge of Robotic basics
is required, so see the following sections to learn about
Robots.

>#ROBOTSWH.HLP:1st:Robots - What They Are and How to Use Them
>#ROBOTICT.HLP:1st:Robotic Tutorial
>#ROBOTICR.HLP:087:Robotic Reference Manual

The following sections discuss individual commands relating to
sound and music.

>#COMMAND2.HLP:_c6:~ACHANGE SFX # "string"
>#COMMANDR.HLP:_e2:~AEND MOD
>#COMMANDR.HLP:_e4:~AEND SAM
>#COMMANDR.HLP:_e3:~AEND PLAY
>#COMMAND2.HLP:_j1:~AJUMP MOD ORDER #
>#COMMANDR.HLP:_m3:~AMOD "file"
>#COMMAND2.HLP:_m5:~AMOD FADE IN "file"
>#COMMAND2.HLP:_m6:~AMOD FADE OUT
>#COMMAND2.HLP:_m4:~AMOD FADE # #
>#COMMAND2.HLP:_m7:~AMOD SAM # #
>#COMMANDR.HLP:_p2:~APLAY "string"
>#COMMANDR.HLP:_p3:~APLAY SFX "string"
>#COMMANDR.HLP:_s1:~ASAM # "file"
>#COMMANDR.HLP:_sO:~ASFX #
>#COMMAND2.HLP:_v3:~AVOLUME #
>#COMMAND2.HLP:_w2:~AWAIT MOD FADE
>#COMMAND2.HLP:_w3:~AWAIT PLAY
>#COMMANDR.HLP:_w4:~AWAIT PLAY "string"

$SAM Files in the Port

Much like GDMs, SAM files are not directly supported in MZX.
WAV files are created on first loading the SAM, and are
exclusively used thereafter. An easy way to convert SAM files
is by using Alt+L and playing each. However, using WAVs as the
original source is preferred, as conversion can degrade quality
(not to mention that SAMs, as ~~8KHz mono files, aren't
high-quality to begin with). For large sound effects such as
voice, try using OGGs; while lossy, the OGG format can provide
very good compression and still sound the same (or extremely
similar) to the human ear. You may also use module formats with
the SAM command, which has its uses.

$Format for Sound Effects

The sound effects editor and Robotic PLAY commands all use the
same format for playing sound effects. The format consists of
a single string of characters, each character representing one
note or command. Spaces are ignored, and capitalization is not
important. Some knowledge of music is required to use the
format effectively. The commands are:

~A A B C D E F G
  Plays the note stated, at the current octave and duration.
  The scale starts at C and continues DEFGAB before going up
  an octave. Use # and $ for sharps and flats, placing them
  after the note.
~A # $
  Sharps (#) or flats ($) the previous note. This does not
  affect any note other than the note directly before the sharp
  or flat. Constructs such as B# are allowed.
~A 0 1 2 3 4 5 6
  Sets the current octave. Octave 3 starts at middle C. The
  lower the number, the lower the notes.
~A + -
  Raises or lowers the current octave by 1, but only if
  possible. You cannot go below octave 0 or above octave 6.
~A X
  Plays a rest of the current duration. A rest is a period of
  silence.
~A Z T S I Q H W
  These letters change the current duration of notes and rests,
  I.E. the length of time each subsequent note is played. Each
  one is twice as long as the previous one, with Z being the
  fastest and W the slowest. Duration defaults to Z. The
  counterparts to the durations follow:
   Z = sixty-fourth note
   T = ~AT~Fhirty-second note
   S = ~AS~Fixteenth note
   I = e~AI~Fghth note
   Q = ~AQ~Fuarter note
   H = ~AH~Falf note
   W = ~AW~Fhole note
  Duration (and octave) does not carry over from one string to
  the next.
~A .
  A dot will change the current duration to 150% that of usual.
  This is a permanent duration change and will only affect
  subsequent notes. Its use is similar to that of a dot in
  regular music, except that this dot affects multiple notes.
~A !
  An exclamation point will change the current duration to 33%
  that of usual. This is a permanent duration change and will
  only affect subsequent notes. Its use is similar to that of
  triplets in regular music, except it affects ALL subsequent
  notes.
~A &
  & is a very special command. It is used to play SAM files
  (digitized sounds) within an sfx string. It allows digitized
  sounds within the sound effects editor. The general format
  for & is as follows:

$"&FILENAME.WAV&3C"

  This will play middle C using FILENAME.WAV. Duration is
  irrelevant. If nothing follows the last &, the effect will
  play at natural frequency. Multiple filenames can be used in
  the same PLAY command, but only the last one can have nothing
  following its last &.
~A _
  An underscore is usually used in conjunction with &. It
  turns off digitized sounds for the rest of the string, and
  ignores the rest of the string ONLY IF digitized music/sound
  is on. For example:

$"&SHOT.WAV&6F#_+C-C"

  The above will play SHOT.WAV at 48KHz (F-sharp, 6th octave)
  if digitized sound is on, OTHERWISE it will play the normal
  shooting sound of "+C-C".

$Sound Effect Numbers

The PLAY SFX command in Robotic plays one of the built-in sound
effects. The numerical values corresponding to these sound
effects are listed below.

0  - Gem
1  - Magic Gem
2  - Health
3  - Ammo
4  - Coin
5  - Life
6  - Lo Bomb
7  - Hi Bomb
8  - Key
9  - Full Keys
10 - Unlock
11 - Can't Unlock
12 - Invis. Wall
13 - Forest
14 - Gate Locked
15 - Open Gate
16 - Invinco Start
17 - Invinco Beat
18 - Invinco End
19 - Door Locked
20 - Open Door
21 - Hurt
22 - AUGH!
23 - Death
24 - Game Over
25 - Gate Closing
26 - Push
27 - Transport
28 - Shoot
29 - Break
30 - Out of Ammo
31 - Ricochet
32 - Out of Bombs
33 - Place Bomb (Lo)
34 - Place Bomb (Hi)
35 - Switch Bomb Type
36 - Explosion
37 - Entrance
38 - Pouch
39 - Ring/Potion
40 - Empty Chest
41 - Chest
42 - Out of Time
43 - Fire Ouch
44 - Stolen Gem
45 - Enemy HP Down
46 - Dragon Fire
47 - Scroll/Sign
48 - Goop
49 - Unused

:frq:
$SAM, OGG, MOD and WAV Frequencies

Sounds played using the SAM command in Robotic play at its
"natural" frequency at value 0; if one wants to play the sound
at a different pitch, a frequency value is needed. Frequencies
corresponding to MOD file notes follow:

 Ú--------Â---Â---Â---Â---Â---Â---Â---Â---Â---Â---Â---Â---¿
 |        | C | C#| D | D#| E | F | F#| G | G#| A | A#| B |
 Ã--------Å---Å---Å---Å---Å---Å---Å---Å---Å---Å---Å---Å---´
 |Octave 1|856|808|762|720|678|640|604|570|538|508|480|453|
 Ã--------Å---Å---Å---Å---Å---Å---Å---Å---Ã---Å---Å---Å---´
 |Octave 2|428|404|381|360|339|320|302|285|269|254|240|226|
 Ã--------Å---Å---Å---Å---Å---Å---Å---Å---Ã---Å---Å---Å---´
 |Octave 3|214|202|190|180|170|160|151|143|135|127|120|113|
 Ã--------Å---Å---Å---Å---Å---Å---Å---Å---Ã---Å---Å---Å---´
 |Octave 4|107|101| 95| 90| 85| 80| 75| 71| 67| 63| 60| 56|
 Ã--------Å---Å---Å---Å---Å---Å---Å---Å---Ã---Å---Å---Å---´
 |Octave 5| 53| 50| 47| 45| 42| 40| 37| 35| 33| 31| 30| 28|
 À--------Á---Á---Á---Á---Á---Á---Á---Á---Á---Á---Á---Á---Ù

The following table lists frequencies corresponding to PLAY
statement notes:

 Ú-Â----Â----Â----Â----Â----Â----Â----Â----Å----Â----Â----Â----¿
 |O|C   |C#  |D   |D#  |E   |F   |F#  |G   |G#  |A   |A#  |B   |
 Ã-Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----´
 |0|3424|3232|3948|2880|2712|2560|2416|2280|2152|2032|1920|1812|
 Ã-Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----´
 |1|1712|1616|1524|1440|1356|1280|1208|1140|1076|1016| 960| 906|
 Ã-Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----´
 |2| 856| 808| 762| 720| 678| 640| 604| 570| 538| 508| 480| 453|
 Ã-Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----´
 |3| 428| 404| 381| 360| 339| 320| 302| 285| 269| 254| 240| 226|
 Ã-Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----´
 |4| 214| 202| 190| 180| 170| 160| 151| 143| 135| 127| 120| 113|
 Ã-Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----´
 |5| 107| 101|  95|  90|  85|  80|  75|  71|  67|  63|  60|  56|
 Ã-Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----Å----´
 |6|  53|  50|  47|  45|  42|  40|  37|  35|  33|  31|  30|  28|
 À-Á----Á----Á----Á----Á----Á----Á----Á----Á----Á----Á----Á----Ù

The following tables list how to play a Wave or OGG at its
normal sound with PLAY statements:

 48000Hz Wave/OGG --> 37
 44100Hz Wave/OGG --> 41
 32000Hz Wave/OGG --> 56
 24000Hz Wave/OGG --> 75
 22050Hz Wave/OGG --> 81
 16000Hz Wave/OGG --> 112
 12000Hz Wave/OGG --> 149
 11025Hz Wave/OGG --> 162
 08000Hz Wave/OGG --> 224

To convert frequencies from MZX to real, use these formulae:

 Actual frequency = 1789682 / MZX frequency
 MZX frequency = 1789682 / actual frequency

WAVs converted from SAMs play at a natural frequency of 8363Hz.

Finally, tracked modules have a normal frequency of 44100 Hz;
other types such as OGG and WAV have normal frequencies at
their recording rate (for example, a WAV encoded at 22050 Hz
will play normally at the 22050 Hz setting). The frequency of a
module can be controlled with the "mod_frequency" counter;
changing the frequency mid-song can create a popping sound,
especially while lowering frequency. The lowest allowed setting
of mod_frequency is 16 Hz.

$Where to Get Module and Sound Files

These questions are answered in the Frequently Asked Questions
section of help.

>#FAQ.HLP:1st:Frequently Asked Questions
>#CONFGINI.HLP:1st:External MegaZeux Options
>#MAIN.HLP:072:Table of Contents
#TOVERLAY.HLP
:081: 
$~9Editing and Using the Overlay

The overlay is a simple but useful part of a board. If one
looks at Floors and Fakes as a floor layer, and Walls as a
central layer, the overlay is a ceiling layer. Basically, the
overlay, when on, appears OVER anything on the board. The
player, enemies, Robots, etc. all move underneath it. The
overlay is purely for show and graphical effects. For example,
you could create archways that the player moves under, or have
a score and lives display that is overlaid over the view at all
times (by using Robotic). However, character 32 (empty space
99.99% of the time) is never part of the overlay. To emulate a
space, use the wall character or make your own space character.
This is very important to remember when putting text onto the
overlay.

The overlay is set on "Normal Overlay" mode by default. The
editor will prevent you from editing the overlay if it is Off,
since it will not be saved if it is. These are the available
overlay modes:

Off - No overlay is saved, none is shown.
Normal - The overlay is shown normally, scrolling along with
  the rest of the board. Default for boards.
Static - The overlay is shown, but it does not scroll with the
  board. It always shows the top left position.
Transparent - The overlay is saved and can hold info, but is
  currently not shown.

If the overlay is on, press Alt+O in the editor to edit it.
This brings you to the overlay editor. The menu at the bottom
of the screen will change, and you will have access to the
following keys and options:

:074:~EAlt+B - Block

Press Alt+B to start block mode. Then move the cursor to the
opposite corner of a rectangular block, and press Alt+B again.
You can then select an action to perform upon the block. Copy
will allow you to duplicate the block by moving the cursor to
a destination and pressing Enter. The cursor marks the new
UPPER LEFT corner. Copy (repeated) is the same as Copy but can
allow copying of the same block to multiple places. Move will
allow you to move the block to a new location. Clear will erase
the contents of the block. Flip will flip the block upside
down. Mirror will flip the block left to right. Paint will
change the entire block to the current color. Copy to/from
overlay will copy the block to the main level from the overlay.
You will have to select the type of thing it will be copied as:
Floor, Text, etc. Save as MZM will save the block as a 
layer-type MZM file. Destinations for Move and Copy can
overlap the original block safely. Ctrl+Dir is especially
helpful when doing a repeated copy block; it moves the cursor
the width of the block, ensuring no overlap when pasting.

Like normal Block functions, one can now copy between boards by
selecting the board when the editor prompts the user for the
block's destination.  Use the B key to select the destination
board.

:_C:~EC - Color

Press C to select a new current color from a menu. The character
under the cursor is not affected.

:_F:~EF - Fill

Press F to fill in an enclosed area with the current character
and color. The area must be completely surrounded by characters
other than the character beneath the cursor. For example, you
can fill over a solid square of As with something else. The
current fill command may not work right for very large and
complex areas- In this case, you must move to the unfilled areas
and press F to continue filling. However, this happens very
rarely.

:AltO:~EAlt+O - Edit Overlay

Alt+O will exit overlay mode and return to editing the main
board.

:AltS2:~EAlt+S - Show Level

Alt+S will toggle whether the level beneath the overlay is
shown. Without the level, only the overlay is shown, and no
board bits are seen through the holes in the overlay. However,
it is a good idea to show the level to see how it looks beneath
the overlay.

:F1:~EF1 - Help

F1 will bring up help on the current action. You can press F1
at almost any time.

:F2:~EF2 - Text

F2 will toggle text mode on and off. When text mode is on, Enter
will go to the next line, and Backspace will delete going
backwards. All printable characters will type in as text.

:Ar:~EArrow - Move

The arrow keys will move the cursor. The edit window will Scroll
when necessary.

:AltAr:~EAlt+Arrow - Move 10

Alt with the arrow keys will move the cursor up to ten spaces at
a time.

:BkSp:~EBackspace - Delete
:Del:~EDel - Delete

These two keys will delete everything under the cursor. The
current character is not affected.

:End:~EEnd - L/R Corner

End will jump the cursor to the lower left corner of the entire
overlay.

:Enter2:~EEnter - Character

Enter will change the current character. Select it from a menu
and then press Enter to confirm your choice.

:ESC:~EESC - Exit/Cancel Mode

ESC will exit overlay mode. If you are in block, text, or draw
mode, ESC will instead cancel the current mode and return to
normal overlay editing.

:Home:~EHome - U/L Corner

Home will jump the cursor to the upper-left corner of the
entire overlay.

:Ins:~EIns - Grab

Ins will select the character and color under the cursor
as the current. The actual character is not affected.

:Sp:~ESpace - Place

Space will copy the current character and color to the location
under the cursor. Trying to place something over itself will
instead delete it. Other things will be deleted if they are in
the way.

:Tab:~ETab - Draw

Tab will toggle the current draw mode. When drawing is on, you
will place a copy of the current character every time you move
the cursor.

The basic method of editing the overlay is to use C and Enter to
select characters and colors, and use Space, arrows, and Tab to
draw with them. Do not switch overlay mode to Off once you have
drawn your overlay, or it may be permanently erased.

The overlay and overlay mode can also be changed using Robotic;
with Robotic, not only can one powerfully manipulate the
overlay, but change the overlay's type, and also copy directly
to the board or vlayer from the overlay (and vice versa). A
knowledge of Robotic basics is required, so see the following
sections to learn about Robots.

>#ROBOTSWH.HLP:1st:Robots- What They Are and How to Use Them
>#ROBOTICT.HLP:1st:Robotic Tutorial
>#ROBOTICR.HLP:087:Robotic Reference Manual

The following sections discuss individual commands relating to
overlays.

>#COMMAND2.HLP:_c4:CHANGE OVERLAY [color] [char] [color] [char]
>#COMMAND2.HLP:_c5:CHANGE OVERLAY [color] [color]
>#COMMAND2.HLP:_cJ:~ACOPY BLOCK # # # # # #
>#COMMAND2.HLP:_cL:COPY OVERLAY BLOCK # # # # # #
>#COMMAND2.HLP:_cR:COPY OVERLAY BLOCK # # # # "@@filename" #
>#COMMAND2.HLP:_cS:COPY OVERLAY BLOCK "#x" "#y" # # "@@filename" #
>#COMMAND2.HLP:_cU:COPY OVERLAY BLOCK # # # # "$string" #
>#COMMAND2.HLP:_cV:COPY OVERLAY BLOCK "#x" "#y" # # "$string" #
>#COMMAND2.HLP:_cX:COPY OVERLAY BLOCK # # # # "#x" "#y"
>#COMMAND2.HLP:_cZ:COPY OVERLAY BLOCK "#x" "#y" # # # #
>#COMMAND2.HLP:_cAA:COPY OVERLAY BLOCK "#x1" "#y1" # # "#x2" "#y2"
>#COMMAND2.HLP:_o2:OVERLAY ON
>#COMMAND2.HLP:_o3:OVERLAY STATIC
>#COMMAND2.HLP:_o4:OVERLAY TRANSPARENT
>#COMMAND2.HLP:_pE:PUT [color] [char] OVERLAY # #
>#COMMAND2.HLP:_w7:WRITE OVERLAY [color] "string" # #

>#MAIN.HLP:072:Table of Contents
#SCROLLSS.HLP
:1st: 
$~9Signs and Scrolls in the Editor

Signs and Scrolls are a simple way to get messages across in
the game. To place them in the editor, press F10 and select
Sign or Scroll from the list. You must then edit the text of
the Sign or Scroll.

The Scroll editor is very simple. You can move the cursor among
the different lines and characters. Type to insert text
anywhere. Press Ins to toggle between insert mode (default)
and overwrite mode, where typed characters will overwrite any
characters already there. Backspace and delete work as normal,
as do PageDown, PageUp, End, and Home. Finally, use Enter to
start or insert new lines.

Press ESC when you are done editing your Scroll. It will be
placed at the current cursor position and will become the
current object in the buffer. Note that although you can now
copy the Scroll freely, there is a limit of 255 Scrolls and
Signs per board. This limit shouldn't ever be a problem.

>#MAIN.HLP:072:Table of Contents
#DBGMODE.HLP
:dbg:
$~9Debug Mode

The debug mode is a powerful tool. The debug mode not only can
pause all current MZX world action and display all of the
counters and strings the world has set, but also can manipulate
these values and even add new ones.

The left side of the debug mode shows the current selection of
counters/strings. Built-in counters ending with an asterisk (*)
are read-only. Highlighting a counter/string and either
clicking it or pressing Enter/Space while on it will bring up a
box, allowing the value of the counter/string to be changed.
Type in the desired new value, and press Enter to set the
counter/string to the new value. Press Escape to cancel setting
a new value.

(PLEASE NOTE: Strings can only show and set its first 68
characters when attempting to set a new value. If a string
originally contained over 68 characters, none of the characters
past the 68th will show in the value setting box, even when any
of the first 68 characters are deleted. Simply choosing to set
a value, while not doing anything else, will truncate the
string down to its first 68 characters.)

These counters and strings are organized into various lists,
shown in the upper-right. Selecting one of these lists will
display its contents in the left-side box. If a list has a plus
sign next to it, it is a tree, and clicking on it or pressing
Space or Enter will expand it to show any of that tree's
sub-lists (if they exist). Click again to hide the sub-lists.

The lists are as follows:

~ACounters~F: Lists all user-defined counters, as well as status
counters (things like AMMO, HEALTH, etc) and menu counters,
followed by their values. Expanding this tree will allow
selection of lists sorted by starting character - individual A
through Z lists contain only counters starting with their
respective characters, and # does the same for everything else.
Only the first 45 characters of a counter name will be shown.

~AStrings~F: Lists all user-defined strings, followed by their
values. Expanding this tree will allow selection of lists
sorted by starting character - individual A through Z lists for
the respective characters, and # for everything else. Only the
first 16 characters of a string name (including the $) and the
first 40 characters of a string value will be shown.

~ASprites~F: Lists the global sprite counters and their values.
Expanding this list will allow selection of lists sorted by
relevant sprite - "spr1","spr2", and so on. Each spr# list
shows all of each sprite's relevant counters.

~AWorld~F: Lists built-in world counters/strings and their values.

~ABoard~F: Lists built-in board counters/strings and their values.

~ARobots~F: Directly highlighted, this option lists nothing.
However, expanding this tree will allow selection of lists
sorted by the robot_id of the current board's Robots - starting
with "0: <name>" for the Global, and continuing on for each
Robot on the board. Each list displays that Robot's local
counters and their values (as well as their robot_name
strings).

Outside of directly displaying and setting values of counters
and strings, the debug mode has several other tools at its
disposal. They are given buttons in the lower-right corner, and
are as follows:

~ASearch~F: Locates names and values in any of the counters/strings
listed in the debug mode. Type the desired search string and
select from the given options, then press Enter. The search
begins from the last highlighted line. This menu can be
directly accessed with Ctrl+F, and an instant repeat of the
last search can be done with Ctrl+R. Options:
-Search names: Searches counter and string names.
-Search values: Searches counter and string values.
-Case sensitive: Returns results only if case matches.
-Reverse: Searches from bottom to top (as opposed to the
default top to bottom).
-Wrap search: If no results are found, starts from the opposite
end and searches until a result is found or the original search
location is reached.
-Current list only: Only searches the current list. Child lists
of the current list will not be searched.

~ANew~F: Creates a new counter or string with the given name. Its
value will be 0 for a new counter, and blank for a new string.
If any counter or string already exists with the given name,
this will be ignored and the original counter/string will keep
its original value; you will not be notified of any such
conflicts. This menu can be directly accessed with Alt+N.

~AToggle Empties~F: Sets whether counters with values of 0 and
blank strings are shown in the display lists. Defaults to Show
(i.e. counters and strings with these values will be shown).
Searching forces this setting to Show. This menu can be
directly accessed with Alt+H.

~AExport~F: Exports a text file list of SET commands that would set
the current user-defined counters and strings, and the built-in
counters in the Counters parent list, to their current values.
If overwriting a current file is chosen, MZX will ask for
confirmation.

>#MAIN.HLP:072:Table of Contents
#ERRORMES.HLP
:1st: 
$~9Error Messages

The following is a list of error messages in alphabetical
order, which links to descriptions of the error and possible
remedies. MegaZeux silently ignores many other possible errors.

MegaZeux General Errors:

>era:Cannot decrypt write-protected world.
>erb:Cannot overwrite the player- move it first
>erc:Directory rename failed.
>erd:Error saving world
>ere:Error swapping to next world
>erf:(Filename) already exists.
>erg:File rename failed.
>erh:Overlay mode is not on (see Board Info)
>eri:Save would overwrite older world. Aborted.
>erj:Windowing code bug
>erk:You can only play this game via a swap from another game

MegaZeux Validation Errors:

>eva:Any extra scrolls/signs/robots were replaced
>evb:Board @@ (hex location) could not be found
>evc:Board @@ (hex location): found (#) robots; expected (#)
>evd:Board @@ (hex location): found (#) scrolls/signs; expected (#)
>eve:Board @@ (hex location): found (#) sensors; expected (#)
>evf:Board @@ (hex location) is irrecoverably truncated or corrupt
>evg:Board @@ (hex location) is truncated, but could be partially
  ~Frecovered
>evh:Bytecode file (filename) failed validation check
>evi:Cannot load password protected world.
>evj:File doesn't exist!
>evk:File is not a board file or is corrupt
>evl:File is not an MZM or is corrupt
>evm:File is not a valid .SAV file or is corrupt
>evn:File is not a valid world file or is corrupt
>evo:MZM file of a more recent version (version) -- robots will
>evo:be dummied out
>evp:Post validation IO error occurred
>evq:Robot @@ (hex location) is truncated or corrupt
>evr:Runtime robots incompatible with editor -- robots will be
  ~Fdummied out
>evs:.SAV files from newer versions of MZX (version) are not
  ~Fsupported
>evt:.SAV files from older versions of MZX (version) are not
  ~Fsupported
>evu:This world may be password protected.
>evv:World is from a more recent version (version)
>evw:World is from old version (version); use converter

MegaZeux Updater Errors:

>eua:Attempt to invoke self failed!
>eub:Failed to back up manifest. Check permissions.
>euc:Failed to change back to user directory.
>eud:Failed to change into install directory.
>eue:Failed to compute update manifests
>euf:Failed to create (filename). Check permissions.
>eug:Failed to create directories (path too long)
>euh:Failed to create TCP client socket.
>eui:Failed to identify applicable update version.
>euj:Failed to initialize network layer.
>euk:Failed to remove (filename). Check permissions.
>eul:Failed to roll back manifest. Check permissions.
>eum:Failed to prune directories (path too long)
>eun:Transferred more than expected uncompressed size.
>euo:Unknown stat() error occurred

~9MZX General Errors

:era:~ACannot decrypt write-protected world.

This can be caused by file errors or a hard disk space
shortage. It can also result from an attempt to overwrite a
read-only file.

:erb:~ACannot overwrite the player- move it first

The user attempted to place an object over the player. The
player must be moved from its current location if something
else is desired at that location.

:erc:~ADirectory rename failed.
:erg:~AFile rename failed.

The user attempted to rename a directory or file, respectively,
but failed. This could be due to trying to change a read-only
file, trying to change a locked file, or due to some other
error.

:erd:~AError saving world

This can be caused by file errors or a hard disk space
shortage. It can also result from an attempt to overwrite a
read-only file.

:ere:~AError swapping to next world

A Robotic command, SWAP to WORLD, was issued, but the stated
world could not be found or otherwise could not be swapped to,
due to version conflicts, file errors, etc.

:erf:~A(Filename) already exists.

The user attempted to create a new file, but a file with that
name already exists.

:erh:~AOverlay mode is not on (see Board Info)

You cannot edit or copy to the Overlay if it is Off; go to
Board Info and turn it to Normal, Static, or Transparent.

:eri:~ASave would overwrite older world. Aborted.

A save was attempted in the debytecode version of MegaZeux that
would overwrite a non-debytecode world file. Due to the present
instability of debytecode, this is forcibly prevented.

:erj:~AWindowing code bug

This is an internal error. Try to isolate the reason for the
problem and notify the maintainer(s), as this error signifies a
severe bug in MegaZeux.

:erk:~AYou can only play this game via a swap from another game

This error occurs when the user tries to play a game that has
the option set to disallow normal gameplay. The world can only
be played as a swap from another game. For example, this may be
the second half of another game, or a separate world for
showing the introduction.

~9MZX Validation Errors

:evc:~ABoard @@ (hex location): found (#) robots; expected (#)
:evd:~ABoard @@ (hex location): found (#) scrolls/signs; expected (#)
:eve:~ABoard @@ (hex location): found (#) sensors; expected (#)
:eva:~AAny extra robots/scrolls/signs were replaced

MegaZeux found more instances of the given object than the
world file indicated it had. All instances past the expected
amount are tossed out.

:evb:~ABoard @@ (hex location) could not be found

The MegaZeux world is indicating that there should be a board
at the given location, but it is not actually in the world
file.

:evf:~ABoard @@ (hex location) is irrecoverably truncated or corrupt

The board at the given location is corrupt beyond repair and
will be replaced with a blank board.

:evg:~ABoard @@ (hex location) is truncated, but could be partially
~Arecovered

Only part of the board was found, but what board info remained
is placed at that location.

:evh:~ABytecode file (filename) failed validation check

An attempt to load a bytecode file has failed validation checks
and will not be loaded.

:evi:~ACannot load password protected world.

Since MegaZeux 2.80, worlds that are password protected have to
be stripped of the password to run. This error is seen when the
user refuses to decrypt the password-protected file.

:evj:~AFile doesn't exist!

An import of a file was attempted, but the file does not exist.

:evk:~AFile is not a board file or is corrupt
:evl:~AFile is not an MZM or is corrupt
:evm:~AFile is not a valid .SAV file or is corrupt
:evn:~AFile is not a valid world file or is corrupt

An import of the given type was halted due to being unrecognized
as a valid file, or due to corruption.

:evo:~AMZM file of a more recent version (version) -- robots will
~Abe dummied out

Load of an MZM file with Robots from a more recent version of
MZX was attempted. The Robots will be replaced with CustomBlock
facsimiles, as if the file were loaded as a layer-type MZM.

:evp:~APost validation IO error occurred

The given file passed validation, but some other problem is
preventing it from loading.

:evq:~ARobot @@ (hex location) is truncated or corrupt

The Robot at the given location is unrecoverable, and will be
replaced with an empty Robot at that location.

:evr:~ARuntime robots incompatible with editor -- robots will be
~Adummied out

Load of an MZM containing Robots and saved during a running
game was attempted. The Robots will be replaced with
CustomBlock facsimiles, as if the file were loaded as a
layer-type MZM.

:evs:~A.SAV files from newer versions of MZX (version) are not
~Asupported
:evt:~A.SAV files from older versions of MZX (version) are not
~Asupported

The .SAV file the user attempted to load is a different format
than the current version's .SAV and cannot be loaded.

:evu:~AThis world may be password protected.

Worlds saved with password protection (some worlds made before
MZX2.51s3.2) cannot natively run in MegaZeux. MegaZeux will
then prompt the user to decrypt the file.

:evv:~AWorld is from a more recent version (version)

The .MZX file you tried to load or import is from a more
current version of MegaZeux. You must upgrade MegaZeux to the
given version or higher to play this worldfile.

:evw:~AWorld is from old version (version); use converter

The user tried to load a .MZX file from version 1.00g, 1.01,
1.02, or 1.03 of MegaZeux. In order to use these worlds, they
must first be converted to 2.51 format using the included
VER1TO2 program. Run VER1TO2 without any command line arguments
for further instructions.

~9MZX Updater Errors

:eua:~AAttempt to invoke self failed!

This error occurs when MZX fails to reload itself after an
update. This signifies a major bug in MegaZeux; please contact
the maintainer(s).

:eub:~AFailed to back up manifest. Check permissions.
:euf:~AFailed to create (filename). Check permissions.
:euk:~AFailed to remove (filename). Check permissions.
:eul:~AFailed to roll back manifest. Check permissions.

MZX tried to write/delete a file from the working directory,
but could not, likely due to the user's MZX working directory
disallowing write access.

:euc:~AFailed to change back to user directory.
:eud:~AFailed to change into install directory.

These errors occur when MZX fails to change active directories
during the updating process.

:eue:~AFailed to compute update manifests

This error occurs when the hash check in a manifest file fails.
This error can also appear if the download of the manifest file
times out.

:eug:~AFailed to create directories (path too long)
:eum:~AFailed to prune directories (path too long)

This error occurs when the pathnames of the subdirectories
included in or deleted by the selected update are too long.

:euh:~AFailed to create TCP client socket.

MZX failed to create a socket. This may be because the last one
created is still in use. This can signify a major bug in
MegaZeux; please contact the maintainer(s).

:eui:~AFailed to identify applicable update version.

MZX could not find an update in the branch the user selected.
Please check the update_branch_pin and update_host options in
config.txt and make sure they are correct.

:euj:~AFailed to initialize network layer.

MZX's networking code is unable to load. This signifies a major
bug in MegaZeux; please contact the maintainer(s).

:eun:~ATransferred more than expected uncompressed size.

The updater has sent the user more data than needed. The update
may be corrupt.

:euo:~AUnknown stat() error occurred

A fatal error outside of the ones mentioned occurred. Please
contact the developer(s) if you see this error.

>#MAIN.HLP:072:Table of Contents
#SENSORSW.HLP
:094: 
$~9Sensors - What They Are and How to Use Them

Sensors have two real purposes. The first is to act as save
points. The second is to interact with Robots as a type of
floor. The first use is simple - just set the board to "Save
only on Sensors," and then the player can only save when
standing on a Sensor.

The second use is more complex, and requires knowledge of
Robotic. Sensors are like controllable CustomFloors. When
creating one, give it a name and a character, then enter the
name of a Robot with which it will interact. This use of
sensors is easily replicable through Robotic now, so this use
of sensors is deprecated. However, if one wants to use sensors,
this information will easily help.

Sensors interact with Robots using labels (messages) and SEND
commands, just like Robots interact with each other. Any Robot
can SEND a message to a Sensor, but the Sensor will only SEND
messages to the Robot stated in its settings. If you entered a
Robot of ALL, then it will SEND messages to all Robots. Unlike
Robots, Sensors cannot send to a dynamic name; for instance, it
cannot be set to send to "&fest&ive" (whereas a Robot would 
properly send to "1ive" when "fest" is 1 and to "5ive" when
"fest" is 5).

$Messages TO Sensors

The following messages can be sent to a Sensor. A Sensor can
receive messages even when it is beneath the player.

~EDIE

This will cause the Sensor to disappear forever.

~ECHAR'X'

This will cause the Sensor to change its character to X.

~ECHAR###

This will cause the Sensor to change its character to that
represented by the number ###, from 0 to 255.

~ECOLORxx

This will cause the Sensor to change its color to the color
represented by the code xx, a hexadecimal number from 00 to
FF. The color coding is the same as used for Robotic commands,
except without the "c" character. ?s are not allowed.

~EN
~ES
~EE
~EW

This will cause the Sensor to move north, south, east, or west,
respectively. If the player is on top of the Sensor, the player
will move along with it. If the Sensor tries to move towards
the player, it will instead move beneath.

$Messages FROM Sensors

Sensors will send Robots the following messages.

~ESENSORON

This is sent when the player steps onto the Sensor, or when the
Sensor is told to move and it ends up beneath the player, or
when something pushes the player onto the Sensor.

~ESENSORTHUD

This is sent when the Sensor is told to move, but it is blocked.

~ESENSORPUSHED

This is sent when something (not the player, of course) pushes
the Sensor.

$Notes on Sensors

Only the player can step onto a Sensor; other things will push
it. The Sensor, when moving, will move UNDER the player if in
the way, or will take the player with it if the player is on
the Sensor.

>#MAIN.HLP:072:Table of Contents
#ROBOTICR.HLP
:087: 
$~9Robotic Reference Manual

Use the following help links to see your desired topic(s).

>#COMMANDS.HLP:1st:Command Syntax
>#COMMANDR.HLP:1st:Command Reference
>#USINGTHE.HLP:1st:Using the Editor
>#THEGLOBL.HLP:gbl:The Global
>#SENSORSW.HLP:094:Sensors
>#COMMANDS.HLP:dir:Directions
>#COMMANDS.HLP:col:Colors
>#BUILTINL.HLP:1st:Built-in Labels
>#COUNTERS.HLP:1st:Counters, Built-in Counters and Local Counters
>#COMMAND2.HLP:pre:Prefixes
>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic
>#COMMANDS.HLP:con:Conditions
>#SOUNDEFX.HLP:1st:Sound and Music
>#SMZXMODE.HLP:095:Super MZX Modes
>#SUBROUTE.HLP:sub:Subroutines
>#EXPRESS.HLP:exp:Expressions
>#FILEACSS.HLP:fil:File Access
>#SPRITES.HLP:spr:Sprites
>#VLAYER.HLP:vla:The Vlayer
>#MZM.HLP:mzm:Using MZMs
>#TRIG.HLP:tri:Trigonometric Functions
>#PARTIAL.HLP:par:Partial Character Sets
>#BULLETTY.HLP:1st:Bullet Types
>#CHANGECH.HLP:1st:CHANGE CHAR ID - The CHAR ID Table

>#ROBOTSWH.HLP:1st:Robots - What They Are and How to Use Them
>#ROBOTICT.HLP:1st:Robotic Tutorial
>#BADPRACT.HLP:101:Robotic Usages That Should be Avoided
>#MAIN.HLP:072:Table of Contents
#COMMANDS.HLP
:1st: 
$~9Command Syntax

Commands in Robotic must conform to a certain syntax:

  COMMAND [param] [param] ...

COMMAND is the words or symbol that specifies exactly which
command you are using. Params are the values used to supplement
the command's function.

~E"string" or "counter" or "label" or "Robot" or "file"

Strings are a series of characters surrounded by quotes.
Counters are strings representing the name of a counter. Labels
are strings representing the name of a label, a point within a
Robot. Robots are strings representing the name of a Robot.
Files are strings representing a file or folder on disk, always
including the extension in the case of files. (Some string
examples: "Hi", "Gems", "Label5", "*1230 +725", "robott.txt",
etc.) The quotes can be left off if the string contains no
spaces and if the string is not the same as any word found in
any command or parameter, i.e. a word that the editor could not
mistake for a part of a command. MegaZeux will add the quotes
for you if the string meets these criteria. For example,
"fifty" and "HONK" will be auto-completed by MZX, but "Ammo",
"N", "Goto", and "You died" have to have the quotes typed in
manually.

~E#

Numbers are allowed to be integers within the range of
-2147483648 to 2147484647. Numbers can be replaced with a string
representing the name of a counter at any time. Examples of
legal numbers: 3200, -79k, .$FA9, "Ammo". They can also be
represented in hexadecimal, using $xxxx format. In this case,
xxxx can be any number from 0 to FFFF.

Numbers can not directly be allowed to go past the 16-bit
limits (-32768 to 32767) in Robotic commands, but this can be
easily circumvented by using constant expressions. Constant
expressions also allow larger hexadecimal numbers and octal
numbers; please view the expressions section for more detail.

>#EXPRESS.HLP:1st:Expressions

:col:~E[color]

The format for colors is cXX, where X is 0-9, A-F, or ?. The
first X represents the background color, the second X represents
the foreground color. The numbers and symbols represent the
following colors, by default:

0 Black       ~0(color #0)
1 Blue        ~1(color #1)
2 Green       ~2(color #2)
3 Cyan        ~3(color #3)
4 Red         ~4(color #4)
5 Purple      ~5(color #5)
6 Brown       ~6(color #6)
7 Lt. Gray    ~7(color #7)
8 Dk. Gray    ~8(color #8)
9 Lt. Blue    ~9(color #9)
10 Lt. Green  ~A(color #10)
11 Lt. Cyan   ~B(color #11)
12 Lt. Red    ~C(color #12)
13 Lt. Purple ~D(color #13)
14 Yellow     ~E(color #14)
15 White      ~F(color #15)
? Any color/No change in color

The UI uses its own set of protected colors, to prevent general
color edits from harming usability. However, one can still
temporarily edit the UI colors through Robotic by editing
colors 16-31.

The use of ? is not always a logical option for some commands.
When used, it signifies to replace it with the current color or
ignore that part of the color for that command (or if used in
IF statements, signifies to accept any value in that field).
Colors may be selected from a menu within the Robot editor
using F2. Colors can also be replaced with the name of a
counter at any time. In this case, the value of the counter is
BK*16+FG, where BK and FG are 0-15. To use ?, use the following
values:

   256+FG = c?X
   272+BK = cX?
   288    = c??

A color of c?? will be inserted into commands when you do not
put down anything for the color. Examples of legal colors: cF9,
c02, c?5, c??, "Colored".

While detecting colors of ?? is generally an accepted practice,
it's extremely discouraged to change to or put colors of ??.

>#BADPRACT.HLP:101:Robotic Usages That Should be Avoided

~E[char]

Characters are a single character surrounded by apostrophes,
e.g. 'X'. X can be any character except #0. A character can be
selected from a menu in the Robot editor using F3. Numbers and
counters can be used to represent characters as well, with
values from 0 to 255 (other values will wrap around to be
0-255). Examples of legal characters - 'a', '±', 20, "Count".
Characters can also represent numbers, so typing in commands
like INC "health" '5' will most likely yield _much_ different
results than what was likely intended. However, for some usages
this use of chars is vastly superior to any other method (such
as when reading from the overlay onto strings).

:dir:~E[dir]

Directions are used to denote a direction on the board. A
direction is one of the following:

  NORTH (or N or UP)
  SOUTH (or S or DOWN)
  EAST (or E or RIGHT)
  WEST (or W or LEFT)
  IDLE
  NODIR
  ANYDIR
  RANDNS
  RANDEW
  RANDNE
  RANDNB
  RANDB
  SEEK
  FLOW
  RANDANY
  UNDER (or BENEATH)

The four cardinal directions (N, S, E, W) are self-explanatory.
Below are descriptions of the other directions.

~BIDLE

No direction, as in the absence of any direction. Used with:

:_w5:~AWALK [dir]

>#COMMANDS.HLP:con:Conditions

~BNODIR

No directions satisfy the condition. Used with:

>#COMMANDS.HLP:con:Conditions

~BANYDIR

Any direction satisfies the condition. Used with:

>#COMMANDS.HLP:con:Conditions

~BRANDNS

Randomly either NORTH or SOUTH.

~BRANDEW

Randomly either EAST or WEST.

~BRANDNE

Randomly either NORTH or EAST.

~BRANDNB

Randomly any direction where the Robot is not blocked by
something.

~BRANDB

Randomly any direction where the Robot is blocked.

~BSEEK

The direction closest to the player. If the player is on a
diagonal and is equally far away from the Robot vertically and
horizontally, the direction will randomly be one of the two
directions comprising the diagonal.

~BFLOW

The direction that the Robot is currently walking.

~BRANDANY

Randomly one of NORTH, SOUTH, EAST, or WEST.

~BUNDER

The direction signifying whatever is BENEATH something, such
as floors. Often used with:

:_l1:~ALAYBOMB [dir]
:_l2:~ALAYBOMB HIGH [dir]

>#COMMANDS.HLP:con:Conditions

Most directions can be used with the following modifying
prefixes:

~BOPP

The opposite direction. NORTH becomes SOUTH, etc.

~BCW

The direction clockwise of the named direction. NORTH becomes
EAST, etc.

~BRANDP

Randomly a direction perpendicular to the named direction.
NORTH becomes EAST or WEST, etc.

~BRANDNOT

Randomly any direction OTHER than the given direction.

~E[thing]

The name of any object from the editor, other than the player.
Use the name from the object list, minus any punctuation or
spaces. In addition to the things on the lists, you can use
Lazer for any lazer walls shot by lazer guns or Robots, and
OpenGate for a gate that has been opened. Examples of legal
things: Gem, CustomFloor, LitBomb, Robot.

~E[param]

A code representing the settings for a thing. (see above) The
format is p# or p??. # is a hexadecimal code from 0 to FF. ??
represents settings that you don't care about or shouldn't
change. To enter parameter codes easily, use F4 in the Robot
editor after you have typed in an object name. p?? will be
inserted automatically any time you have a thing without a
parameter. Counters can also be used as parameters, as well as
decimal numbers; to insert decimal numbers, place the number
in the proper location, but without the "p" before it.

~E[item]

One of the following: TIME, SCORE, GEMS, AMMOS, LIVES, LOBOMBS,
HIBOMBS, COINS, HEALTHS. Note the plural format. This
distinguishes items from things.

~E!<>=

A conditional for comparing two numbers, counters or strings:

= or ==        Equal to
.<              Less than
.>              Greater than
.<= or =<       Less than or equal to
.>= or =>       Greater than or equal to
!= or <> or >< Not equal to

:con:~E[condition]

A word, sometimes followed by a direction, signifying a certain
condition; use in IF [condition] and IF NOT [condition] commands
to test whether a condition is currently present.

~BWALKING [dir]

Tests whether the Robot is currently walking in a given
direction. IDLE, NODIR, and ANYDIR are allowed here.

~BSWIMMING

Tests whether the Robot is currently in water.

~BFIREWALKING

Tests whether the Robot is currently in either lava or fire.

~BTOUCHING [dir]

Tests whether the player is next to the Robot in the given
direction. NODIR and ANYDIR are allowed here.

~BBLOCKED [dir]

Tests whether the Robot is blocked by something in the given
direction. NODIR and ANYDIR are allowed here. This condition
has a special mode: if the IF command has a REL PLAYER prefix
before it, it will instead check next to the PLAYER for being
blocked. If the IF command has a REL COUNTERS prefix before
it, it will instead check next to the position pointed to by
the counters XPOS and YPOS.

>#COMMAND2.HLP:pre:REL COUNTERS
>#COMMAND2.HLP:_r2:REL PLAYER

~BALIGNED

Tests whether the player is aligned with the Robot either
horizontally or vertically.

~BALIGNEDNS
~BALIGNEDEW

Tests whether the player is aligned with the Robot, but only
tests on the horizontal (EW) or vertical (NS) axis, not both
at once.

~BLASTSHOT [dir]

Tests whether the last direction the Robot was shot in was
the given direction. For example, if the Robot had just been
shot on the north side, then LASTSHOT NORTH would be true.

~BLASTTOUCH [dir]

Similar to the above; tests whether the last direction the
Robot was touched by the player is the given direction.

~BRIGHTPRESSED
~BLEFTPRESSED
~BUPPRESSED
~BDOWNPRESSED
~BSPACEPRESSED
~BDELPRESSED

Tests whether the indicated key is currently being held down.

~BMUSICON

Tests whether digitized music and sound effects are currently
on.

~BPCSFXON

Tests whether PC speaker sound effects are currently on.

~EMiscellaneous

When typing in a command, the following symbols and words, as
well as spaces, can be used freely. They have no effect on the
final command and are only used to clarify its meaning.

, (comma)
; (semicolon)
A
AN
AND
AS
AT
BY
ELSE
FOR
FROM
INTO
IS
OF
THE
THEN
THERE
THROUGH
THRU
TO
WITH

These will disappear from the line if "disassemble_extras" is
set to 0 in the config file. See the config file for further
details.

>#CONFGINI.HLP:1st:The Config File
>#MAIN.HLP:072:Table of Contents
>#ROBOTICR.HLP:087:Robotic Reference Manual
#STRINGS.HLP
:1st:Strings, Special Formatting, and Their Place in Robotic

$Simple Strings

Generally, a string is a series of symbols within quotes: "BUG",
"Hi there!", or even "ÅEA9 _±Ç". There are two special aspects
or features of strings that may be useful: color coding, and
counter interpolation.

$Color

Used in Robotic commands *, %, ?, and &, strings can contain
color codes. There are two color symbols: ~~ for changing
foreground, and @@ for changing background. These should be
followed by one of these characters:

    0 Black (color 0)        8 Dk. Gray (color 8)
    1 Blue (color 1)         9 Lt. Blue (color 9)
    2 Green (color 2)        A Lt. Green (color 10)
    3 Cyan (color 3)         B Lt. Cyan (color 11)
    4 Red (color 4)          C Lt. Red (color 12)
    5 Purple (color 5)       D Lt. Purple (color 13)
    6 Brown (color 6)        E Yellow (color 14)
    7 Lt. Gray (color 7)     F White (color 15)
    

To show a ~~, use a ~~~~. To show a @@, use @@@@.

$Counters

Strings can show the values of counters, using the counter name
surrounded with &s. For example, if the player has 55 gems,
"You have &GEMS& gems." will become "You have 55 gems." If you
use &INPUT&, then the last inputted string will be shown. Use &&
to show a true '&'. The above features are available in nearly
ALL Robotic commands that use strings, including in the name of
OTHER counters. (The sole exception is in label names.) This
can be used to simulate array-like constructs.

$Robotic Usage of Strings

In Robotic, strings can be incredibly powerful. They can act
like counters, but hold text information as well as numbers
(however, counters are by far better-suited for number use).
A Robotic string is any counter prefixed by a $ sign (e.g. 
"$string").

Certain characters must be inputted in specific ways to avoid
problems with Robotic:

  \0 for character 0 (this probably won't work in strings, but
  should work in chars)
  \t for tab (character 9)
  \n for newline (character 10)
  \r for carriage return (character 13)
  \" for quotation mark
  \\ for slash

$Robotic Usage - Setting Strings

~BSET "$string" to "text"

Sets the given string to the given line of text.

~BSET "$string" to "$string2"

Sets the given string to the contents of another string.

~BSET "$string" to #

Sets the string to an integer value. Notice that DEC commands
and other similar commands will not work arithmetically with
strings but instead clip and append to the string.

$Robotic Usage - Outputting Strings

Anywhere you can output a counter, you can output a string.
Simply encase the string name in ampersands. E.G.:

~ESET "$woohoo" to "My favorite song!"
~E* "&$woohoo&"

Would output "My favorite song!" in the message row.

There are several special things you can set strings to for
certain functions.

>#COUNTERS.HLP:stc:String Counters

$Robotic Usage - Comparing Strings

Strings can be compared through these commands:

~BIF "$string" = "value" then "label"
~BIF "$string" != "value" then "label"
~BIF "$string" > "value" "label"
~BIF "$string" < "value" "label"
~BIF "$string" >= "value" "label"
~BIF "$string" <= "value" "label"

String comparisons are case-insensitive. Allowed comparisons
are to a line of text, to another string and to a number.
However, the string is required to be the first item, and
string counters such as "MOD_NAME", "BOARD_SCAN", etc. are not
valid comparisons.

$Robotic Usage - Manipulating Strings

Firstly, strings can be offset and limited ("spliced").

~B$strname#X~F will cap the string to X characters in length.

~B$strname+X~F will offset the start of the string by X
characters.

~B$strname+X#Y~F will offset the string by X characters and limit
the string to Y characters in length.

Normally string splicing is used to read a given selection of a
string; however, it can also be used for writing to parts of
strings. When you set an offset when setting a string, the
length of the string will not decrease, so you'll only
manipulate a portion of the string. For instance:

~Bset "$str" "hello"
~Bset "$str+1" "LOL"

Will cause $str to have the value "hLOLo"

Writing to parts of strings also changes how the string limit
works; the cap will limit how much of the spliced-in material
is inserted instead of limiting the string length in total. For
instance:

~B set "$str" "Baby steps."
~B set "$str#4" "Long journey."

Will cause $str to have the value "Long steps."

~B$strname.X~F will manipulate the Xth character in a string
(starting from 0). When used for output, it will give the
character value of the given character in a string. Any invalid
numbers (past the terminator) are given a value of 0. This
command works well with char immediates: 
E.G. SET "$string.0" 'S' . When setting the character in a
string it will make the string length one larger than X, so be
careful when using very large values.

~B$str.length~F will give the length of the given string.

Secondly, strings can be clipped, appended or written to from
the board or overlay.

~BINC "$string" "$string2"
~BINC "$string" "text"

These two commands append another string's contents or text,
respectively, to the end of a given string.

~BDEC "$string" #

This command clips the given number of characters from the end
of a string. # is treated as unsigned so using negative numbers
will probably cause the length to go down to zero.

~BCOPY BLOCK x y w h "$string" t
~BCOPY OVERLAY BLOCK x y w h "$string" t

These commands copy information from the board or overlay,
respectively, to a given string. X and Y are the coordinates
of the upper-left corner of the block; W and H are its width
and height; T is the terminating character. For T, one can put
in a counter with the param value of the desired terminator
character or a char immediate in the form 'c' (not just the
character itself). If "t" is 0 there will be no terminator.
The letters are added from left to right and up to down until
the terminator character is reached, or until the end of the
given block is reached. If x and y begin with a pound sign (#),
the string will instead be read from the vlayer. Please use
this method of scanning strings instead of BOARD_SCAN.

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#COMMANDR.HLP
:1st: 
$~9Command Reference

The following table is a list of all Robotic commands in
MegaZeux. They are listed as help links, in alphabetical order.
After the table are the actual command descriptions, in order
of importance/difficulty. Note that because of its size, the
command reference is split into two parts.

>__1:% "string"
>__2:& "string"
>__3:* "string"
>__4:. "string"
>_4b:. "@@string"
>__5:/ "string"
>__6:: "label"
>__7:? "counter" "label" "string"
>__8:? "label" "string"
>__9:[ "string"
>#COMMAND2.HLP:__0:| "label"
>_a1:ABORT LOOP
>#COMMAND2.HLP:_a2:ASK "string"
>#COMMAND2.HLP:_a3:AVALANCHE
>_b1:BECOME [color] [thing] [param]
>#COMMAND2.HLP:_b2:BECOME NONLAVAWALKER
>#COMMAND2.HLP:_b3:BECOME NONPUSHABLE
>#COMMAND2.HLP:_b4:BECOME LAVAWALKER
>#COMMAND2.HLP:_b5:BECOME PUSHABLE
>#COMMAND2.HLP:_b6:BLIND #
>#COMMAND2.HLP:_b7:BOARD [dir] "string"
>#COMMAND2.HLP:_b8:BOARD [dir] NONE
>#COMMAND2.HLP:_b9:BULLETCOLOR [color]
>#COMMAND2.HLP:_b0:BULLETE [char]
>#COMMAND2.HLP:_bA:BULLETN [char]
>#COMMAND2.HLP:_bB:BULLETS [char]
>#COMMAND2.HLP:_bC:BULLETW [char]
>#COMMAND2.HLP:_c1:CENTER MESG
>_c2:CHANGE [color] [thing] [param] [color] [thing] [param]
>#COMMAND2.HLP:_c3:CHANGE CHAR ID # [char]
>#COMMAND2.HLP:_c4:CHANGE OVERLAY [color] [char] [color] [char]
>#COMMAND2.HLP:_c5:CHANGE OVERLAY [color] [color]
>#COMMAND2.HLP:_c6:CHANGE SFX # "string"
>#COMMAND2.HLP:_c7:CHANGE THICK ARROW CHAR [dir] [char]
>#COMMAND2.HLP:_c8:CHANGE THIN ARROW CHAR [dir] [char]
>_c9:CHAR [char]
>#COMMAND2.HLP:_c0:CHAR EDIT [char] # # # # # # # # # # # # # #
>#COMMAND2.HLP:_cA:CLEAR MESG
>#COMMAND2.HLP:_cB:CLIP INPUT
>_cC:COLOR [color]
>_cD:COLOR FADE OUT
>_cE:COLOR FADE IN
>#COMMAND2.HLP:_cF:COLOR INTENSITY # PERCENT
>#COMMAND2.HLP:_cG:COLOR INTENSITY # # PERCENT
>#COMMAND2.HLP:_cH:COPY # # # #
>#COMMAND2.HLP:_cI:COPY [dir] [dir]
>#COMMAND2.HLP:_cJ:COPY BLOCK # # # # # #
>#COMMAND2.HLP:_cK:COPY CHAR [char] [char]
>#COMMAND2.HLP:_cL:COPY OVERLAY BLOCK # # # # # #
>#COMMAND2.HLP:_cQ:COPY BLOCK # # # # "@@filename" #
>#COMMAND2.HLP:_cR:COPY OVERLAY BLOCK # # # # "@@filename" #
>#COMMAND2.HLP:_cS:COPY (OVERLAY) BLOCK "#x" "#y" # # "@@filename" #
>#COMMAND2.HLP:_cT:COPY BLOCK # # # # "$string" #
>#COMMAND2.HLP:_cU:COPY OVERLAY BLOCK # # # # "$string" #
>#COMMAND2.HLP:_cV:COPY (OVERLAY) BLOCK "#x" "#y" # # "$string" #
>#COMMAND2.HLP:_cW:COPY BLOCK # # # # "#x" "#y"
>#COMMAND2.HLP:_cX:COPY OVERLAY BLOCK # # # # "#x" "#y"
>#COMMAND2.HLP:_cY:COPY BLOCK "#x" "#y" # # # #
>#COMMAND2.HLP:_cZ:COPY OVERLAY BLOCK "#x" "#y" # # # #
>#COMMAND2.HLP:_cAA:COPY (OVERLAY) BLOCK "#x1" "#y1" # # "#x2" "#y2"
>_cM:COPYROBOT "Robot"
>_cN:COPYROBOT # #
>_cO:COPYROBOT [dir]
>_cP:CYCLE #
>_d1:DEC "counter" #
>_d2:DEC "counter" RANDOM # #
>#COMMAND2.HLP:_dA:DEC "$string" #
>_d3:DIE
>_d4:DIE ITEM
>#COMMAND2.HLP:_d5:DISABLE MESG EDGE
>#COMMAND2.HLP:_d6:DISABLE SAVING
>_d7:DIVIDE "counter" #
>_d8:DOUBLE "counter"
>_d9:DUPLICATE SELF # #
>_d0:DUPLICATE SELF [dir]
>_e1:END
>_e2:END MOD
>_e3:END PLAY
>_e4:END SAM
>_e5:ENDGAME
>_e6:ENDLIFE
>#COMMAND2.HLP:_e7:ENABLE MESG EDGE
>#COMMAND2.HLP:_e8:ENABLE SAVING
>#COMMAND2.HLP:_e9:ENABLE SENSORONLY SAVING
>#COMMAND2.HLP:_e0:ENEMY BULLETCOLOR [color]
>#COMMAND2.HLP:_eA:ENEMY BULLETE [char]
>#COMMAND2.HLP:_eB:ENEMY BULLETN [char]
>#COMMAND2.HLP:_eC:ENEMY BULLETS [char]
>#COMMAND2.HLP:_eD:ENEMY BULLETW [char]
>#COMMAND2.HLP:_eE:EXCHANGE PLAYER POSITION
>#COMMAND2.HLP:_eF:EXCHANGE PLAYER POSITION #
>#COMMAND2.HLP:_eG:EXCHANGE PLAYER POSITION # DUPLICATE SELF
>_eH:EXPLODE #
>#COMMAND2.HLP:_f1:FIREWALKER #
>#COMMAND2.HLP:_f2:FILLHEALTH
>#COMMAND2.HLP:_f3:FLIP CHAR [char] [dir]
>#COMMAND2.HLP:_f4:FREEZETIME #
>#COMMAND2.HLP:_g1:GIVE # [item]
>#COMMAND2.HLP:_g2:GIVEKEY [color]
>#COMMAND2.HLP:_g3:GIVEKEY [color] "label"
>_g4:GO [dir] #
>_g5:GOTO "label"
>_g6:GOTO "#return"
>_g7:GOTO "#top"
>_g8:GOTOXY # #
>_h1:HALF "counter"
>_i1:IF "counter" !<>= # "label"
>#COMMAND2.HLP:_i2:IF [condition] "label"
>#COMMAND2.HLP:_i3:IF # # "label"
>#COMMAND2.HLP:_i4:IF [dir] PLAYER [color] [thing] [param] "label"
>#COMMAND2.HLP:_i5:IF [color] [thing] [param] # # "label"
>#COMMAND2.HLP:_i6:IF [color] [thing] [param] [dir] "label"
>#COMMAND2.HLP:_i7:IF ALIGNEDROBOT "Robot" "label"
>#COMMAND2.HLP:_i8:IF ANY [color] [thing] [param] "label"
>#COMMAND2.HLP:_i9:IF FIRST STRING "string" "label"
>#COMMAND2.HLP:_i0:IF NO [color] [thing] [param] "label"
>#COMMAND2.HLP:_iA:IF NOT [color] [thing] [param] [dir] "label"
>#COMMAND2.HLP:_iB:IF NOT [condition] "label"
>#COMMAND2.HLP:_iC:IF PLAYER # # "label"
>#COMMAND2.HLP:_iD:IF STRING "string" "label"
>#COMMAND2.HLP:_iE:IF STRING MATCHES "string" "label"
>#COMMAND2.HLP:_iF:IF STRING NOT "string" "label"
>#COMMAND2.HLP:_iO:IF "$string" (equality) # "label"
>#COMMAND2.HLP:_iK:IF "$string" (equality) "text" "label"
>#COMMAND2.HLP:_iL:IF "$string" (equality) "$string2" "label"
>#COMMAND2.HLP:_iG:IF c?? Sprite_Colliding pNN # # "label"
>#COMMAND2.HLP:_iH:IF c?? Sprite p?? # # "label"
>#COMMAND2.HLP:_iM:INC "$string" "text"
>#COMMAND2.HLP:_iN:INC "$string" "$string2"
>_iI:INC "counter" #
>_iJ:INC "counter" RANDOM # #
>#COMMAND2.HLP:_iP:INPUT STRING "string"
>#COMMAND2.HLP:_j1:JUMP MOD ORDER #
>#COMMAND2.HLP:_l1:LAYBOMB [dir]
>#COMMAND2.HLP:_l2:LAYBOMB HIGH [dir]
>#COMMAND2.HLP:_l3:LAZERWALL [dir] #
>#COMMAND2.HLP:_l4:LOAD CHAR SET "file"
>#COMMAND2.HLP:_l5:LOAD PALETTE "file"
>#COMMAND2.HLP:_l6:LOCKPLAYER
>#COMMAND2.HLP:_l7:LOCKPLAYER ATTACK
>#COMMAND2.HLP:_l8:LOCKPLAYER EW
>#COMMAND2.HLP:_l9:LOCKPLAYER NS
>#COMMAND2.HLP:_l0:LOCKSCROLL
>_lA:LOCKSELF
>_lB:LOOP #
>_lC:LOOP START
>#COMMAND2.HLP:_m1:MESSAGE ROW #
>#COMMAND2.HLP:_m2:MISSILECOLOR [color]
>_m3:MOD "file"
>#COMMAND2.HLP:_m4:MOD FADE # #
>#COMMAND2.HLP:_m5:MOD FADE IN "file"
>#COMMAND2.HLP:_m6:MOD FADE OUT
>#COMMAND2.HLP:_m7:MOD SAM # #
>_m8:MOD "*"
>_m9:MODULO "counter" #
>#COMMAND2.HLP:_m0:MOVE ALL [color] [thing] [param] [dir]
>_mA:MOVE PLAYER [dir]
>_mB:MOVE PLAYER [dir] "label"
>_mC:MULTIPLY "counter" #
>#COMMAND2.HLP:_n1:NEUTRAL BULLETCOLOR [color]
>#COMMAND2.HLP:_n2:NEUTRAL BULLETE [char]
>#COMMAND2.HLP:_n3:NEUTRAL BULLETN [char]
>#COMMAND2.HLP:_n4:NEUTRAL BULLETS [char]
>#COMMAND2.HLP:_n5:NEUTRAL BULLETW [char]
>#COMMAND2.HLP:_o1:OPEN [dir]
>#COMMAND2.HLP:_o2:OVERLAY ON
>#COMMAND2.HLP:_o3:OVERLAY STATIC
>#COMMAND2.HLP:_o4:OVERLAY TRANSPARENT
>_p1:PERSISTENT GO "string"
>_p2:PLAY "string"
>_p3:PLAY SFX "string"
>#COMMAND2.HLP:_p4:PLAYER BULLETCOLOR [color]
>#COMMAND2.HLP:_p5:PLAYER BULLETE [char]
>#COMMAND2.HLP:_p6:PLAYER BULLETN [char]
>#COMMAND2.HLP:_p7:PLAYER BULLETS [char]
>#COMMAND2.HLP:_p8:PLAYER BULLETW [char]
>_p9:PLAYER CHAR [dir] [char]
>_p0:PLAYER CHAR [char]
>_pA:PLAYERCOLOR [color]
>#COMMAND2.HLP:_pB:PUSH [dir]
>_pC:PUT [color] [thing] [param] # #
>_pD:PUT [color] [thing] [param] [dir]
>#COMMAND2.HLP:_pE:PUT [color] [char] OVERLAY # #
>_pF:PUT [color] [thing] [param] [dir] PLAYER
>_pG:PUT PLAYER # #
>_pH:PUT PLAYER [dir]
>_pI:PUT "@@FILENAME.XXX" Image_File [param] # #
>_pJ:PUT [color] Sprite [param] # #
>#COMMAND2.HLP:pre:REL COUNTERS
>#COMMAND2.HLP:_r2:REL PLAYER
>#COMMAND2.HLP:_r3:REL SELF
>#COMMAND2.HLP:_r4:REL COUNTERS FIRST
>#COMMAND2.HLP:_r5:REL PLAYER FIRST
>#COMMAND2.HLP:_r6:REL SELF FIRST
>#COMMAND2.HLP:_r7:REL COUNTERS LAST
>#COMMAND2.HLP:_r8:REL PLAYER LAST
>#COMMAND2.HLP:_r9:REL SELF LAST
>#COMMAND2.HLP:_r0:RESETVIEW
>#COMMAND2.HLP:_rA:RESTORE "label" #
>#COMMAND2.HLP:_rB:RESTORE PLAYER POSITION
>#COMMAND2.HLP:_rC:RESTORE PLAYER POSITION #
>#COMMAND2.HLP:_rD:RESTORE PLAYER POSITION # DUPLICATE SELF
>#COMMAND2.HLP:_rE:ROTATECW
>#COMMAND2.HLP:_rF:ROTATECCW
>_s1:SAM # "file"
>#COMMAND2.HLP:_s2:SAVE PLAYER POSITION
>#COMMAND2.HLP:_s3:SAVE PLAYER POSITION #
>#COMMAND2.HLP:_s4:SCROLL CHAR [char] [dir]
>#COMMAND2.HLP:_s5:SCROLLARROW COLOR [color]
>#COMMAND2.HLP:_s6:SCROLLBASE COLOR [color]
>#COMMAND2.HLP:_s7:SCROLLCORNER COLOR [color]
>#COMMAND2.HLP:_s8:SCROLLPOINTER COLOR [color]
>#COMMAND2.HLP:_s9:SCROLLTITLE COLOR [color]
>#COMMAND2.HLP:_s0:SCROLLVIEW [dir] #
>#COMMAND2.HLP:_sA:SCROLLVIEW POSITION # #
>_sB:SEND # # "label"
>_sC:SEND "Robot" "label"
>_sD:SEND [dir] "label"
>_sE:SEND [dir] PLAYER "label"
>_sF:SET "counter" #
>_sG:SET "counter" RANDOM # #
>_sH:SET "$string" "text"
>_sI:SET "$string1" "$string2"
>_sJ:SET "$string" #
>#COMMAND2.HLP:_sK:SET COLOR # # # #
>#COMMAND2.HLP:_sL:SET EDGE COLOR [color]
>#COMMAND2.HLP:_sM:SET MAXHEALTH #
>#COMMAND2.HLP:_sN:SET MESG COLUMN #
>_sO:SFX #
>_sP:SHOOT [dir]
>_sQ:SHOOTMISSILE [dir]
>_sR:SHOOTSEEKER [dir]
>#COMMAND2.HLP:_sS:SLOWTIME #
>_sT:SPITFIRE [dir]
>#COMMAND2.HLP:_sU:STATUS COUNTER # "counter"
>#COMMAND2.HLP:_sV:SWAP WORLD "file"
>#COMMAND2.HLP:_sW:SWITCH [dir] [dir]
>#COMMAND2.HLP:_t1:TAKE # [item]
>#COMMAND2.HLP:_t2:TAKE # [item] "label"
>#COMMAND2.HLP:_t3:TAKEKEY [color]
>#COMMAND2.HLP:_t4:TAKEKEY [color] "label"
>#COMMAND2.HLP:_t5:TELEPORT PLAYER "string" # #
>#COMMAND2.HLP:_t6:TRADE # [item] # [item] "label"
>_t7:TRY [dir] "label"
>#COMMAND2.HLP:_u1:UNLOCKPLAYER
>#COMMAND2.HLP:_u2:UNLOCKSCROLL
>_u3:UNLOCKSELF
>#COMMAND2.HLP:_v1:VIEWPORT # #
>#COMMAND2.HLP:_v2:VIEWPORT SIZE # #
>_v3:VOLUME #
>_w1:WAIT #
>#COMMAND2.HLP:_w2:WAIT MOD FADE
>#COMMAND2.HLP:_w3:WAIT PLAY
>_w4:WAIT PLAY "string"
>_w5:WALK [dir]
>#COMMAND2.HLP:_w6:WIND #
>#COMMAND2.HLP:_w7:WRITE OVERLAY [color] "string" # #
>#COMMAND2.HLP:_z1:ZAP "label" #

$Command Descriptions

:__3:~A* "string"

This command displays the given string as a message on the
message line, at the bottom of the screen by default.

>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:__5:~A/ "string"
:_p1:~APERSISTENT GO "string"
:_g4:~AGO [dir] #

Use / followed by a string to move the Robot around the board.
The string must consist of a series of N, S, E, W, and I. NSEW
will move the Robot in that direction, and I will wait for one
cycle. One action is performed each cycle.

Use PERSISTENT GO in the same way as /. However, if the Robot
attempts to move in a given direction and it cannot, the Robot
will wait until it can before moving on to the next symbol.

Use GO to move in a single direction for a given number of
spaces (limited to 255; higher numbers and negatives wrap).

These commands can be used concurrently with ~AWALK [dir]~F, 
allowing Robots to move in double-speed steps. However, this
can only happen when the commands are in the same cycle and if
the given string/number for the moving command is small.

>_w5:WALK [dir]
>#COMMANDS.HLP:dir:Directions

:__6:~A:~A "label"

A : is used to denote actual LABELS within a Robotic program.
These labels are used as points within the program to branch
to when a Robot receives a message from another Robot, goes to
a label of its own, or otherwise receives an external message.
Label names can be any length and consist of any characters.
They are not case-sensitive, and they can not take interpreted
counters (e.g. : "&label&").

Labels starting with a pound sign/hash (#) are subroutines.
See the corresponding section for more information.

>#SUBROUTE.HLP:sub:Subroutines
>#BUILTINL.HLP:1st:Built-in Labels

:_g5:~AGOTO "label"

This will attempt to send the current Robot to the label
given; if the label does not exist, this command does nothing.
If the label begins with a # it will go to it as a subroutine.

:_g6:~AGOTO "#return"
:_g7:~AGOTO "#top"

This will send the current Robot to the line after the
next-highest subroutine call and to the line after the first
subroutine call, respectively.

>#SUBROUTE.HLP:sub:Subroutines

:_sC:~ASEND "Robot" "label"
:_sD:~ASEND [dir] "label"
:_sE:~ASEND [dir] PLAYER "label"
:_sB:~ASEND # # "label"

Use SEND to send another Robot to the label given. This is
called "messaging" a Robot, and the label given is the
"message". The target Robot can be given one of four ways,
as listed above respectively:

1. State the target Robot's name. Use "ALL" to message all
Robots (including the Robot doing the send). Set ~ALOCKSELF~F
beforehand to prevent sending to yourself when sending to
"ALL".
2. State the direction of the target Robot.
3. State the direction of the target Robot, relative to the
player.
4. State the {x,y} coordinates of the target Robot.

>#COMMANDS.HLP:dir:Directions
>#COMMANDR.HLP:_lA:LOCKSELF

:__9:~A[ "string"
:__2:~A& "string"
:__1:~A% "string"
:__8:~A? "label" "string"
:__7:~A? "counter" "label" "string"

Use these commands to bring up a message box during the game
containing the given text. The message box will contain all
consecutive lines using the commands [, &, %, or ?. Blank lines
and labels will be skipped over. The box message commands are
as follows:

  [ will simply display the given message.
  & will display the given message, centered within the box.
  % will display the given message, which can have color
   codes.
  ? will display an option, which, when selected, will send
   the current Robot to the given label. If a counter is
   included, the option will only be shown if the counter is
   NOT zero.

All box-message commands can use ~~ and @@ color codes, EXCEPT
for [. The advantage of [ is that it will be clipped to 64
characters if it is too long, thereby preventing the display
from being screwed up. The other commands are not clipped and,
if too long, can mess up the current display. (No permanent
damage is done, it just looks stupid.)

NOTE: Take care when using any of these commands in a loop (and
be especially vigilant of possible unintended loops). Looping
these commands without any WAITs or similar cycle-breaking
commands (or repeatedly jumping to a label with said command)
can cause the dialogue box to re-appear as soon as it is
closed, making it very hard to close the MZX world.

>#COUNTERS.HLP:1st:Counters, Built-in Counters and Local Counters
>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:__4:~A. "string"

This command does nothing. It is used for comments and other
notes you may wish to make within your Robots. There is one
exception - If "string" begins with a @@. (see next) You may
comment or de-comment lines of code automatically with the
Ctrl+C command (comment mark). Comments can nonetheless have an
actual effect on code speed, as they must be interpreted when
encountered.

:_4b:~A. "@@string"

If a comment's string begins with a @@, then the rest of the
string becomes the new name for the Robot. For example,
"@@Hiya" would name the Robot "Hiya". This clips at the first
14 characters of the string; for example, . "@@Robothasanewname"
would cut off and rename the Robot "Robothasanewna".

:_e1:~AEND

This command ends the Robot's program. The Robot will not run
any further commands until an external event affects it.

:_d3:~ADIE
:_d4:~ADIE ITEM

These commands destroy the Robot forever. DIE ITEM will also
put the player at the location the Robot previously occupied,
which is useful for creating Robots that simulate items.

:_w1:~AWAIT #

This command will cause the Robot to do absolutely nothing for
a given number of cycles (limited to 255; values over this will
wrap around).

:_c9:~ACHAR [char]

This command will change the Robot's character (appearance) to
the character given.

:_cC:~ACOLOR [color]

This command will change the Robot's color to the color given.

>#COMMANDS.HLP:col:Colors

:_sF:~ASET "counter" #
:_sG:~ASET "counter" RANDOM # #

These commands set a counter to a certain value. Counters are
internal variables that can be changed through Robots. They are
usually used for custom purposes, although there are many
counters with pre-defined uses as well, such as "Gems". The
RANDOM version will set the counter to a random number within
the given range, inclusive.

:_sH:~ASET "$string" "text"
:_sI:~ASET "$string" "$string2"
:_sJ:~ASET "$string" number

These commands set strings to a certain value: a line of text,
another string or a number, respectively.

>#COUNTERS.HLP:1st:Counters, Built-in Counters and Local Counters

:_iI:~AINC "counter" #
:_d1:~ADEC "counter" #
:_iJ:~AINC "counter" RANDOM # #
:_d2:~ADEC "counter" RANDOM # #

These commands will increase or decrease a given counter or
string by a given amount. The RANDOM versions will increase or
decrease by a random number within the given range, inclusive.

>#COUNTERS.HLP:1st:Counters, Built-in Counters and Local Counters

:_i1:~AIF "counter" !<>= # "label"

This command tests to see if a given counter is equal to, less
than, etc. another counter or value. If the conditional is met,
the current Robot is sent to the given label. The following
conditionals are allowed- = Equal, < Less than, > Greater than,
.<= Less than/equal, >= Greater than/equal, <> (also !=) Not
equal.

>#COUNTERS.HLP:1st:Counters, Built-in Counters and Local Counters

:_cP:~ACYCLE #

This command changes the Robot's speed to one Robot cycle for
every given number of update cycles. An update cycle is how
often everything onscreen is updated, such as most enemies.
Every time a given Robot gets to run commands is called a cycle
in terms of that Robot; most commands can run several times in
a single Robot cycle. (CYCLE # values are limited to 255;
values over this will wrap around.)

:_e6:~AENDLIFE
:_e5:~AENDGAME

These commands will end the player's current life or the entire
game, just as if the player died or lost all of its lives.

:_w5:~AWALK [dir]

This will cause the Robot to move one space in the given
direction every cycle. Use a direction of IDLE to turn walking
off.

This can be used concurrently with ~AGO [dir] #~F and its
relatives to make Robots move in double-speed steps.

>_g4:GO [dir] #
>__5:/ "string"
>_p1:PERSISTENT GO "string"
>#COMMANDS.HLP:dir:Directions

:_sP:~ASHOOT [dir]
:_sQ:~ASHOOTMISSILE [dir]
:_sR:~ASHOOTSEEKER [dir]
:_sT:~ASPITFIRE [dir]

These four commands all shoot a weapon in the given direction:
A bullet, a missile, a seeker, or shooting fire, respectively.

>#COMMANDS.HLP:dir:Directions

:_t7:~ATRY [dir] "label"

This will have the Robot attempt to move in the given
direction. If it can, it will. If it can't, it will jump to the
given label.

>#COMMANDS.HLP:dir:Directions

:_b1:~ABECOME [color] [thing] [param]

The Robot will end its program permanently, and instead become
a specified object with a given color and parameter. 
NOTE: Becoming another Robot type will not destroy the program,
but there are far better commands for doing this: ~ABECOME~F
~APUSHABLE~F and ~ABECOME NONPUSHABLE~F.

>#COMMANDS.HLP:col:Colors
>#COMMAND2.HLP:_b3:BECOME NONPUSHABLE
>#COMMAND2.HLP:_b5:BECOME PUSHABLE

:_c2:~ACHANGE [color] [thing] [param] [color] [thing] [param]

All on-board objects of the first given type will become
objects of the second given type.

>#COMMANDS.HLP:col:Colors

:_pC:~APUT [color] [thing] [param] # #
:_pD:~APUT [color] [thing] [param] [dir]
:_pF:~APUT [color] [thing] [param] [dir] PLAYER

This will put a given object somewhere onscreen. The target
location can be given in one of three ways:

1. State the target {x,y} coordinates.
2. State the direction, relative to the Robot.
3. State the direction, relative to the player.

Note that this command is not suitable for placing Robots. For
moving a Robot, use ~AGOTOXY # #~F; for placing a copy of a Robot,
use ~ADUPLICATE SELF # #~F or ~ADUPLICATE SELF [dir]~F.

>#COMMANDS.HLP:col:Colors
>#COMMANDS.HLP:dir:Directions

:_m3:~AMOD "file"

This command loads the given module/OGG/WAV/SAM file as
background music. These files also can be loaded from a
subdirectory with the syntax of ""dir"\"file"" or 
""dir"/"file"" (without the inner quotes). The biggest
difference between MOD and SAM commands is that for a file
loaded with MOD one can use related commands like VOLUME and
MOD ORDER; the music loops as well. NOTE: placing * at the end
of the filename will set the current mod to the given filename,
but institute MOD "*" (see below) for subsequent board visits.

:_m8:~AMOD "*"

Sets the board's currently running music to "wildcard". This
means that it will continue to play whatever was last playing.
This setting does not "lock" the board's music to any one song;
for instance, if 1.mod was playing on the last board, mod "*"
will continue playing 1.mod, but if the player then goes to a
board playing 2.mod and jumps back to the mod "*" board from
there, 2.mod will continue playing, and 1.mod will not start.

>#SOUNDEFX.HLP:1st:Sound and Music
>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:_s1:~ASAM # "file"

Plays the given SAM/WAV/OGG/module file at a given frequency.
These files also can be loaded from a subdirectory with the
syntax of ""dir"\"file"" or ""dir"/"file"" (without the inner
quotes).0 plays the file at natural frequency. Music loaded
with the SAM command will not loop.

>#SOUNDEFX.HLP:1st:Sound and Music

:_e2:~AEND MOD
:_e4:~AEND SAM
:_e3:~AEND PLAY

Ends the playing of the current audio set by MOD "file",
the current audio set by SAM # "file", or the currently playing
PLAY statement (respectively).

>#SOUNDEFX.HLP:1st:Sound and Music

:_d8:~ADOUBLE "counter"
:_h1:~AHALF "counter"

Doubles or halves (rounding down) the value of the given
counter, respectively.

>#COUNTERS.HLP:1st:Counters, Built-in Counters and Local Counters

:_mC:~AMULTIPLY "counter" #
:_d7:~ADIVIDE "counter" #
:_m9:~AMODULO "counter" #

Multiplies, divides, or performs a modulo on the value of the
given counter by the given number (rounding down). To modulo is
to set to the remainder when dividing. Example: 7 modulo 3 is
equal to 1, since 7 divided by 3 gives a remainder of 1.

NOTE: The modulo command may output different numbers compared
to the modulo expression function; they may act differently
when negative numbers are involved. For the modulo command, the
output will give results similar to when both numbers are
positive, but will simply have the sign of the dividend (i.e. a
truncated modulo).

>#COUNTERS.HLP:1st:Counters, Built-in Counters and Local Counters

:_p2:~APLAY "string"
:_p3:~APLAY SFX "string"
:_w4:~AWAIT PLAY "string"

These all play sound effects, PC speaker notes, or a
combination thereof. PLAY SFX will only play if there are no
other notes currently playing, while PLAY will add its notes to
the end of the current sound effects queue. WAIT PLAY will wait
until the queue is almost empty before adding its notes.

>#SOUNDEFX.HLP:1st:Sound and Music

:_sO:~ASFX #

Plays the given built-in sound effect.

>#SOUNDEFX.HLP:1st:Sound and Music

:_eH:~AEXPLODE #

The Robot will explode, destroying it and its program forever.
The radius of the explosion is stated in the command, with a
maximum of 16.

:_cD:~ACOLOR FADE OUT
:_cE:~ACOLOR FADE IN

Fades the palette out to black or in to full color. Fading in
will not work if you haven't faded out, and fades affect
neither the current palette nor current intensities.

:_g8:~AGOTOXY # #

The Robot will go to the given {x,y} coordinates on the current
board, destroying anything there that cannot go on the under
layer. If the player is at those coordinates, the Robot ignores
the command.

:_lC:~ALOOP START
:_lB:~ALOOP #
:_a1:~AABORT LOOP

These three commands define a loop, which is a sequence of
commands to be repeated. LOOP START marks the start of a loop.
LOOP # will loop back to LOOP START the given number of times.
ABORT LOOP will jump out of the loop, to the command after LOOP
.#. The loop count is kept in the local counter "loopcount".
Make sure your number in LOOP # is one less than the amount for
which you actually want to loop, as the initial iteration
before first hitting LOOP # is not counted in the number.

NOTE: Using ABORT LOOP outside of the loop (that is, outside of
any block of code starting with LOOP START and ending in
LOOP #) is very highly unadvised and will most likely cause
unintended effects.

>#COUNTERS.HLP:1st:Counters, Built-in Counters and Local Counters

:_mA:~AMOVE PLAYER [dir]
:_mB:~AMOVE PLAYER [dir] "label"

The player attempts to move in the given direction. If the
player is blocked, and the command contains a label, the Robot
will jump to that label.

>#COMMANDS.HLP:dir:Directions

:_p0:~APLAYER CHAR [char]
:_p9:~APLAYER CHAR [dir] [char]

Changes the character (appearance) of the player. The second
form allows you to change the appearance of one of the four
facing directions at a time, while the first form changes all
four directions at once.

>#COMMANDS.HLP:dir:Directions

:_pA:~APLAYERCOLOR [color]

Changes the color of the player.

>#COMMANDS.HLP:col:Colors

:_pG:~APUT PLAYER # #
:_pH:~APUT PLAYER [dir]

The player will go to the given {x,y} coordinates or in the
given direction immediately relative to the Robot. If this is
impossible, the command is ignored.

>#COMMANDS.HLP:dir:Directions

:_pI:~APUT "@@FILENAME.XXX" Image_File [param] # #

Places an MZM of the given filename. These files also can be
loaded from a subdirectory with the syntax of ""dir"\"@@file""
or ""dir"/"@@file"" (without the inner quotes). The @@ is
REQUIRED. The numbers mark the destination {x,y} coordinates of
the MZM's upper-left corner; the parameter determines the
placement of the MZM (00 = board, 01 = overlay, 02 = vlayer).
See the MZM section for further details.

>#MZM.HLP:mzm:Using MZMs

:_pJ:~APUT [color] Sprite [param] # #

Puts a sprite on the board. The param number is the number of
the sprite in hex (auto-converted from decimal). If the color
is c?? then the sprite is drawn with its normal colors as seen
on the board; otherwise, it's painted with the given colors.
.# # marks the {x,y} coordinates of the sprite's upper-left
corner. See the Spites section for further details.

>#SPRITES.HLP:spr:Sprites

:_lA:~ALOCKSELF
:_u3:~AUNLOCKSELF

Locks or unlocks, respectively, the current Robot. When a Robot
is locked, no external messages will be acknowledged - Only
internal GOTOs, etc. will be processed. (Built-in label calls
to "thud" and "edge" are exceptions.)

:_v3:~AVOLUME #

Changes the volume of the MOD playing, from 0 (silent) to 255.

:_cM:~ACOPYROBOT "Robot"
:_cN:~ACOPYROBOT # #
:_cO:~ACOPYROBOT [dir]

The current Robot becomes an exact duplicate of the noted
Robot, starting from the beginning of the noted Robot's code.
Note that if the source Robot was previously ended with the END
command, or was at the end of its program, the destination
Robot will be in an ended state as well. The Robot to copy can
be stated in one of three ways:

1. State the target Robot's name.
2. State the {x,y} coordinates of target Robot.
3. State the direction of target Robot.

NOTE: Exact means just that - EXACT. If one requires an group
of objects differing only in name, COPYROBOT is unsuitable
for this purpose because even the Robot name is copied.

>#COMMANDS.HLP:dir:Directions

:_d9:~ADUPLICATE SELF # #
:_d0:~ADUPLICATE SELF [dir]

The current Robot creates an exact duplicate of itself 
(including local counter values!) and places it at the noted
{x,y} coordinates or relative direction. That Robot then begins
its program at the first command.

>#COMMANDS.HLP:dir:Directions

~EThe remaining Robotic commands are covered in another section.

>#COMMAND2.HLP:1st:Command Reference Part II
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#COMMAND2.HLP
:1st: 
$~9Command Reference Part II

>#COMMANDR.HLP:1st:Command Reference (Part I)

:_b9:~ABULLETCOLOR [color]

Changes the color of all bullets.

>#COMMANDS.HLP:col:Colors

:_p4:~APLAYER BULLETCOLOR [color]
:_e0:~AENEMY BULLETCOLOR [color]
:_n1:~ANEUTRAL BULLETCOLOR [color]

Changes the color of a specific type of bullet: Player, Enemy,
or Neutral (ricocheted/Robot) bullets.

>#COMMANDS.HLP:col:Colors
>#BULLETTY.HLP:1st:Bullet Types

:_bA:~ABULLETN [char]
:_bB:~ABULLETS [char]
:_b0:~ABULLETE [char]
:_bC:~ABULLETW [char]

Changes the character (appearance) of one of the four
directions of bullet, across all three types.

:_p6:~APLAYER BULLETN [char]
:_p7:~APLAYER BULLETS [char]
:_p5:~APLAYER BULLETE [char]
:_p8:~APLAYER BULLETW [char]
:_eA:~AENEMY BULLETE [char]
:_eB:~AENEMY BULLETN [char]
:_eC:~AENEMY BULLETS [char]
:_eD:~AENEMY BULLETW [char]
:_n3:~ANEUTRAL BULLETN [char]
:_n4:~ANEUTRAL BULLETS [char]
:_n2:~ANEUTRAL BULLETE [char]
:_n5:~ANEUTRAL BULLETW [char]

Changes the character of one of the four directions of bullet,
for one of the three types of bullet: Player, Enemy, or Neutral
(ricocheted/Robot) bullets, respectively.

>#BULLETTY.HLP:1st:Bullet Types

:_b5:~ABECOME PUSHABLE
:_b3:~ABECOME NONPUSHABLE

The Robot becomes a pushable or nonpushable Robot,
respectively.

:_i2:~AIF [condition] "label"
:_iB:~AIF NOT [condition] "label"

These test whether a given condition is present or not, and if
it is, the first will jump to the given label. If it isn't, the
second will jump to the given label. Conditions are covered in
another section.

>#COMMANDS.HLP:con:Conditions

:_i3:~AIF # # "label"

Jumps to the given label if the current Robot is at the {x,y}
coordinates given.

:_i4:~AIF [dir] PLAYER [color] [thing] [param] "label"

Jumps to the given label if the given thing is the given
direction relative to the player.

>#COMMANDS.HLP:col:Colors
>#COMMANDS.HLP:dir:Directions

:_i5:~AIF [color] [thing] [param] # # "label"
:_i6:~AIF [color] [thing] [param] [dir] "label"
:_iA:~AIF NOT [color] [thing] [param] [dir] "label"

Jumps to a label if a given thing is at the given {x,y}
coordinates or to the immediate given direction of the current
Robot. The third form jumps if the thing is NOT in the 
immediate given direction.

>#COMMANDS.HLP:col:Colors
>#COMMANDS.HLP:dir:Directions

:_i7:~AIF ALIGNEDROBOT "Robot" "label"

Jump to the given label if the current Robot is aligned either
vertically or horizontally with the named Robot.

:_i8:~AIF ANY [color] [thing] [param] "label"
:_i0:~AIF NO [color] [thing] [param] "label"

If there are ANY of a given thing on the current board, jumps
to the given label. The second form triggers on the absence of
the given thing.

>#COMMANDS.HLP:col:Colors

:_iC:~AIF PLAYER # # "label"

If the player is at the given {x,y} coordinates, jump to the
given label.

:_g2:~AGIVEKEY [color]
:_g3:~AGIVEKEY [color] "label"
:_t3:~ATAKEKEY [color]
:_t4:~ATAKEKEY [color] "label"

Attempts to give keys to or take keys from the player. The
forms without labels will give or take the key if possible,
otherwise they will do nothing. The forms with labels will jump
to the labels if the Robot tries to give a key when the player
has no room for keys, or if the Robot tries to take a key the
player doesn't have.

>#COMMANDS.HLP:col:Colors

:_g1:~AGIVE # [item]
:_t1:~ATAKE # [item]
:_t2:~ATAKE # [item] "label"

Gives or takes a number of a certain item. The third form jumps
to a label if the player doesn't have enough of the stated
item.

:_t6:~ATRADE # [item] # [item] "label"

Gives the player a number of the first item and takes a number
of the second item in exchange. If the player doesn't have
enough of the second item, jumps to label and has no other
effect. This command eases the writing of simple shops and
vendors.

:_l6:~ALOCKPLAYER
:_l9:~ALOCKPLAYER NS
:_l8:~ALOCKPLAYER EW
:_l7:~ALOCKPLAYER ATTACK
:_u1:~AUNLOCKPLAYER

The first four commands lock the player, preventing the player
from doing any moving and attacking (i.e. default shooting and
bombing), from moving north or south, from moving east or west,
or from attacking, respectively. The fifth command will clear
all locks on the player, allowing free movement and attacking.
These have no relation to the Board Info options "Can Bomb" and
"Can Shoot". Player locking is local, only affecting the
current board.

Also, locking the player will not cause the relevant input to
be ignored completely. MegaZeux will still detect that you are
pressing keys, even if the Player is forbidden from responding
to them, and will act accordingly. In short, even if a player
is locked, Robots that take directional and space/delete inputs
will still act the same.

:_b7:~ABOARD [dir] "string"
:_b8:~ABOARD [dir] NONE

Changes the board exit in the given direction to lead to the
given board or to nowhere.

>#COMMANDS.HLP:dir:Directions
>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:_z1:~AZAP "label" #
:_rA:~ARESTORE "label" #
:__0:~A| "label"

ZAP will scan the Robotic program from the top down, changing
a given number of instances of the stated label to ZAPPED
labels. A ZAPPED label is inactive - it cannot be jumped to or
sent to under any circumstance. This has two uses: It will
prevent interference from a certain outside event, and it
allows multiple instances of the same label. For example, you
could have four SHOT labels in a row, ZAP one each time the
Robot was shot, and jump back to normal code, but have a fifth
SHOT label lead to an explosion.

RESTORE will scan the Robotic program from the bottom up,
changing a given number of the stated ZAPPED labels back to a
normal label. Both ZAP and RESTORE can have a number larger
than the number of instances of the stated label. The final
command, |, is a pre-ZAPPED label, allowing you to have labels
in your Robotic programs that are already ZAPPED and inactive.

:pre:~AREL COUNTERS
:_r2:~AREL PLAYER
:_r3:~AREL SELF

These are special types of commands, called PREFIXES. Prefixes
don't do a thing by themselves, but when placed before another
command that uses {x,y} coordinates, they change the origin of
the {x,y} coordinate system for that ONE following command. REL
COUNTERS moves the origin to the {x,y} location stated in the
counters XPOS and YPOS. REL PLAYER moves the origin to the
{x,y} of the player. REL SELF moves the origin to the {x,y} of
the current Robot.

The movement of the origin changes the {0,0} coordinates from
the upper left of the board to somewhere else, effectively
adding that {x,y} position to any coordinates entered. For 
example, if the Robot is at the {5,5} position and uses REL
SELF on the coordinates {2,2}, it will effectively act on
coordinates {7,7}. If the player is at the {7,2} position and a
Robot uses REL PLAYER on coordinates {-3, 6}, the Robot will
effectively act on coordinates {4,8}.

Let's look at some examples.

~EPUT c0E GEM p?? 5 5

This places a gem at the {x,y} coordinates {5,5}.

~EREL PLAYER
~EPUT c0E GEM p?? 5 5

This places a gem 5 spaces to the right and 5 spaces below
where the player currently is.

~EREL SELF
~EPUT c0E GEM p?? -2 -3

This places a gem 2 spaces to the left and 3 spaces above
where this Robot currently is.

~EREL COUNTERS
~EPUT c0E GEM p?? 1 -4

This places a gem at the coordinates {XPOS+1,YPOS-4}.

Prefixes only have an effect on the very next command.

Prefixes also affect two other things. The built in counters
THISX and THISY will be offset by a prefix, and the command
IF [dir] BLOCKED will check next to the player or next to the
position noted by the counters, if a prefix is present. See
these for details.

:_r4:~AREL COUNTERS FIRST
:_r5:~AREL PLAYER FIRST
:_r6:~AREL SELF FIRST
:_r7:~AREL COUNTERS LAST
:_r8:~AREL PLAYER LAST
:_r9:~AREL SELF LAST

These prefixes are similar to the above prefixes, but they only
affect the first or last {x,y} coordinates in the next command.
For example, COPY accepts two pairs of coordinates. If you
precede it with the following:

REL PLAYER FIRST
REL SELF LAST

Then the x-coordinate will be relative to the player, and the
y-coordinate will be relative to the Robot. There is one other
difference with these commands - REL COUNTERS FIRST works off
of the counters FIRSTXPOS and FIRSTYPOS, and  REL COUNTERS LAST
works off of the counters LASTXPOS and LASTYPOS.

NOTE: Using REL COUNTERS on COPY commands, instead of its 
first/last versions, will still force FIRSTXPOS/FIRSTYPOS and
LASTXPOS/LASTYPOS to be used, instead of basing both coordinate
pairs off of XPOS and YPOS.

:_j1:~AJUMP MOD ORDER #

The current module jumps to the stated module order, if
applicable. For example, JUMP MOD ORDER 3 will begin playing
the third order in the module, which is the fourth section of
the module. Sometimes your music editor will refer to this as
the 'Pattern' or 'Track'.
With OGG music and/or WAVs, this command makes a jump to the
stated frame.

>#SOUNDEFX.HLP:1st:Sound and Music

:_l1:~ALAYBOMB [dir]
:_l2:~ALAYBOMB HIGH [dir]

Places a bomb (high strength for the second form) next to the
Robot in the given direction. Use a direction of UNDER or
BENEATH to place the bomb underneath the Robot.

>#COMMANDS.HLP:dir:Directions

:_l3:~ALAZERWALL [dir] #

The Robot shoots a lazer in the given direction, and the lazer
has the color of the Robot and the duration given.

>#COMMANDS.HLP:dir:Directions

:_cH:~ACOPY # # # #
:_cI:~ACOPY [dir] [dir]
:_sW:~ASWITCH [dir] [dir]

Copies the thing at one location to another, with the location
stated through {x,y} coordinates or directions relative to the
current Robot. The third command will swap the things in the
two directions.

COPY can copy between different layers by using the appropriate
prefixes. Prefix coordinate numbers with "+" to indicate
overlay coordinates, and with "#" to indicate vlayer
coordinates.

NOTE: DO NOT normally use COPY # # # # to copy Robots; use
DUPLICATE SELF or COPYROBOT. It is useful for copying by Robot
id, however; use COPY r&id&.thisx and r&id&.thisy as the first
pair of coordinates.

Using COPY # # # # on a Robot will no longer cause the Robot
copy to start where the parent left off.

>#BADPRACT.HLP:101:Robotic Usages That Should be Avoided
>#COMMANDS.HLP:dir:Directions

:_cJ:~ACOPY BLOCK # # # # # #
:_cL:~ACOPY OVERLAY BLOCK # # # # # #

Copies a block of things from one location on the board or
overlay to another section. The first two numbers state the
upper-left corner of the block to be copied, the second two
numbers state the size of the block, and the third two numbers
state the destination block's upper-left corner.

COPY BLOCK and COPY OVERLAY BLOCK can copy from board to
overlay and from overlay to board (respectively). The last two
numbers must be prefixed by plus signs, like so:

COPY BLOCK # # # # "+#" "+#"
COPY OVERLAY BLOCK # # # # "+#" "+#"

>#TOVERLAY.HLP:081:Editing and Using the Overlay

:_cW:COPY BLOCK # # # # "#x" "#y"
:_cX:COPY OVERLAY BLOCK # # # # "#x" "#y"

These commands copy from the board or overlay (respectively) to
the vlayer. The first two numbers are the {x,y} coordinates of
the upper-left corner of the block to be copied; the next two
numbers are the respective width and height of the block; the
"#x" and "#y" are the {x,y} coordinates of the destination
block's upper-left corner. The pound sign in "#x" and "#y" MUST
be included.

:_cY:COPY BLOCK "#x" "#y" # # # #
:_cZ:COPY OVERLAY BLOCK "#x" "#y" # # # #

These commands similarly copy from the vlayer to the board or
overlay (respectively).

>#TOVERLAY.HLP:081:Editing and Using the Overlay
>#VLAYER.HLP:vla:The Vlayer and Its Uses

:_cAA:COPY (OVERLAY) BLOCK "#x1" "#y1" # # "#x2" "#y2"

This command copies a block from the vlayer and copies it onto
a different spot on the vlayer. "#x1" and "#y1" are the {x,y}
coordinates of the upper-left corner of the copied block; the
next two numbers are the respective width and height of the
copied area; "#x2" and "#y2" are the {x,y} coordinates of the
destination block's upper-left corner. The pound sign in #x1",
"#y1", "#x2" and "#y2" MUST be included.

>#VLAYER.HLP:vla:The Vlayer and Its Uses

:_cQ:~ACOPY BLOCK # # # # "@@filename" #
:_cR:~ACOPY OVERLAY BLOCK # # # # "@@filename" #

These commands copy from the board or overlay (respectively)
to an MZM. The first two numbers are the {x,y} coordinates of
the block's upper-left corner; # # is the respective width and
height of the block; filename is the name of the file - the @@
is required. Finally, the last number determines the MZM type.
1 saves as layer; 0 saves as board. 0 is integral for copying
non-graphical data (primarily Robots); 1 is proper for copying
graphical data, as the block's appearance will stay as exactly
as it was when saved.

>#MZM.HLP:mzm:Using MZMs
>#TOVERLAY.HLP:081:Editing and Using the Overlay

:_cS:~ACOPY (OVERLAY) BLOCK "#x" "#y" # # "@@filename" #

These commands act much like the above two commands, but they
copy from the vlayer to an MZM instead.

>#MZM.HLP:mzm:Using MZMs
>#VLAYER.HLP:vla:The Vlayer and Its Uses

:_cT:~ACOPY BLOCK # # # # "$string" #
:_cU:~ACOPY OVERLAY BLOCK # # # # "$string" #
:_cV:~ACOPY (OVERLAY) BLOCK "#x" "#y" # # "$string" #

These commands copy information from the board, overlay, or
vlayer (respectively) to a given string. The first two numbers
are the {x,y} coordinates of the upper-left corner of the
block; the third and fourth are its respective width and
height; the last is the terminating character's char value
(i.e. a number from 0-255). The operation will end before all
characters in the given range are read if either the parameter
matching the terminating character, or a parameter of p00, is
found. For the vlayer command, the pound sign is REQUIRED.

>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic
>#TOVERLAY.HLP:081:Editing and Using the Overlay

:_s2:~ASAVE PLAYER POSITION
:_s3:~ASAVE PLAYER POSITION #

Saves the player's coordinates and board in one of eight
internal slots. If no number is given, slot one is used.

:_rB:~ARESTORE PLAYER POSITION
:_rC:~ARESTORE PLAYER POSITION #
:_rD:~ARESTORE PLAYER POSITION # DUPLICATE SELF

Relocates the player to the coordinates and board stored in
the given slot, or slot number one if none is given. The third
form also duplicates the current Robot where the player used to
be; this Robot then starts its program at the first command.

:_eE:~AEXCHANGE PLAYER POSITION
:_eF:~AEXCHANGE PLAYER POSITION #
:_eG:~AEXCHANGE PLAYER POSITION # DUPLICATE SELF

Exchanges the player's current coordinates and board with the
coordinates and board stored in the given slot, or slot number
one if none is given. The third form also duplicates the
current Robot where the player used to be; this Robot then
starts its program at the first command.

:_f2:~AFILLHEALTH

The player's health is filled to its maximum.

:_cA:~ACLEAR MESG

The message row, if currently displayed, disappears.

:_m1:~AMESSAGE ROW #

The message row is moved to the stated row, from 0 to 24.

:_sN:~ASET MESG COLUMN #

The message is displayed at the given column, from 0 to 79.

:_c1:~ACENTER MESG

The message is centered on its row instead of being shown at a
constant column. (see above)

:_l4:~ALOAD CHAR SET "file"
:_l5:~ALOAD PALETTE "file"

Loads in the specified character set or palette, exported using
Alt+X from the world editor. The new character set or palette
is permanent and affects the entire world until a new one is
loaded. These files also can be loaded from a subdirectory with
the syntax of ""dir"\"file"" or  ""dir"/"file"" (without the
inner quotes).

Character sets can be loaded to the middle of the current
charset by prefixing the "file" name with +offset, where offset
is a hexadecimal number, or @@offset where offset is a decimal
number.

>#PARTIAL.HLP:par:Partial Character Sets
>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:_t5:~ATELEPORT PLAYER "string" # #

Teleports the player to the given board at the stated {x,y}
coordinates.

>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:_c4:~ACHANGE OVERLAY [color] [char] [color] [char]
:_c5:~ACHANGE OVERLAY [color] [color]

All of the stated character and color on the overlay are
changed to the new character and color. The second form doesn't
care about the character, only the color.

>#COMMANDS.HLP:col:Colors
>#TOVERLAY.HLP:081:Editing and Using the Overlay

:_m0:~AMOVE ALL [color] [thing] [param] [dir]

All of the stated thing are moved in the given direction.

>#COMMANDS.HLP:col:Colors
>#COMMANDS.HLP:dir:Directions

:_o1:~AOPEN [dir]

If there is a gate or door in the given direction, it will
be opened. If the door is going to open towards the Robot, the
Robot will be pushed out of the way if necessary. It is
suggested to wait a couple cycles before then continuing on
through the door. (Gates aren't a problem.)

>#COMMANDS.HLP:dir:Directions

:_m7:~AMOD SAM # #

Plays a sample (instrument) from the current module file. The
first number states the frequency at which to play it; the
second is the number of the sample, from 1 on.

>#SOUNDEFX.HLP:1st:Sound and Music

:_l0:~ALOCKSCROLL
:_u2:~AUNLOCKSCROLL

Locks or unlocks scrolling on the current board. When scrolling
is locked, the view will remain showing the same thing, even if
the player moves. The screen will not scroll.

:_c0:~ACHAR EDIT [char] # # # # # # # # # # # # # #

Changes the appearance of the given character, using a 
14-number code from the character editor. To insert these codes
easily, use F5 in the Robot editor, select the desired
character, and press ESC.

:_m5:~AMOD FADE IN "file"

Fades in the stated module/OGG/WAV music file, from 0 volume to
255 volume. These files also can be loaded from a subdirectory
with the syntax of ""dir"\"file"" or ""dir"/"file"" (without
the inner quotes).

>#SOUNDEFX.HLP:1st:Sound and Music
>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:_m6:~AMOD FADE OUT

Fades out the current module/OGG/WAV music file, from the
current volume to 0 volume.

>#SOUNDEFX.HLP:1st:Sound and Music

:_m4:~AMOD FADE # #

Fades the current module/OGG/WAV music file to a given volume
at the given rate. The first number is the target volume, the
second number is the speed at which to fade. All negative
numbers and numbers over 255 will wrap around.

>#SOUNDEFX.HLP:1st:Sound and Music

:_m2:~AMISSILECOLOR [color]

Changes the color of all missiles fired from that point on.

>#COMMANDS.HLP:col:Colors

:_pB:~APUSH [dir]

Pushes anything in the given direction one space forward, if
the object in that direction is pushable. The Robot itself does
not move.

>#COMMANDS.HLP:dir:Directions

:_sL:~ASET EDGE COLOR [color]

Changes the color of the edging shown around the viewport.

>#COMMANDS.HLP:col:Colors

:_sM:~ASET MAXHEALTH #

Changes the player's health limit, or maximum health rating.

:_w2:~AWAIT MOD FADE

Waits for the module/OGG/WAV music to finish its fading. (see
MOD FADE IN, MOD FADE OUT, and MOD FADE)

>#SOUNDEFX.HLP:1st:Sound and Music
>#COMMAND2.HLP:_m5:~AMOD FADE IN "file"
>#COMMAND2.HLP:_m6:~AMOD FADE OUT
>#COMMAND2.HLP:_m4:~AMOD FADE # #

:_w3:~AWAIT PLAY

Waits for all queued sound effects to finish playing.

>#SOUNDEFX.HLP:1st:Sound and Music

:_a2:~AASK "string"

Brings up a dialog box asking the player a question. The player
can select YES or NO. The Robot is then sent to either the YES
or NO label, depending on the choice. If the player presses
ESC, the NO label is used.

>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:_a3:~AAVALANCHE

Enacts the potion/ring effect, Avalanche, placing boulders
randomly about the board. Often precedes the CHANGE c?? Boulder
p?? to c?? Explosion p?? command.

>#BUILTINS.HLP:prx:Potion and Ring Effects

:_b4:~ABECOME LAVAWALKER
:_b2:~ABECOME NONLAVAWALKER

The current Robot can or cannot move on lava now. Robots can
always move over fire.

:_b6:~ABLIND #
:_f1:~AFIREWALKER #
:_f4:~AFREEZETIME #
:_sS:~ASLOWTIME #
:_w6:~AWIND #

The stated potion/ring effect is now active for the given
number of cycles. Potion/ring effects are global; that is, they
affect the entire world. The only exception is the global
Robot; FREEZETIME and SLOWTIME commands do not affect it.

>#THEGLOBL.HLP:gbl:The Global
>#BUILTINS.HLP:prx:Potion and Ring Effects

:_c3:~ACHANGE CHAR ID # [char]

Changes the character/color/number at the stated (numeric)
location within the CHAR ID table. The CHAR ID table is
internal and is covered in another section.

>#CHANGECH.HLP:1st:CHANGE CHAR ID - The CHAR ID Table

:_c6:~ACHANGE SFX # "string"

The sound effect referenced by the given number is changed to
the new string. The numbers refer to the sound events editable
through ALT+F.

>#SOUNDEFX.HLP:1st:Sound and Music

:_c8:~ACHANGE THIN ARROW CHAR [dir] [char]
:_c7:~ACHANGE THICK ARROW CHAR [dir] [char]

Changes the character used to represent thin arrows (for guns)
or thick arrows (for pushers and spikes) for the specified
direction.

>#COMMANDS.HLP:dir:Directions

:_iP:~AINPUT STRING "string"

Asks the player to input a string, using the given string as
a prompt, or question. The inputted string is stored in memory.
This string can be displayed within box messages or on the
message row by using &INPUT& within a message. Inputted strings
are local to the current board.

>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:_iD:~AIF STRING "string" "label"
:_iF:~AIF STRING NOT "string" "label"

Jumps to the given label if the inputted string is or is not
equal to the given string. Case is ignored.

:_iE:~AIF STRING MATCHES "string" "label"

If the string matches a given pattern, jump to the given label.
(Case is ignored.) The pattern is a series of characters and
symbols to match. Characters must match exactly. The following
symbols apply:

.# matches any number from 0-9
_ matches any letter from A-Z or a-z
? matches any character
* matches the remainder of the input string

:_i9:~AIF FIRST STRING "string" "label"

If the first word in the inputted string matches the given
string, jump to the given label.

:_cB:~ACLIP INPUT

This command chops off the first word of the inputted string
(everything before and including the first instance of a
space, aka char 32). For example, "Hello there" will now read
in memory as "there".

:_iM:~AINC "$string" "text"
:_iN:~AINC "$string" "$string2"

This command appends the given text or string to the end of a
given string.

:_dA:~ADEC "$string" #

This command clips the given string by the amount of characters
given. Decreasing negative numbers will not add characters to
the string.

:_iO:~AIF "$string" (equality) # "label"
:_iK:~AIF "$string" (equality) "text" "label"
:_iL:~AIF "$string" (equality) "$string2" "label"

These commands jump to a given label if the string matches the
given equality conditions (ONLY equal or not equal; others such
as less than are automatically parsed as FALSE). These commands
compare the given string to a number, a line of text, or
another string respectively.

:_iG:~AIF c?? Sprite_Colliding pNN x y "label"

This command determines whether the sprite numbered NN is
colliding at the location [x, y]; if it is, the program goes to
the given label.

:_iH:~AIF c?? Sprite pNN x y "label"

This command checks if the sprite numbered NN is currently at
the location [x, y]; if it is, the program goes to the given
label.

:_cF:~ACOLOR INTENSITY # PERCENT
:_cG:~ACOLOR INTENSITY # # PERCENT

The first command changes the intensity of the entire palette
from 0 to 255 percent (100 percent is a palette's default). The
second command only changes one color, stated by number.

:_cK:~ACOPY CHAR [char] [char]

The character picture of the first character is copied to the
second character.

:_d5:~ADISABLE MESG EDGE
:_e7:~AENABLE MESG EDGE

Disables or enables the edging on the message row. When
enabled, all messages have a space (char 32) tacked onto each
end for display clarity. This is enabled by default.

:_d6:~ADISABLE SAVING
:_e8:~AENABLE SAVING
:_e9:~AENABLE SENSORONLY SAVING

Disables or enables saving on this board, or enables saving on
Sensors only.

>#SENSORSW.HLP:094:Sensors

:_f3:~AFLIP CHAR [char] [dir]

The character picture of the stated character is flipped
vertically if the direction is north/south, or horizontally if
the direction is east/west.

>#COMMANDS.HLP:dir:Directions

:_o2:~AOVERLAY ON
:_o3:~AOVERLAY STATIC
:_o4:~AOVERLAY TRANSPARENT

Turns the overlay on (to normal mode), to static mode, or to
transparent mode.

>#TOVERLAY.HLP:081:Editing and Using the Overlay

:_rE:~AROTATECW
:_rF:~AROTATECCW

Rotates all pushable items around the Robot in a clockwise or
counter-clockwise direction, respectively. This is done in the
same manner as a CW Rotate or CCW Rotate object.

:_s4:~ASCROLL CHAR [char] [dir]

The character picture of the stated character is scrolled one
pixel in the given direction, with wraparound in effect.

>#COMMANDS.HLP:dir:Directions

:_s5:~ASCROLLARROW COLOR [color]
:_s6:~ASCROLLBASE COLOR [color]
:_s7:~ASCROLLCORNER COLOR [color]
:_s8:~ASCROLLPOINTER COLOR [color]
:_s9:~ASCROLLTITLE COLOR [color]

Changes the color used to represent a specific element of the
Scroll and box-message system:

ARROW   = The arrows used to denote options
BASE    = The overall box and text color
CORNER  = The color of the corners of the box, and of the
          options in the option box at the bottom
POINTER = The color of the pointers on the left and right
TITLE   = The color of the Scroll/box title

>#COMMANDS.HLP:col:Colors

:_s0:~ASCROLLVIEW [dir] #
:_sA:~ASCROLLVIEW POSITION # #
:_r0:~ARESETVIEW

The first two commands scroll the current view a number of
spaces in one direction or until the given coordinates are in
the upper-left corner. RESETVIEW resets the view to normal,
showing the player in the center of the screen when possible.

>#COMMANDS.HLP:dir:Directions

:_sK:~ASET COLOR # # # #

The given color (stated by the first number) is changed to the
RGB values of the next three numbers. The RGB values must range
from 0 to 63. These are the same numbers shown in the palette
editor.

:_sU:~ASTATUS COUNTER # "counter"

The status screen counter stated is changed to the given
counter. The numbers of the counters range from 1 to 6.

>#COUNTERS.HLP:1st:Counters, Built-in Counters and Local Counters

:_sV:~ASWAP WORLD "file"

Transfers play to the first board in the stated world file.
All counters, items, keys, etc. are retained from the current
world. The target file can be the same world that is currently
running.

>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

:_pE:~APUT [color] [char] OVERLAY # #
:_w7:~AWRITE OVERLAY [color] "string" # #

Puts the given color/character at the given coordinates on the
overlay, or writes a message in the given color starting at the
given coordinates on the overlay.

>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic
>#TOVERLAY.HLP:081:Editing and Using the Overlay
>#COMMANDS.HLP:col:Colors

:_v1:~AVIEWPORT # #

Moves the viewport's upper-left corner to the given screen
coordinates. X ranges from 0 to 79, and Y ranges from 0 to 24.

:_v2:~AVIEWPORT SIZE # #

Changes the size of the viewport. X size must be from 1 to 80,
and Y size must be from 1 to 25.

>#COMMANDR.HLP:1st:Command Reference (Part I)
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#BULLETTY.HLP
:1st: 
$~9Bullet Types

There are three different types of bullets in MegaZeux: Player,
Enemy, and Neutral. The player shoots Player bullets, enemies
shoot Enemy bullets, and ricocheted bullets become Neutral
bullets. A Robot can shoot any type of bullet, according to its
BULLETTYPE counter, but it defaults to Neutral bullets. All
Enemy bullets, even those shot from Robots, become Neutral
bullets when the option "Enemies' bullets can hurt enemies" is
set.

Player bullets can only hurt enemies. Enemy bullets can only
hurt the player. Neutral bullets can hurt either. Robots go to
different labels when shot with each one, or to a generic SHOT
label if there are none of the specific PLAYERSHOT, ENEMYSHOT,
or NEUTRALSHOT labels.

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#CHANGECH.HLP
:1st: 
$~9CHANGE CHAR ID - The CHAR ID Table

The CHAR ID table has many uses. The first area of usage - the
CHANGE CHAR ID # [char] command - basically changes the value
(a character, color, or number) of a given type of item. These
values correspond to the Global Chars or Damage tables from
Global Info. The first number in the command states what is to
change. (Note - if noted, the number corresponds to a color or
damage. Otherwise, it is a character.) These numbers are also
listed next to things in the Global Edit Chars menus.

The second area - using the BOARD_ID, BIDx,y or UIDx,y counters
- will change an actual item instead of that entry's value;
i.e. these counters transform the actual item (and ONLY that
item) at a specific pair of coordinates from one type to
another.

WARNING: Changing certain CHAR ID values will have decidedly
special effects:

~A*~FChanging the value of any Custom type will turn ALL of that
type into the given character; same with text.
~A*~FThere is a special exception to this, though. If the value is
(char) 255, then all items of that type act like Custom objects
and assume a character based on their parameter (e.g. p01
objects will use character 1). This can allow built-ins of the
same type that display different characters in-game at the same
time.
~A*~FChanging the CHAR IDs of objects with animations or four
directional characters will fix ALL animations/chars of that
object type to the given character.
~A*~FIt is inadvisable to use any UNUSED values.
~A*~FUsing CHAR ID to change between actual items only works
with values <122. For example, changing something into Ice by
setting BOARD_ID to 160 will not work, but setting BOARD_ID to
25 will. However, there is no such restriction with changing
CHAR ID table values using CHANGE CHAR ID.
~A*~FDamage values start at 327. Not all values are listed, because
technically you can assign damage values for things that cannot
give damage (i.e. pretty much everything not listed in the
table). If you really want to manipulate damage values for such
items, to find the CHAR ID number for an item, just add 327 to
it.

Number  Changes
------  -------
0       Space
1       Normal
2       Solid
3       Tree
4       Line
5       Custom Block
6       Breakaway
7       Custom Break
8       Boulder
9       Crate
10      Custom Push
11      Box
12      Custom Box
13      Fake
14      Carpet
15      Floor
16      Tiles
17      Custom Floor
18      Web
19      Thick Web
20      Still Water
21      N Water
22      S Water
23      E Water
24      W Water
25      Ice
26      Lava
27      Chest
28      Gem
29      Magic Gem
30      Health
31      Ring
32      Potion
33      Energizer
34      Goop
35      Ammo
36      Bomb
37      Lit Bomb
38      Explosion
39      Key
40      Lock
41      Door
42      Open Door
43      Stairs
44      Cave
45      CW Rotate
46      CCW Rotate
47      Gate
48      Open Gate
49      Transport
50      Coin
51      N Moving Wall
52      S Moving Wall
53      E Moving Wall
54      W Moving Wall
55      Pouch
56      Pusher
57      Slider NS
58      Slider EW
59      Lazer
60      Lazer Gun
61      Bullet
62      Missile
63      Fire
64      UNUSED
65      Forest
66      Life
67-70   Whirlpool Anim 1-4
71      Invis Wall
72      Ricochet Panel
73      Ricochet
74      Mine
75      Spike
76      Custom Hurt
77      Text
78      Shooting Fire
79      Seeker
80      Snake
81      Eye
82      Thief
83      Slimeblob
84      Runner
85      Ghost
86      Dragon
87      Fish
88      Shark
89      Spider
90      Goblin
91      Spitting Tiger
92      Bullet Gun
93      Spinning Gun
94      Bear
95      Bear Cub
96      UNUSED
97      Missile Gun
98      Sprite
99      Sprite Collision
100     Image File
101-121 UNUSED
122     Sensor
123     Pushable Robot
124     Robot
125     Sign
126     Scroll
127     Player
128-143 Thin Lines (Web) (see below)
144-159 Thick Lines (Thick Web, Lines) (see below)
160     Ice
161-163 Ice Anim 1-3
164-166 Lava Anim 1-3
167     Small Ammo (below 10)
168     Large Ammo (above or equal to 10)
169-175 Lit Bomb Anim 1-7
176-183 Energizer Color Anim 1-8
184-187 Explosion Colors 1-4
188     Horizontal Door
189     Vertical Door
190-193 CW Rotate Anim 1-4
194-197 CCW Rotate Anim 1-4
198-229 UNUSED
230-233 Transport N Anim 1-4
234-237 Transport S Anim 1-4
238-241 Transport E Anim 1-4
242-245 Transport W Anim 1-4
246-249 Transport All-Dir Anim 1-4
250     Thick Arrow N (Pusher/Spike)
251     Thick Arrow S (Pusher/Spike)
252     Thick Arrow E (Pusher/Spike)
253     Thick Arrow W (Pusher/Spike)
254     Thin Arrow N (Guns)
255     Thin Arrow S (Guns)
256     Thin Arrow E (Guns)
257     Thin Arrow W (Guns)
258-261 Horizontal Lazer Anim 1-4
262-265 Vertical Lazer Anim 1-4
266-271 Fire Anim 1-6
272-277 Fire Color Anim 1-6
278-281 Life Anim 1-4
282-285 Life Color Anim 1-4
286     Ricochet Panel \
287     Ricochet Panel /
288-289 Mine Anim 1-2
290-291 Shooting Fire Anim 1-2
292-293 Shooting Fire Color Anim 1-2
294-297 Seeker Anim 1-4
298-301 Seeker Color Anim 1-4
302-305 Whirlpool Color Anim 1-4
306-309 Player Bullets, NSEW
310-313 Neutral Bullets, NSEW
314-317 Enemy Bullets, NSEW
318-321 Player, NSEW
322     Player Color
323     Missile Color
324     Player Bullet Color
325     Neutral Bullet Color
326     Enemy Bullet Color
353     Lava Damage
365     Explosion Damage
386     Lazer Damage
388     Bullet Damage
389     Missile Damage
390     Fire Damage
402     Spike Damage
403     Custom Hurt Damage
405     Shooting Fire Damage
406     Seeker Damage
407     Snake Damage
410     Slimeblob Damage
411     Runner Damage
412     Ghost Damage
413     Dragon Damage
414     Fish Damage
415     Shark Damage
416     Spider Damage
417     Goblin Damage
418     Spitting Tiger Damage
421     Bear Damage
422     Bear Cub Damage

To change a character, use the following form:

~ACHANGE CHAR ID # [char]~F

.# is the number corresponding to the character that you want to
change, or a counter representing that number. [char] is the
character (or counter representing the character) that you wish
to change it to.

To change a color, use the following form:

~ACHANGE CHAR ID # [color]~F

.# is the same as above, but corresponding to a color. [color]
is the color or a counter representing the color that you wish
to change it to.

To change damage values, use a number or counter in place of
the [char] or [color].

After typing in a [color] or damage value, it may change to a
character representation, but the value will still remain the
same.

To change line characters:

Take the base number for the type of line you wish to change
(128 for thin, 144 for thick) and add one of the following
values to represent which sides are connected via other web or
lines:

0  -
1  N
2  S
3  N S
4  E
5  E N
6  E S
7  E N S
8  W
9  W N
10 W S
11 W N S
12 W E
13 W E N
14 W E S
15 W E N S

>#COMMAND2.HLP:_c3:CHANGE CHAR ID # [char]
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#BUILTINL.HLP
:1st: 
$~9Built-in Labels

Robotic has many built-in labels (messages) that are activated
on certain external events. Each label, and what triggers it,
is listed below.

Subroutine versions of most labels exist. If a built-in label
has a subroutine version, [#] will be listed to the right of
its name. If both forms exist, they will both be triggered,
with the subroutine version being triggered first, and the
normal version triggered as the subroutine is left.

Special care is required when dealing with built-in subroutine
labels; to prevent abuse of the stack, using LOCKPLAYER and/or
ZAP to keep subroutine calls to an absolute minimum is highly
advised. Subroutines themselves are explained in another
section.

>#SUBROUTE.HLP:sub:Subroutines

~ETOUCH [#]

This is sent when the player touches the Robot, that is, when
the player stands next to it and presses an arrow key towards
it.

~ETHUD [#]

This is sent when the Robot is walking and it runs into a wall.
This label is not sent when the wall is hit during the ~EGO [dir]~F
~E#~F or the ~E/ "string"~F commands. THUD ignores LOCKSELF.

>#COMMANDR.HLP:_w5:WALK [dir]

~EEDGE [#]

This is sent when the Robot is walking and it runs into the
edge of the board. If EDGE is not found, the Robot is sent to
THUD. This label is not sent when the edge of the board is hit
during the ~EGO [dir] #~F or the ~E/ "string"~F commands. EDGE
ignores LOCKSELF.

>#COMMANDR.HLP:_w5:WALK [dir]

~EBOMBED [#]

This is sent when the Robot is hit with an explosion.

~EKEY? [#]

This is sent when the player presses the given key. ? should be
replaced with the key to be scanned for. Characters a to z, 0
to 9, and space (for the spacebar) work as expected. Shifted
characters will NOT work, and will actually scan as their
non-shifted counterparts. Any other character that can be
outputted directly, such as ";" or "*" or "=", will work. Other
characters can be entered by pressing F3 and selecting them
from the grid, but they are usually not guaranteed to work.
Some special-case characters that can work with KEY? are
character 8 (BackSpace), character 9 (Tab), and character 13
(Enter, though there's a better counter just for this mentioned
in the very next entry).

There is another way to scan for key presses - using counters.
They are called KEY_PRESSED, KEY, and KEYCODE, and are detailed
in the Miscellaneous Counters section of the help file.

>#COUNTERS.HLP:msc:Miscellaneous Counters

~EKEYENTER [#]

This is sent when the player presses the Enter key.

~EINVINCO [#]

This is sent when the player grabs an energizer.

~EPUSHED [#]

This is sent when a pushable Robot is pushed by something other
than the player.

~EENEMYSHOT [#]
~EPLAYERSHOT [#]
~ENEUTRALSHOT [#]

One of these is sent when the Robot is shot, correlating to the
type of bullet used. If the appropriate label is not found, the
Robot is sent to SHOT instead.

~ESHOT [#]

This is sent when the Robot is shot by a bullet and the more
specific label cannot be found.

~EPLAYERHIT [#]

This is sent when the player is shot with a bullet. If not
found, the Robot is sent to PLAYERHURT instead.

~EPLAYERHURT [#]

This is sent when the player is hurt by anything other than a
bullet. Bullets send the Robot to PLAYERHIT, and only send it
to PLAYERHURT if PLAYERHIT cannot be found.

~ESPITFIRE [#]

This is sent when the Robot is hit with shooting fire.

~EJUSTLOADED

This is sent when the world was just loaded or restored from a
saved game. This is also sent upon swapping worlds; in that
case, it will only trigger if no JUSTENTERED label is set.

~EJUSTENTERED

This is sent when the board was just entered or the world was
just started on this board. This is also sent upon swapping
worlds; in that case, if no JUSTENTERED label is set,
JUSTLOADED is triggered instead.

~ESENSORON

This is sent by a Sensor when it is stepped upon by the player,
or the Sensor moves beneath the player.

>#SENSORSW.HLP:094:Sensors

~ESENSORTHUD

This is sent by a Sensor when it tries to move and is blocked.

>#SENSORSW.HLP:094:Sensors

~ESENSORPUSHED

This is sent by a Sensor when it is pushed by something.

>#SENSORSW.HLP:094:Sensors

~ELAZER [#]

This is sent when the Robot is hit with a lazer.

~EGOOPTOUCHED [#]

This is sent when the player touches Goop.

~EYES

This is sent when the YES button is selected in an ASK box.

~ENO

This is sent when either the NO button is selected in an ASK
box, or when ESC exits an ASK box.

>#COMMAND2.HLP:_a2:ASK "string"

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#SENSORSW.HLP:094:Sensors
>#MAIN.HLP:072:Table of Contents
#COUNTERS.HLP
:1st: 
$~9Counters, Built-in Counters and Local Counters

Counters are built-in variables, or stored values with names.
Each counter has a name, such as "Yellow" or "Apple Pies" or
even "100". A counter can hold a value from -2147483648 to
2147483647, in most cases. A counter is "active" when it has a
value other than 0. There can be a practically unlimited amount
of active counters at any one time, in addition to the built-in
counters (in reality it tops off around four billion). Counters
retain values between different boards.

Local counters, on the other hand, only hold their values for
one Robot. These are useful because multiple Robots can set
local counters with the exact same names without causing
conflicts. There are several local counters explicitly reserved
for use; these are the "local" & "local2" thru "local32"
counters.

To display a counter's number, enclose the counter in
ampersands. (e.g. &counter&). This displays the counter value
in decimal. Sometimes hexadecimal is needed, like in certain
MegaZeux commands. To output a counter number in hex, add a
+ to the front of the enclosed counter (e.g. &+hexcount&).

Also, characters can be used as counters in commands. For
example: SET "boom" to '0' would come out as SET "boom" to 48.
It's quite a difference!

The following is a list of built-in counters, which all have
special meanings. There are three types of built-in counters:
Global, which affect everything; Local, which are different for
each Robot and are only available to read by that Robot; and
Board, which are specific to the current board. Some built-in
counters are read-only; a few are write-only.

MegaZeux utilizes a large number of built-in counters to
maximize flexibility. For this reference, they have been
divided into distinct sections.

>#COUNTERS.HLP:ply:Player Counters
>#COUNTERS.HLP:rob:Robot Counters
>#COUNTERS.HLP:brd:Board Counters
>#COUNTERS.HLP:mth:Mathematical Counters
>#COUNTERS.HLP:fac:File Access Counters
>#COUNTERS.HLP:spc:Sprite Counters
>#COUNTERS.HLP:stc:String Counters
>#COUNTERS.HLP:szc:Super MZX Counters
>#COUNTERS.HLP:cha:Character Edit Counters
>#COUNTERS.HLP:chu:Mouse Counters
>#COUNTERS.HLP:def:Defaults Counters
>#COUNTERS.HLP:vlc:Vlayer Counters
>#COUNTERS.HLP:msc:Miscellaneous Counters

$Player Counters
:ply:
~BGEMS, AMMO, LOBOMBS, HIBOMBS, COINS, LIVES, HEALTH

These contain the current number of the stated item that the
player currently has.

~BINVINCO

The number of cycles of invincibility the player currently has.

~BSCORE

The player's current score.

~BPLAYERLASTDIR

The last direction the player moved: 0 for none, or 1 2 3 4 for
N S E W. Used to determine ice slippage and certain other
effects.

~BPLAYERFACEDIR

The direction the player is facing: 0 1 2 3 for N S E W. Used
to determine which player character to display.

~BPLAYERX (read-only)
~BPLAYERY (read-only)

The x or y coordinate of the player, respectively.

$Robot Counters
:rob:
~BPLAYERDIST (read-only, local)

The distance from the Robot to the player, in spaces. The sum
of HORIZPLD and VERTPLD.

~BHORIZPLD (read-only, local)
~BVERTPLD (read-only, local)

The horizontal or vertical distance from the Robot to the
player, in spaces.

~BTHISX (read-only, local)
~BTHISY (read-only, local)

The current X or Y coordinate of the Robot. Affected by
prefixes - If a command that uses THISX and THISY is prefaced
with a REL PLAYER command, THISX and THISY will be generated
based on the player's current position. For example, if the
player is at [2,2] and the Robot is at [5,5], THISX and THISY
will be 3. If the player is at [8,8], THISX and THISY will be
-3. If a command that uses THISX and THISY is prefaced with
a REL COUNTERS command, THISX and THISY will be generated
based on XPOS and YPOS. Basically, THISX and THISY will be
set to THISX-XPOS and THISY-YPOS.

>#COMMAND2.HLP:pre:REL COUNTERS
>#COMMAND2.HLP:_r2:REL PLAYER

~BBULLETTYPE (local)

The current type of bullet shot by the Robot: 0 for Player, 1
for Neutral, and 2 for Enemy. Technically, this counter can
hold any number from 0 to 255, but only 0, 1 and 2 have
defined behavior. Use the others at your own risk!

>#BULLETTY.HLP:1st:Bullet Types

~BCOMMANDS

The number of commands executed per cycle (40 is default). This
number is global. It can severely slow MegaZeux if set too high
and coupled with poor coding (especially busy loops lacking
cycle-ending commands).

~BLOOPCOUNT (local)

The counter used for looping commands in Robotic - LOOP START,
LOOP #, and ABORT LOOP.

>#COMMANDR.HLP:_lC:LOOP START

~BROBOT_ID (read-only, local)

The internal ID of the Robot.

~BRID<Robot name> (read-only)
~BROBOT_ID_<Robot name> (read-only)

Both of these give the robot_id number of the given named
Robot. In the case of multiple robots with the same name, the
ID number corresponds to only one of them (the one with the
largest robot_id). If no robots have the name, or if the name
in question only belongs to the global Robot, -1 is given.

BEWARE: The existence of this counter makes it impossible to
use words which start with "rid" as counters. The port will NOT
fall through and give the values of any counter that starts
with "rid"; instead, it ends at -1 (since the Robot the counter
is trying to find, like "dles" (for "riddles"), will most
likely not exist). Older games will allow this, but only for
compatibility reasons.

~BRn.<counter>

Contains the value of the given counter in the Robot with the
robot_id number n. If no Robot exists with this robot_id, the
counter will return -1.

~BTHIS_COLOR (read-only, local)
~BTHIS_CHAR (read-only, local)

The current color and character of the Robot, respectively.

~BLAVA_WALK (local)

Controls whether the Robot can walk on lava or not. Setting
this to 1 is the equivalent of using the BECOME LAVAWALKER
command. Setting it to 0 is the same as BECOME NONLAVAWALKER.
Like BULLETTYPE, this counter can hold any value from 0 to 255,
but only 0 and 1 have defined behavior. This was a popular
local counter before the local counters were plentiful, as most
Robots didn't deal with lava.

>#COMMANDR.HLP:_b4:BECOME LAVAWALKER

~BLOCAL (local)
~BLOCAL2 (local)
...
~BLOCAL32 (local)

The non-special local counters each Robot can use. In effect,
any number can be used, not just 2-32; the counter accessed by
it would be N%32 (so, for example, any change to "local0" would
have the same effect as changing "local32"). LOCAL is the same
as LOCAL1.

$Board Counters
:brd:

~BBOARD_ID

Reads or alters the CHAR ID value of the object located at
"board_x" "board_y".

>#CHANGECH.HLP:1st:CHANGE CHAR ID - The CHAR ID Table

~BBOARD_PARAM

Reads or alters the parameter of the object located at
"board_x" "board_y".

~BBOARD_W (read-only, board)
~BBOARD_H (read-only, board)

The current board's width and height, respectively.

~BTIME (board)

The current timer value, between 0 and the time limit for the
current board.

~BTIMERESET (board)

The time limit for the current board. 0 for no time limit.

~BSCROLLEDX (board, read-only)
~BSCROLLEDY (board, read-only)

The top-left corner of the screen's x or y coordinates,
respectively.

~BBOARD_X (board)
~BBOARD_Y (board)
~BBOARD_COLOR (read-only, board)
~BBOARD_CHAR (read-only, board)

Set BOARD_X and BOARD_Y to the {x,y} coordinates of a cell on
the current board, and BOARD_COLOR and BOARD_CHAR will
automatically hold the color and character values for that
cell, respectively.

One thing to note is that BOARD_COLOR will not take
transparency into account. For example, if a white-on-black
Robot walks onto a yellow-on-blue floor tile, the Robot appears
as white-on-blue on the screen, but this counter will still
report it as white-on-black instead of the displayed colors.

~BBCHx,y (read-only, board)

Allows the reading of single characters to the board with
regards to coordinates x,y; the comma must be included.

~BBCOx,y (read-only, board)

Allows the reading of single colors to the board with regards
to coordinates x,y; the comma must be included. Much like
BOARD_COLOR, BCOx,y will not take transparency into account.

~BBIDx,y (board)

Allows reading and writing of the CHAR ID of an object on the
board at the coordinates x,y; the comma must be included.

~BBPRx,y (board)

Allows reading and writing parameter values of an object on the
board at the coordinates x,y; the comma must be included.

~BUCHx,y (read-only, board)

Allows the reading of single characters on the under layer at
the coordinates x,y; the comma must be included.

~BUCOx,y (read-only, board)

Allows the reading of single colors on the under layer at the
coordinates x,y; the comma must be included.

~BUIDx,y (board)

Allows reading and writing of the CHAR ID of an object on the
under layer at the coordinates x,y; the comma must be included.

~BUPRx,y (board)

Allows reading and writing parameter values of an object on the
under layer at the coordinates x,y; the comma must be included.

All of the above four under layer counters will fail if any
floor-type object (fake, floor, carpet, ice, lava, etc) is
currently occupying the board layer at the given coordinates.

~BOVERLAY_X (board)
~BOVERLAY_Y (board)
~BOVERLAY_CHAR (read-only, board)
~BOVERLAY_COLOR (read-only, board)

These work in the same way as the BOARD_xxx counters above, but
deal with the overlay instead.

~BOCHx,y (read-only, board)

Allows the reading of single characters on the overlay at the
coordinates x,y; the comma must be included.

~BOCOx,y (read-only, board)

Allows the reading of single colors on the overlay at the
coordinates x,y; the comma must be included.

~BOVERLAY_MODE (read-only, board)

Shows the state of the overlay. 0 is off, 1 is normal, 2 is
static and 3 is transparent.

~BMOD_FREQUENCY (board)

Controls the frequency (in Hz) of the currently playing module/
OGG music. Note that this value is NOT saved by save files, so
if necessary, it needs set again after a save gets loaded.

>#SOUNDEFX.HLP:frq:SAM, OGG, MOD and WAV Frequencies

~BMOD_ORDER (board)

Controls the current mod order of the currently playing mod.

~BMOD_POSITION (board)

Controls the current row in tracked modules, or the current PCM
sample in other types of audio files.

$Mathematical Counters
:mth:

~BABSn

Gives the absolute value of the number n.

~BSQRTn

Gives the integer approximation of the square root of n.

~BMINx,y

Takes the numbers x and y and outputs the smaller number. The
comma is required.

~BMAXx,y

Takes the numbers x and y and outputs the larger number. The
comma is required.

~BMULTIPLIER

Multiplies values output by the normal trigonometric functions
(sin, cos, tan) by the given number.

~BDIVIDER

Divides the number given to the inverse trigonometric functions
(asin, acos, atan) by the given number.


~BC_DIVISIONS

Determines how many divisions the base circle in MegaZeux's
trigonometric functions is divided.

~BSINn
~BCOSn
~BTANn
~BASINn
~BACOSn
~BATANn
~BARCTANdy,dx

Accesses MegaZeux's sine, cosine, tangent, inverse sine,
inverse cosine, inverse tangent, and atan2 functions
(respectively).

>#TRIG.HLP:tri:Trigonometric Functions

$File Access Counters
:fac:

~BFREAD_OPEN (function)
~BFWRITE_OPEN (function)

Opens a file for reading from or writing to, respectively. The
syntax is as such:

set "file.ext" to "FREAD_OPEN"

~BFWRITE_MODIFY (function)

This opens an existing file for reading without overwriting it,
starting at the beginning of the file.

~BFWRITE_APPEND (function)

This opens a file for writing at the END of the file. Note that
all FWRITE_POS functionality is ignored in this mode.

~BFREAD_COUNTER (function)

Reads four bytes from the open file.

~BFWRITE_COUNTER (function)

Writes four bytes to the open file.

NOTE: The above two counters will have different functionality
in worlds made before MZX 2.82 (in the old implementation, they
use two bytes and are unsigned). This is purely for
compatibility reasons.

~BFREAD_POS
~BFWRITE_POS

The current reading or writing position of the accessed file.
If set to -1, sets the position to the end of the file.

~BFREAD_DELIMITER
~BFWRITE_DELIMITER

The character considered the terminator for fread and fwrite
operations, respectively.

~BFWRITE (function)
~BFREAD (function)

Writes strings to and read strings from, respectively, the open
file.

~BSAVE_ROBOT (function)
~BLOAD_ROBOT (function)
~BSAVE_ROBOTn (function)
~BLOAD_ROBOTn (function)

Saves or loads Robotic code to or from plaintext files,
respectively. The first forms save/load the current Robot,
while the second forms save/load the Robot with the Robot ID of
the number n.

~BSAVE_BC (function)
~BLOAD_BC (function)
~BSAVE_BCn (function)
~BLOAD_BCn (function)

Saves or loads Robotic code to or from bitcode files,
respectively. The first forms save/load the current Robot,
while the second forms save/load the Robot with the Robot ID of
the number n.

~BSAVE_WORLD (function)

Saves MZX worldfiles. The syntax is the same as the file
opening series.

~BSAVE_GAME (function)
~BLOAD_GAME (function)

Saves or loads MZX savegames, respectively.

>#FILEACSS.HLP:fil:File Access
>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic

$Sprite Counters
:spc:

~BSPR_CLISTn (read-only)

A list of flagged collisions after a collision test was
performed. Values of n from 0 to (SPR_COLLISIONS - 1) are
valid. If the background collided, SPR_CLIST0 is always set to
-1 to indicate this.

~BSPR_COLLISIONS (read-only)

The number of sprites/background listed in SPR_CLISTn.

~BSPR_NUM

When using p?? for a sprite this value is referenced. When
IF c?? Sprite p?? X Y is used, SPR_NUM is used to match the
highest sprite that's checked; i.e. it will check for all
sprite parameters from p00 to SPR_NUM, and will return true on
the first match.

~BSPR_YORDER (write-only)

If set to 1, the sprites are drawn in order of lowest SPRn_CY
value to highest. Otherwise, the sprites are drawn in order of
their numbers.

~BSPRn_CCHECK (write-only)

If set to 1, overlapping char 32s will not cause a collision
between sprites or the background. If set to 2, char 32s and
blank chars will also not collide, and blank characters will
not be drawn.

~BSPRn_CWIDTH
~BSPRn_CHEIGHT

The dimensions of the collision box around a sprite. (X and Y
dimensions, respectively)

~BSPRn_CLIST (write-only)

Setting this counter to any value will perform a collision test
on sprite n against its current location.

~BSPRn_CX
~BSPRn_CY

The location, relative to the sprite's upper left corner, of
the sprite's collision box (X and Y coordinates, respectively).

~BSPRn_OFF (write-only)

Turns the given sprite off if it is on.

~BSPRn_OVERLAID (write-only)
~BSPRn_OVERLAY (write-only)

If either is set to 1, these draw the given sprite n over the
overlay as opposed to underneath.

~BSPRn_REFX
~BSPRn_REFY

Where the sprite's appearance is stored - either on the board
or the vlayer (see SPRn_VLAYER). Whatever this looks like at
this position is what the sprite will look like when drawn,
including the colors if c?? is used when placing the sprite.

~BSPRn_SETVIEW (write-only)

Setting this to 1 will cause the viewport to be centered around
sprite n. This is useful for scrolling the screen, along with
sprite based players.

~BSPRn_STATIC (write-only)

If set to 1, makes given sprite n act static (like a static
overlay, a static sprite always stays in a given position on
the screen); if this is 0, the sprite scrolls with the board.
SPRn_STATIC takes in SCROLLEDX and SCROLLEDY as collision
reference points, as opposed to the normal {x,y} coordinates.

~BSPRn_SWAP (write-only)

Swaps the given sprite n with the sprite number to which this
function is set.

~BSPRn_VLAYER (write-only)

If set to 1, the sprite is referenced from the vlayer instead
of the board.

~BSPRn_HEIGHT
~BSPRn_WIDTH

The dimensions of the sprite. (x and y dimensions,
respectively.)

~BSPRn_X
~BSPRn_Y

The current position of the sprite. This can be used to set the
sprite outside the edges of the board, whereas PUT c?? Sprite
p?? X Y disallows this.

>#SPRITES.HLP:spr:Sprites

$String Counters
:stc:

~BSET "$string" to "BOARD_NAME"

Sets the given string to the name of the current board.

~BSET "$string" to "BOARD_SCAN"

Sets the given string to a line of characters read directly
from the board starting at "board_x" "board_y" and terminating
at an asterisk (char 42), any instance of char 0, or after 63
characters (whichever comes first). This command is
deprecated; please use copy block to strings instead.

~BSET "$string" to "INPUT"

Sets the given string to any input placed for the "input
string" command.

~BSET "$string" to "MOD_NAME"

Sets the given string to the name of the currently playing
module.

~BSET "$string" to "ROBOT_NAME"

Sets the given string to the name of the Robot this command
is in.

~BSET "$string" to "FREAD"
~BSET "$string" to "FREADn"

Sets the given string to the contents of the currently open
file. FREAD stops at the terminator (*, or char 42, by default)
or at the end of the file. FREADn reads the first n characters
from the file. You can use FREAD with the #N string splicing
format to read up to N characters while still terminating on
the terminator.

~BSET "$string" to "FWRITE"
~BSET "$string" to "FWRITEn"

Places the contents of the given string in the currently open
file. FWRITE places the entire string, while FWRITEn only
places the first n characters. If n goes over the string's
length, the entire string (and nothing else like whitespace or
garbage characters) will be placed.

$Super MZX Counters
:szc:

~BSMZX_MODE

Determines whether Super MZX mode is off (0), 1, 2, or 3.

~BSMZX_Rn
~BSMZX_Bn
~BSMZX_Gn

Changes or reads the value of color n's red/blue/green value,
respectively. These counters also work outside of SMZX modes;
in normal mode, numbers 0-15 alter the normal palette while
16-31 alter the protected palette.

~BSMZX_PALETTE (read-only)

Loads a Super MZX palette. This command is deprecated; please
use load palette instead.

$Character Edit Counters
:cha:

~BCHAR_X
~BCHAR_Y
~BPIXEL

Set CHAR_X and CHAR_Y to a pixel location in the char set. You
can then set the PIXEL counter to one of the following to edit
the pixel:

  0 Turns the pixel OFF
  1 Turns the pixel ON
  2 Toggles the pixel

You can also read the counter to see the current state of the
chosen pixel. A value of 1 denotes that the pixel is set, and 0
if not.

The pixel location system works on a 32 x 8 grid of characters,
exactly like the 'Select Character' grid. Each character
consists of fourteen rows of eight pixels, which gives us 256
pixels across by 112 pixels down. Since we start counting at 0,
the top-left pixel of the top-left character (char 0) would be
0,0. The bottom-right pixel of the bottom-right character
(char 255) would be 255,111. However, these counters become
worthless in SMZX modes.

>#CHAREDIT.HLP:079:The Character Editor

~BCHAR_BYTE
~BCHAR
~BBYTE

Set CHAR to a character (0-225) and BYTE to one of the fourteen
bytes within the char (0-13). You can then read or write that
byte using the CHAR_BYTE counter. Byte values range from 0-255,
and meaning of each byte setting changes between normal mode
and SMZX modes. Normal MZX graphics mode sets bytes in binary
(base 2); SMZX modes use quaternary (base 4).

It helps to write the number in binary/quaternary first, then
convert to decimal. Writing the numbers this way helps
demonstrate that whatever is desired to be set is set. The
values per pixel decrease going left to right.

Examples:

(Normal MZX mode, setting the third, fifth and seventh pixel)

Binary: 00101010

Ú---Â--Â--Â--Â-Â-Â-Â-¿
|128|64|32|16|8|4|2|1|
Ã---Å--Å--Å--Å-Å-Å-Å-´
|  0| 0| 1| 0|1|0|1|0|
À---Á--Á--Á--Á-Á-Á-Á-Ù

Decimal: ((128*0)+(64*0)+(32*1)+(16*0)+(8*1)+(4*0)+(2*1)+(1*0))
         = 42

Notice that the binary number shows which pixels are on, in
order.

(Super MZX Mode, setting first and second pixel to color 2,
third to color 4 and fourth to color 1)

Quaternary: 1130

Ú--Â--Â-Â-¿
|64|16|4|1|
Ã--Å--Å-Å-´
| 1| 1|3|0|
À--Á--Á-Á-Ù

Decimal: ((64*1)+(16*1)+(4*3)+(1*0)) = 92

Much like the binary numbers for normal MZX mode, the
quaternary number shows what color each pixel is in order.
Here, color values range from 0 to 3.

>#CHAREDIT.HLP:079:The Character Editor

$Mouse Counters
:chu:

~BMOUSEX
~BMOUSEY

Reads/sets the mouse cursor's x or y-coordinates (respectively)
relative to the screen in characters.

~BMOUSEPX
~BMOUSEPY

Reads/sets the mouse cursor's x or y-coordinates (respectively)
in pixels. Always scales to terms of 640x350, regardless of the
actual resolution.

~BMBOARDX (read-only, board)
~BMBOARDY (read-only, board)

Reads the mouse cursor's x or y-coordinates (respectively)
relative to the board.

~BBUTTONS (read-only)

Reads which mouse buttons are being pressed. Outputs 0 for
none, +1 for the left, +2 for the right and +4 for the middle.
E.G., left by itself would output 1, and left+middle would
output 5.

~BCURSORSTATE

Determines whether the default mouse cursor is on or off (0 is
off, 1 (or any non-zero value) is on - defaults to off).

$Defaults Counters
:def:
~BENTER_MENU

Determines whether the built-in status window is loaded when
the enter key is pressed. 1 (or any non-zero value) is yes, 0
is no. The default is 1 (yes).

~BHELP_MENU

Determines whether the built-in help window is loaded when the
F1 key is pressed. 1 (or any non-zero value) is yes, 0 is no.
The default is 1 (yes).

~BF2_MENU

Determines whether the built-in MegaZeux options window is
loaded when the F2 key is pressed. 1 (or any non-zero value) is
yes, 0 is no. The default is 1 (yes).

~BLOAD_MENU

Determines whether the built-in MegaZeux loadgame window is
loaded when the F4 key is pressed. 1 (or any non-zero value) is
yes, 0 is no. The default is 1 (yes).

~BBIMESG (write-only)

Controls built-in game messages (e.g. the message given for
touching goop); 1 (or any non-zero value) is on while 0 is off.
The default is 1 (on).

~BSPACELOCK (write-only)

Controls whether holding space locks player movement. If 1 (or
any non-zero value), the player will be locked into place when
space is held; if 0, the player can move freely when space is
held, but will be unable to shoot bullets. The default is 1
(on).

$Vlayer Counters
:vlc:

~BVLAYER_WIDTH
~BVLAYER_HEIGHT

Sets the width and height of the vlayer, respectively. The
defaults are 256 for VLAYER_WIDTH and 128 for VLAYER_HEIGHT.
Setting one will automatically set the other to the maximum
possible for the current vlayer_size.

~BVLAYER_SIZE

Sets the maximum size of the vlayer. The default is 32768.
Making this larger won't change the values of VLAYER_WIDTH or
VLAYER_HEIGHT but shrinking it may shrink both - height first,
then width.

~BVCHx,y

Allows reading and writing of single characters to the vlayer
at the coordinates x,y; the comma must be included.

~BVCOx,y

Allows reading and writing of single colors to the vlayer with
at the coordinates x,y; the comma must be included.

>#VLAYER.HLP:vla:The Vlayer and Its Uses

$Miscellaneous Counters
:msc:
~BMZX_SPEED

The current game speed (1-16) of MegaZeux. Once the speed is
set with this counter, the player cannot change the speed in
the F2 menu until MZX_SPEED is set to 0. Setting MZX_SPEED to 0
will not affect the current speed. Neither MZX speed nor speed
locking is preserved in saves, so games that change the speed
must alter the speed using the "justloaded" label to stay
consistent. MZX_SPEED will revert back to the default value
listed in the configuration file upon loading a different game.

>#CONFGINI.HLP:1st:The Config File

~BCURRENT_COLOR
~BRED_VALUE
~BGREEN_VALUE
~BBLUE_VALUE

When CURRENT_COLOR is set between 0 and 31 (between 0 and 255
in Super MZX modes), the other three counters contain the red,
green and blue values of that color.

>#SMZXMODE.HLP:095:Super MegaZeux Modes
>#PALEEDIT.HLP:093:The Palette Editor

~BINPUT (board)

The numerical value of the last string inputted.

>#COMMAND2.HLP:_iP:INPUT STRING "string"

~BINPUTSIZE (board)

The size, in characters, of the last string inputted.

>#COMMAND2.HLP:_iP:INPUT STRING "string"

~BDATE_DAY (read-only)
~BDATE_MONTH (read-only)
~BDATE_YEAR (read-only)

Contain the current day, month and year respectively, based on
the system clock.

~BTIME_HOURS (read-only)
~BTIME_MINUTES (read-only)
~BTIME_SECONDS (read-only)

Contain the current hour, minute and second respectively, based
on the system clock, in 24-hour format.

~BINT
~BBIT_PLACE
~BINT2BIN

Used to manipulate bits within a counter. Set INT to the number
or counter you wish to edit. Set BIT_PLACE to a number between
0 and 15 (which correspond to the bits in a 16-bit signed
counter), and then set INT2BIN to one of the following to edit
the bit:

  1 Sets the bit ON
  2 Sets the bit OFF
  3 Toggles the bit

The edited value is placed into the INT counter. You can also
read the INT2BIN counter to see the current state of the bit.

This method of bit manipulation is heavily deprecated in favor
of expressions (especially considering it only works on 16 bits
instead of the current 32). Follow the link below to read more.

>#EXPRESS.HLP:exp:Expressions

~BKEY_PRESSED (read-only)
~BKEY (read-only)
~BKEY_CODE (read-only)

Tests whether any key (each referenced by a number) is
currently being held down; for example, on a typical keyboard,
if the spacebar is being pressed the value of key_pressed will
be 32. This set of keycodes is the same as the ones required
for joystick support. Results are unsigned, so checking for
negative numbers will not work. "Autorepeat" affects
KEY_PRESSED, so if you hold down a key you will get the value,
then get zeros for a period, then get the values again. This is
useful for many applications.
KEY acts like KEY_PRESSED, but lacks autorepeat.
KEY_CODE acts the same as KEY_PRESSED but lacks autorepeat and
has different keycodes. Its keycode set is more limited, making
KEY_CODE only preferable if autorepeat has to be off.

~BKEYn (read-only)
~BKEY_RELEASE (read-only)

KEYn checks whether the key with the keycode n is pressed; 1
means yes, 0 means no. KEY_RELEASE tests whether a key is
released. These display/use the same keycodes as KEY_CODE.
Results are unsigned, so checking for negative numbers will not
work.

~BXPOS
~BYPOS

The X or Y-coordinates (respectively) used by the REL COUNTERS
command.

>#COMMAND2.HLP:pre:REL COUNTERS

~BFIRSTXPOS
~BFIRSTYPOS

The X or Y-coordinates (respectively) used by the REL COUNTERS
FIRST command.

>#COMMAND2.HLP:_r4:REL COUNTERS LAST

~BLASTXPOS
~BLASTYPOS

The X or Y-coordinates (respectively) used by the REL COUNTERS
LAST command.

>#COMMAND2.HLP:_r7:REL COUNTERS LAST

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#USINGTHE.HLP
:1st: 
$~9Using the Editor

The Robotic editor is quite simple to use. After selecting your
Robot's character and name, you will enter the editor screen.
There are three major sections to the editor screen: The top
box, showing current statistics; the middle box, showing the
Robot's program with the current line highlighted in the
center; and the bottom box, showing the available editing
commands.

To edit the Robot, you enter lines just as in editing Scrolls.
Use up and down or PageUp and PageDown to Scroll between lines,
and use Enter at the end of a line to insert new blank lines.
Pressing Enter in the middle of a line will remove everything
to the right of the cursor and place it onto a new, following
line. Press Backspace at the beginning of a line to place its
contents onto the preceding line (this be ignored if there is
not enough space).

After you enter a line, it will be checked for proper syntax.
If it passes, it will be reformatted and redisplayed, and you
can then enter another line; if it does not, it will be marked
as ignored. The reformatting is unpreventable - Since MegaZeux
tokenizes Robotic lines to conserve space, all irrelevant
information such as extra spaces is lost. The editor attempts
to print the lines in a visually pleasing manner.

All lines other than the current line will have the various
elements such as strings and numbers highlighted in different
colors. cXX-type color codes will be shown as their actual
color. The current line is shown in a solid color and color
codes are shown in the usual cXX format.

The following keys are active within the editor.

>_ar:F1 - Help
>_br:F2 - Color
>_cr:F3 - Character
>_dr:F4 - Parameter
>_er:F5 - Char Edit
>_fr:F6-F10 - Macros
>_gr:F12 - Take Screenshot
>_hr:Alt+B OR Alt+Enter - Block Action
>_ir:Alt+E OR Alt+End - Mark Block End
>_jr:Alt+H - Hide Help / Borders
>_kr:Alt+I - Import
>_lr:Alt+O - Macro Options
>_mr:Alt+S OR Alt+Home - Mark Block Top
>_nr:Alt+U - Unmark Block
>_or:Alt+V - Verify
>_pr:Alt+X - Export
>_qr:Alt+BackSpace - Delete Entire Line
>_rr:Alt+Ins - Paste
>_sr:Ctrl+F - Find/Replace
>_tr:Ctrl+G - Goto Position
>_ur:Ctrl+R - Repeat Find/Replace
>_vr:Ctrl+I/D/C - Mark Line
>_wr:Ctrl+BackSpace - Delete Previous Word
>_xr:Ctrl+LeftArrow - Jump to Previous Word
>_yr:Ctrl+RightArrow - Jump to Next Word
>_zr:Esc - Exit Robotic Editor

:_ar:~EF1 - Help

Use F1 to bring up context-sensitive help at any time.

:_br:~EF2 - Color

F2 will bring up a menu of colors. Select one and press Enter to
insert a cXX color code into the current line corresponding to
that color.

:_cr:~EF3 - Character

F3 will bring up a menu of characters. Select one and press
Enter to insert that character into the current line. No quotes
or apostrophes are added.

:_dr:~EF4 - Parameter

If you have just typed in the name of a thing, such as Ammo,
F4 will allow you to select settings for it in order to insert
a pXX parameter code.

:_er:~EF5 - Char Edit

Use F5 to insert series of numbers corresponding to character
pictures, for use with the Robotic CHAR EDIT command.

:_fr:~EF6-F10 - Macro

F6 through F10 will insert short macros, customizable using
Alt+O. If you have an extended macro set for these an input
window for it will come up.

:_gr:~EF12 - Take Screenshot

Pressing F12 will make a 640x350 screenshot (in PNG format by
default) in the working directory, using the software renderer.
The file naming starts from "screen0".

:_hr:~EAlt+B OR Alt+Enter - Block Action

Allows you to perform an action on the current block of lines.
Possible actions are: Copy to the OS's clipboard, Cut to the
OS's clipboard (copy it and then delete it), Clear from memory,
or Export to a text file on disk. If no block is currently
highlighted, the actions will take effect on the current line.
Alt+Enter is the old and deprecated hotkey, left in to ease use
for long-time users.

:_mr:~EAlt+S OR Alt+Home - Mark Block Top
:_ir:~EAlt+E OR Alt+End - Mark Block End

Alt+S/E will mark the top or bottom of a block of lines. You
can then perform various block actions on these lines. The
marked lines are highlighted. Alt+Home and Alt+End are the old
and deprecated hotkeys, left in to ease use for long-time
users.

:_jr:~EAlt+H - Hide Help / Borders

Alt+H toggles the horizontal borders and help key reference.

:_kr:~EAlt+I - Import

Use Alt+I to import a text file or bytecode file into the
current Robot. The new lines will be inserted into the current
program, starting from the current line.

:_lr:~EAlt+O - Macro Options

You can change the values of the five macros here. Use ^ for
Enter in the macros. (43 characters max in MegaZeux itself, 64
max using the config file.)

>#CONFGINI.HLP:1st:The Config File

:_nr:~EAlt+U - Unmark Block

The current block is unmarked.

:_or:~EAlt+V - Verify

Use Alt+V to determine if there are any invalid lines in the
robot, and if there are what their errors are.

:_pr:~EAlt+X - Export

Use Alt+X to export either the current block or the entire
Robot program to a text file or bytecode file on disk. If saved
as text, one can then edit the program outside of MegaZeux or
use the text file in other ways.

:_qr:~EAlt+BackSpace - Delete Entire Line

The currently selected line is blanked. The empty line itself
will remain.

:_rr:~EAlt+Ins - Paste

Alt+Ins will paste in the block last copied to the internal
clipboard. The clipboard used is the OS clipboard, and as such
is preserved between Robots and even between worlds.

:_sr:~ECtrl+F - Find/Replace

Use Ctrl+F to activate the Find/Replace menu. In this menu, one
can find an inputted string, replace it, or replace all
instances of it at once. Wrap Around End will ensure every line
of the code is checked (otherwise all code above the current
line will be ignored) and Match Case will require the search
string and the results match case exactly before giving results
or replacing text.

:_tr:~ECtrl+G - Goto Position

Use Ctrl+G to jump to the given Robotic line/column (if too
high of a number is given, the editor will jump to the last
possible line/column).

:_ur:~ECtrl+R - Repeat Find/Replace

Use Ctrl+R after a Find or Replace action to repeat the action.

:_vr:~ECtrl+I/D/C - Mark Line

These commands mark the current invalid line as to be ignored,
deleted, or commented out upon editor exit, respectively. If
the line is valid Ctrl + C will turn it into a comment
(truncating the end of the line if commenting would make the
line exceed 241 characters). Note that comment-marking a
comment will immediately strip the line.

:_wr:~ECtrl+BackSpace - Delete Previous Word

Use Ctrl+BackSpace to delete the last word typed in the editor.

:_xr:~ECtrl+LeftArrow - Jump to Previous Word

Use Ctrl+LeftArrow to jump to the beginning of the previous
word in the current line.

:_yr:~ECtrl+RightArrow - Jump to Next Word

Use Ctrl+RightArrow to jump to the beginning of the next word
in the current line. If on the last word of the line, this
command jumps to the end of the line.

:_zr:~EEsc - Exit Robotic Editor

This key will exit the Robotic Editor, unless any lines are
marked as invalid.

The statistics line across the top of the Robot editor shows
the current line number, the current character within the line,
the size of the Robot program versus the maximum size this
Robot can reach, and the Robot's X/Y position.

Use ESC to exit the Robot editor when you are done editing your
Robot program.

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#ROBOTSWH.HLP
:1st: 
$~9Robots - What They Are and How to Use Them

Robots are the heart and soul of MegaZeux. Anything you could
want to do in MegaZeux, anything you see done in a MegaZeux
game, many things you didn't know were possible, can be done
with MegaZeux's Robots.

Robots are programmed in their own programming language, called
Robotic. Robotic is a fairly simple language to learn, but
somewhat moderate to completely master. It is somewhere along
the lines of BASIC, although more complex. If you've ever used
Epic Megagame's ZZT, Robotic is vastly more complex than
ZZT-OOP, although there are vague familiarities. There's a
kludge or two dozen to get really powerful things working, but
you'll get used to them.

To place a Robot in the editor, press F10 and select Robot, or
Pushable Robot if you want things to be able to push the Robot.
Then name the Robot, and select a character to represent it.
Now you are brought to the Robot editor, where you can program
the Robot in Robotic.

>#ROBOTICT.HLP:1st:Robotic Tutorial
>#MAIN.HLP:072:Table of Contents
>#ROBOTICR.HLP:087:Robotic Reference Manual
#ROBOTICT.HLP
:1st: 
$~9Robotic Tutorial

Robotic has a few concepts that you must understand before you
begin to program in it. You can skip this if you want, but it
will help you learn Robotic much faster. A large portion of
this will be obvious to anybody who has ever programmed in any
language or used computers extensively.

$Commands

You can have one command per line. A command is an instruction
to MegaZeux or the Robot telling it to do something. A program
is a series of commands, that are run right after another.

$Parameters

A parameter is the part of the command that can change, such
as numbers or colors. They specify how the command should be
run or what it should affect. For example, in the command

WAIT 6

WAIT is the command, and 6 is the parameter. Many commands have
multiple parameters. Parameters are often specified using #,
"string", or [color] [char] etc.

$Labels

A label is a point in a Robotic program that has been given a
name. It is used as a reference point so the Robot can return
to that point at any time, to allow repeating sections of
commands, etc. Labels are written as follows - : "label"

$Messages

A message is something one Robot sends to another, or an
external event sends to a Robot, to tell it to do something.
That something entails jumping to the label corresponding to
that message. For example, a Robot can tell another Robot to
"Bounce"; That Robot will now be executing commands starting
at the label :"Bounce".

$Coordinates

{x,y} coordinates are a pair of numbers representing a point on
the current board. {0,0} is the upper left corner of the board,
and the first coordinate increases while going right, while the
second increases while going down. You can find coordinates
easily using Alt+Y in the editor, or F6 in the game (only in
editor playthroughs). {x,y} coordinates can be negative, but
this is uncommon and used for special purposes only (e.g. using
REL commands).

$Strings

A string is a series of letters or characters, inside quotes.
For example, "STRING", "Booga!", "-21_Trees-", or "[[]]".

$Characters

A character is a single symbol, letter, number, punctuation
mark, space, graphic, etc. All things are viewed as single
characters. When using single characters in Robotic, they must
be enclosed in apostrophes- e.g. 'X'. Certain characters must
be inputted in specific ways to avoid problems with Robotic:

  \0 for character 0 (this probably won't work in strings, but
  should work in chars)
  \t for tab (character 9)
  \n for newline (character 10)
  \r for carriage return (character 13)
  \" for quotation mark
  \\ for slash

$Colors

A color is a code representing a background/foreground color
pair. They follow the format cXX, where X is 0-9 or A-F. To
enter color codes easily, use F2 in the Robot editor. The exact
format of color codes is covered in another section.

$Directions

Directions represent one of the four cardinal directions of
NORTH, SOUTH, EAST, or WEST. They can be abbreviated to N, S,
E, and W. There are other directions, but these are the most
commonly used.

Hopefully you understood the above material, as knowledge of it
is essential to program in Robotic. If you don't quite grasp
it, you can return to it later, but you will need to understand
it eventually.

$Your First Robotic Program: HELLO WORLD!

First, open the Editor and create a Robot. Then open the
Robot's programming box by pressing Enter twice while the Robot
is highlighted.

Now, type the following into the editor:

~E* "HELLO WORLD!"
~Eend

Here's what each line does.

~E* "HELLO WORLD!"

The * command puts whatever text is in the parentheses on the
bottom of the screen. (Actually, it's the given message row
line, which is the bottom by default.) All Robotic code starts
immediately, so this particular statement happens right as the
board with this Robot is loaded.

~Eend

This ends the code. It is good practice to include the END
command even when you don't think you need it; leaving the END
command out can cause some problems such as text glitches or,
worse, the running of any and all code after where you want
your Robot to stop!

That was really simple, wasn't it? Now let's step up to
something a bit bigger.

$Your Second Robotic Program

Create a Robot in the editor, and give it the following
program:

 ~E: "start"
 ~EGO NORTH 2
 ~EGO SOUTH 2
 ~EGOTO "start"

Now test the world. As you can see, this program makes the
Robot move up and down. Let's analyze it line by line.

~E: "start"

As we know, this is a label. It marks the beginning of the
program.

~EGO NORTH 2

This quite plainly tells the Robot to move north two spaces.

~EGO SOUTH 2

This tells the Robot to move south two spaces.

~EGOTO "start"

GOTO tells the Robot to jump to a label. In this case, the
Robot returns to the label "start", effectively restarting its
code. This particular Robot will be executing these lines of
code for the entirety of the game, or until destroyed.

Pretty easy so far, huh? You will probably find that Robotic's
basics are easy to grasp. Let's try something a little more
complex.

$Your Third Robotic Program

Try the following Robot program:

 ~E: "loop"
 ~E/ "NNEESSWW"
 ~EGOTO "loop"
 ~E: "touch"
 ~E* "Hello!"
 ~ECHAR 'X'
 ~EEND

Testing will show you that this Robot runs around in a small
square. Now try touching it. If you can catch it, the Robot
will change to an X and greet you! Let's look at this program.

~E: "loop"

A label.

~E/ "NNEESSWW"

The / command tells the Robot to move along a given path. The
path is represented with a string of the letters N, S, E, W,
and I. NSEW represent the four cardinal directions, while I
tells the Robot to wait for a bit before continuing. Our path
tells the Robot to go north twice, east twice, south twice, and
west twice, forming a square path.

~EGOTO "loop"

The Robot will now return to the "loop" label, continuing in a
square path forever. Without an outside stimulus, the Robot
will never do anything else.

~E: "touch"

Another label, but this one is special. When the player touches
a Robot, by standing next to it and pressing against it, the
Robot is sent the message "touch". The following commands will
be run when the player touches the Robot.

~ECHAR 'X'

This tells the Robot to assume the appearance of character X.
Make sure that the X is in apostrophes ' and NOT quotes ".

$Robot Interaction

Let's get some Robots to interact with each other. Put two
Robots on a board, right next to each other. Name the left one
Lefty, and give it this program:

 ~E: "dance"
 ~E/ "WWWEEE"
 ~ESEND "Righty" to "dance"
 ~EEND

Name the right one Righty, and give it this program:

 ~EEND
 ~E: "dance"
 ~E/ "EEEWWW"
 ~ESEND "Lefty" to "dance"
 ~EEND

Now test this board out. You will see a silly pair of dancing
Robots, as they bump each other left and right. Let's examine
their programs more closely.

Since Righty has an END command as the first line, he isn't
going to be doing anything until told; so, we look at Lefty.
It's nothing we haven't seen, except for the SEND command.

~ESEND "Robot" to "message"

The SEND command allows one Robot to send messages to another,
telling it what to do. In this case, Lefty will tell Righty to
"dance", sending Righty to the label "dance".

Knowing this, the behavior of the two Robots should be clear.
Each one, in turn, moves away and back again, then it tells
the other one to do this. This repeats ad infinitum.

For a little practice, see if you can get them each to display
a message at the start of their dance step. Make the messages
different for each Robot.

$Some New Commands

The following Robot will demonstrate some new commands and
features. Make sure you put some ammo and bombs on the screen
with this Robot:

 ~EEND
 ~E: "shot"
 ~ECOLOR c2C
 ~E[ "OKAY, I GET THE POINT. I NEED MORE IRON"
 ~E[ "...and now a liver transplant :<"
 ~Ezap "shot" 1
 ~EEND
 ~E: "shot"
 ~E[ "...cut it out. =("
 ~EEND
 ~E: "bombed"
 ~E. "Check this out..."
 ~E. "(editor) I'm not impressed."
 ~E* "ARRGHFRRAGGH I'M ALLERGIC TO BEING BOMBED"
 ~EDIE
 ~EEND
 ~E: "touch"
 ~E* "Watch out!"
 ~EWAIT 10
 ~ESHOOT SEEK
 ~EEND

Test this Robot out, bombing, shooting, and touching it. The
new commands and labels are explained below.

~E: "shot"

When the Robot is shot by a bullet, it is sent this message.

~ECOLOR c2C

This changes the Robot's color. The c2C represents Lt. Red on
Red. To enter colors, press F2 in the Robot editor and select
the color you want. The appropriate cXX code will be typed in
for you.

~E[ "OKAY, I GET THE POINT. I NEED MORE IRON"
~E[ "...and now a liver transplant :<"

The [ command is slick for a default. When encountered, all
the [ commands in the same area are put together to form one
long message, which is then displayed in a Scroll-like window.
It can be Scrolled and viewed by the player.

~EZAP "shot" 1

The ZAP command tells the Robot to ignore a certain number of
labels with the given name - in this case, the first "shot"
label. The ZAP command always starts from the top. Using the
ZAP command lets programmers give out different reactions for
going to the same label. In this case, we get to go to the
second "shot" label after we went to the first.

~B: "bombed"

When the Robot is bombed, or otherwise hit by an explosion,
it is sent this message.

~E. "Check this out..."
~E. "(editor) I'm not impressed."

Notice how this message was not shown in any way. The . command
is used for comments, i.e. messages that are not to be shown.
They are good for your own reference, so you know what you were
trying to do with this Robot, or so you can keep notes of
important things.

~EDIE

This command destroys the Robot forever.

~EWAIT 10

WAIT causes the Robot to stop and sit for an amount of time,
the amount of time specified as a number. The time is in
cycles, which is the amount of time it takes to update the
board once, moving all the enemies and bullets, etc. Robots can
cycle at different speeds; the default is speed 1 (fastest,
runs every real cycle) unless a cycle command is placed inside
the Robot.

~ESHOOT SEEK

The Robot will shoot a bullet in the indicated direction (in
this case, the direction the player is in).

$Conclusion

You now should know enough Robotic for simple programs. Even
more importantly, you should be able to scan the Robotic
reference manual, including the command reference, and be able
to learn many new commands. There are loads of important
commands and concepts in the command reference that we have not
yet mentioned, such as TELEPORT PLAYER, IF statements, file
access, expressions, and COPY BLOCK statements. It is
recommended that you at least browse over each of the Robotic
reference manual sections.

Make sure you (eventually) read over every part of the
reference manual, as there are many sections not covered in the
tutorials. Especially of interest will be advanced topics like
"The Vlayer and Its Uses", "Using MZMs", "Subroutines" and most
newer help file additions.

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#THEGLOBL.HLP
:gbl: 
$~9The Global

The global Robot is a special-case Robot; it is always present
on every board of the game. It is immobile (technically off the
board, but listed as at {-1,-1}), has a ROBOT_ID of 0, and
cannot be destroyed or changed into another object, even
through deliberate attempts to do so such as the EXPLODE
command. All other traits of Robots, such as 64k of Robot
memory, reserved local counters and the ability to be copied,
apply to the global.

The global is accessed either through pressing G to access the
Global Settings menu and then clicking Edit Global Robot, or by
simply pressing Alt+G on the editor screen.

The global is important because it not only exists on all
boards, but also continues its state across boards. This allows
for easy management of continuous global engines such as an
inventory, status bars, and sidescrolling control, among
others. If the global did not exist, a copy of the engine would
be needed on every board, and the states of each such Robot
would be separate (possibly leading to management problems).

Certain commands (as hinted above) are worthless in the global.
Obvious commands such as BECOME, EXPLODE, COLOR/CHAR and all
command forms that take a relative direction (like LAYBOMB and
DUPLICATE SELF [dir]) will be ignored. DIE, DIE ITEM and GOTOXY
.# # are completely ignored as well.

Finally, the global is the only Robot that ignores FREEZETIME
and SLOWTIME states. This is extremely handy in creating the
ability to pause and unpause a MegaZeux game, among other
things.

>#COMMAND2.HLP:_f4:FREEZETIME #
>#COMMAND2.HLP:_sS:SLOWTIME #
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#BADPRACT.HLP
:101: 
$~9Robotic Usages That Should be Avoided

There are several coding pitfalls in Robotic; while some are
complex in nature, others can be easily avoided. In general,
clean and efficient code is the least likely to cause
unexpected errors as well as the easiest to repair. Listed here
are several practices to avoid, as well as proper replacements.

~cBAD: Creating anything with c?? or p??
  Anything that has an undefined value will use a default
  that may be undesirable. The correct action would therefore
  be to define the object's color and parameter values.
~9GOOD: Putting in any set value for colors and parameters.

~cBAD: Using global counters for temporary or localized work.
  There are several counters that are Robot-specific and don't
  eat up global counter space. local through local32 per Robot
  should be enough for almost everyone, and the local counters
  can be written to and read by other robots as well (using the
  r&id&.local# counter form).
~9GOOD: Using local counters for temporary or localized work.

~CBAD: Breaking a subroutine without returning or entering the
  ~Cmiddle of a subroutine.
~9GOOD: Fully finishing and starting subroutines. This is
  especially important for built-in labels which can trigger
  very rapidly, such as #keyN.

~cBAD: Using a high amount of if statements regarding one
  ~Cvariable.
~9GOOD: Using goto "label&number&" regarding one variable.

~CBAD: Looping without using cycle-ending commands of any kind.
  Looping without CYCLE 1 in idle loops is more severe than
  many think. Coupled with the "commands" counter set to a high
  number, loops without CYCLE 1 can absolutely choke a game's
  speed, especially idle loops, and potentially FREEZE MZX.
~9GOOD: Including CYCLE 1 in every loop except loops that are
  ~9designed to get a finite length task done as quickly as
  ~9possible.
  You should add a CYCLE 1 for any loop that constantly checks
  for events (such as keypresses or board status).

~cBAD: Ending Robots with a label.
~9GOOD: Ending Robots with the END command.
  It's debatable whether putting END after commands that
  destroy the Robot (e.g. DIE, EXPLODE #) is necessary, but it
  is still recommended in order to prevent a habit of leaving
  it out in less redundant places.

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#SUBROUTE.HLP
:sub: 
$~9Subroutines

Subroutines are returnable labels, in essence. After the
subroutine actions finish, the Robotic goes to the line right
after the subroutine call. Anywhere a label can be used, a
subroutine can be called.

Another way to think about it is a label with a place marker.
Going to this label marks your previous place; when done, the
program goes straight to the place marker and returns where it
left off.

Subroutines are accessed by using the # sign as the first
letter. For example: ~egoto "#example"~f would call the
subroutine at the label "#example". To return to the next
command after the call use ~egoto "#return"~f.

In addition, one can go to the first subroutine's return
position using ~egoto "#top"~f.

A quick example of subroutines:

~E* "YE SHALL NOT PASS UNLESS YOU GIVE ME SPACE."
~Egoto "#spacewait"
~E* "THAT'S BETTER BUT YOU'RE STILL HERE. _CORRECT THIS_"
~Egoto "#spacewait"
~E* "THANKS FOR YOUR COMPLIANCE!"
~Ewait 25
~E* "YOUR PASS WILL ARRIVE IN 6 TO 8 WEEKS! or now! byebyebye"
~Eset "PASS" to 1
~Edie
~Eend
~E: "#spacewait"
~E: "spaceheld"
~Ecycle 1
~E. "If space is held down, progress no further."
~E. "We want to force space to be pressed each time."
~Eif spacepressed "spaceheld"
~E: "notspaceloop"
~Ecycle 1
~Eif not spacepressed "notspaceloop"
~Egoto "#return"

When sending other robots to subroutines the behavior is
slightly different. Because the robot is pre-empted
(interrupted) it will return to the same command it was at
before going to the subroutine, not the instruction after.

When using subroutines, especially with easily triggerable
conditions, it is important to try to make sure that every
subroutine send ends in a #return, or that every set of
subroutine sends ends in a #top. The built-in labels can be
especially problematic, as some can trigger rapidly in a short
period of time. State management with LOCKSELF and/or ZAP is
crucial.

NOTE: Unlike older versions of MegaZeux, it is no longer needed
to initialize the stack, so don't get confused looking at older
examples of code and seeing odd statements like ~e. "#*-1-2-3"~f.
These statements are now treated as comments, and you should
mentally treat them the same.

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#EXPRESS.HLP
:exp: 
$~9Expressions

Expressions in MegaZeux allow users to set counters or a
displayed number to a mathematical expression. This possible
inputs are: counters, constants, or a combination. Any
expression in MegaZeux is bound in quotation marks and
parentheses. For example, an expression adding 5 and 3 would
be done in MegaZeux by inputting "(5 + 3)".

Counters can be used inside expressions using single quotes or
ampersands like so: "(&five& + 'three')".

MegaZeux cannot decipher directly nested ampersands or single
quotes; such will cause MegaZeux to misinterpret your
expression in different ways, depending on which you used.
Therefore, using expressions for nesting is another benefit.

Example: We set "r" to 1, "in" to 8 and ""out18" to 11. We want
to output the value of "out18".
"(&out&&r&in&&)" would output (0r&in&).
"('out'r''in'')" would output ('out'r''in'')
"('out('r')('in')')" would output the desired result - 11.

Nesting is limited only to the amount one can put in a single
editor line - 241 characters.

In expressions, the following operators may be used:

Binary operators (value-argument-value):

 +  Addition
 -  Subtraction
 *  Multiplication
 /  Division
 %  Modulo
 ^  Exponent (A^B is A to the Bth order/power)
 >> Bitshift Right (logical, not arithmetic)
 << Bitshift Left (logical, not arithmetic)
 >  Greater Than
 <  Less Than
 >= Greater Than or Equal To
 <= Less Than or Equal To
 =  Equal To
 != Not Equal To
 a  Bitwise AND (not logical AND)
 o  Bitwise OR (not logical OR)
 x  Bitwise XOR (not logical XOR)

~E+ Addition~F: Outputs the sum of the two given values. (3+2)
would return 5.
~E- Subtraction~F: Outputs the difference of the two given values.
(3-2) would return 1.
~E* Multiplication~F: Outputs the product of the two given values.
(3*2) would return 6.
~E/ Division~F: Outputs the quotient of the two given values.
(3/2) would return 1. Note that any fractional values will be
truncated, i.e. have the decimal part of the number thrown out.
~E% Modulo~F: Outputs the remainder of the two given values, when
both values are positive. (5%3) would return 2. The modulo
expression function and the modulo command may output different
results if any number involved is negative; unlike the command,
the modulo expression function uses a floored modulo.
To explain, if the dividend is negative, than the result will
be the divisor minus the remainder (e.g. (-5%3) would return
1); if the divisor is negative, than the result will be the
additive inverse of the difference of the divisor and the
remainder (e.g. (5%-3) would return -1); if BOTH are negative,
the result will be the additive inverse of the remainder (e.g.
(-5%-3) would return -2).
~E^ Exponent~F: Outputs the result of taking the first number to
the power of the second number. (3^2) would return 9.
~E>> Bitshift Right~F: Shifts the first number rightward by [second
number] of bits. Info shifted off of the boundaries will NOT
wrap around. Using an 8-bit counter for clarity's sake, (5>>2)
would turn 5 [00000101] into 1 [00000001] by shifting two bits
rightward.
~E<< Bitshift Left~F: Shifts the first number leftward by [second
number] of bits. Info shifted off of the boundaries will NOT
wrap around. Using an 8-bit counter for clarity's sake, (5<<2)
would turn 5 [00000101] into 20 [00010100] by shifting two bits
leftward.
~E>>> Signed Shift Right~F: Also known as Arithmetic Right Shift.
Shifts the first number rightward by [second number] of bits,
but unlike normal bitshift right, shifts in whatever number was
in the leftmost bit instead of always shifting in 0s. Info
shifted off of the boundaries still will not wrap around. Using
an 8-bit counter for clarity's sake, (5>>>2) would turn 5
[00000101] into 1 [00000001], while (-5>>>2) would turn -5
[11111011] into -2 [11111110].
~E> Greater Than~F: If the first number is greater than the second
number, outputs 1 (TRUE); otherwise, outputs 0 (FALSE). (3>2)
would return 1, (2>2) would return 0.
~E< Less Than~F: If the first number is less than the second
number, outputs 1 (TRUE); otherwise, outputs 0 (FALSE). (3<2)
would return 0, as would (2<2).
~E>= Greater Than or Equal To~F: If the first number is either
greater than or equal to the second number, outputs 1 (TRUE);
otherwise, outputs 0 (FALSE). (3>=2) would return 1, as would
(2>=2).
~E<= Less Than or Equal To~F: If the first number is either less
than or equal to the second number, outputs 1 (TRUE);
otherwise, outputs 0 (FALSE). (3<=2) would return 0, (2<=2)
would return 1.
~E= Equal To~F: If the first number is the same value as the second
number, outputs 1 (TRUE); otherwise, outputs 0 (FALSE). (3=2)
would return 0, (2=2) would return 1.
~E!= Not Equal To~F: If the first number is a different value
compared to the second number, outputs 1 (TRUE); otherwise,
outputs 0 (FALSE). (3!=2) would return 1, (2!=2) would return
0.
~Ea = Bitwise AND~F: Performs a bitwise AND operation on the two
given values; i.e. compares the bits of each value and sets to
1 each bit that is 1 in both numbers. Using an 8-bit counter
for clarity's sake, (5a3) would return 1, as 5 [00000101] and 3
[00000011] has only the bit in the ones place set in both
numbers, leaving 1 [00000001].
~Eo = Bitwise OR~F: Performs a bitwise OR operation on the two
given values; i.e. compares the bits of each value and sets to
1 each bit that is 1 in either number. Using an 8-bit counter
for clarity's sake, (5o3) would return 7, as 5 [00000101] and
3 [00000011] have bits set in the fours, twos, and ones places
among them, leaving 7 [00000111].
~Ex = Bitwise XOR~F: Performs a bitwise XOR operation on the two
given values; i.e. compares the bits of each value and sets to
1 each bit that is different between numbers. Using an 8-bit
counter for clarity's sake, (5x3) would return 6, as 5
[00000101] and 3 [00000011] have different bits set in the
fours and the twos places, leaving 6 [00000110].

Unary operators (operator followed by value):

~E- Unary Negation~F: returns the negative value of the operand
(two's complement); i.e. reverses the sign of a number. (-10)
would return -10.
~E~~ Bitwise Negation~F: returns the bitwise NOT value of the
operand (one's complement); i.e. changes each bit in a number.
Using an 8-bit counter for clarity's sake, (~~10) [00001010]
would return -11. [11110101]

Special usages:

-Using a constant expression "(n)" is the only way to directly
use numbers over 32767 or under -32768. This can not be changed
due to the way the world file format is coded. This is also the
only way to use octal (base 8) and full-sized hexadecimal
numbers; octal numbers always begin with a 0 (ex: 01745) and
hex numbers begin with 0x (ex: 0xDEAF).
-The ~E#~F character returns the value of the last sub 
expression. For example, if the previous expression was
(2+(2*3)), then # would return 8. Keep in mind that expressions
evaluate from left to right, so, for example, consecutive
expressions (2+2) and ((10/5)+#)) would yield 4 for the second
expression instead of the expected 6 (since # would evaluate to
(10/5) and not (2+2). This function is slated to be removed,
with no backwards compatibility checks to support it, so use at
YOUR OWN RISK.

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#FILEACSS.HLP
:fil: 
$~9File Access

MegaZeux allows somewhat unwieldy but powerful file access
abilities. File access can do things that no other tools of
MegaZeux can do, such as create high score tables or preserve
and unlock game options without needing a save. An MZX world
can access any file in its own directory or deeper, including
for charset, palette, sound and MZM loading commands; access of
folders outside of this range is forbidden.

MegaZeux has some ways of saving standard formats in-game:

~ASET "file.txt" to "SAVE_ROBOT"
~ASET "file.txt" to "LOAD_ROBOT"
~ASET "file.txt" to "SAVE_ROBOTn"
~ASET "file.txt" to "LOAD_ROBOTn"

These commands can save Robotic code to text files and import
text files into a Robot. The first forms use the current Robot,
while the second forms use the Robot with the given Robot ID n.

~ASET "file.bc" to "SAVE_BC"
~ASET "file.bc" to "LOAD_BC"
~ASET "file.bc" to "SAVE_BCn"
~ASET "file.bc" to "LOAD_BCn"

These commands can save Robotic code to files in bitcode format
and import bitcode files into a Robot.  The first forms use the
current Robot, while the second forms use the Robot with the
given Robot ID n. Bitcode is much more compact than plain text,
but cannot be easily read by the human eye.

Note that for loading Robotic code via LOAD_ROBOT(n) or
LOAD_BC(n), any and all local counters previously set in the
Robot will retain their value.

~ASET "file.mzx" to "SAVE_WORLD"

This command saves MZX worldfiles.

~ASET "file.sav" to "SAVE_GAME"
~ASET "file.sav" to "LOAD_GAME"

These commands save or load MZX savegames, respectively.

MegaZeux can manipulate any type of file with certain Robotic
commands. There are some basic things to remember when using
file access.

-A file can only be read or written to at one time, never both.
This means you can't select the same file to be the current
"FREAD_OPEN" and "FWRITE_OPEN" targets.
-Only one file can be read to and one can be written to at the
same time.
-Writing and reading operations change the current fwrite and
fread positions.
-There is a special character called the terminator (char #42,
'*', by default) placed at the end of a write when a string is
written to a file with FWRITE. This character ends an FREAD to
a string when encountered (the terminator character itself will
not be in the string output). However, using FWRITEn will not
place a terminator, and FREADn will ignore any terminator
characters encountered.
-Lastly, files need to be closed when the current task is
finished. Otherwise, the file remains open and causes problems.
To close a file, use SET "" to "FREAD_OPEN" to close a file for
reading and SET "" to "FWRITE_OPEN" to close a file for
writing.

Here are the file writing commands at your disposal.

~ASET "file.xxx" to "FREAD_OPEN"

This command loads a file for reading. It can also open
directories for reading (by using the name of the directory by
itself, e.g. ~ASET "directory" to "FREAD_OPEN"~F); FREAD will then
list the names of files in the directory.

~ASET "file.xxx" to "FWRITE_OPEN"

This command creates a new file for writing; if a file by this
name already exists, it is overwritten.

~ASET "file.xxx" to "FWRITE_MODIFY"

This command opens an existing file for reading without
overwriting it, starting at the beginning of the file.

~ASET "file.xxx" to "FWRITE_APPEND"

This command opens a file for writing at the END of the file.
Please note that FWRITE_POS settings will not work in this
mode.

~ASET "FREAD_POS" to #
~ASET "FWRITE_POS" to #

These commands change the current reading or writing position
of the accessed files. The position is in DECIMAL, not
hexadecimal. To seek the end of a file, set to -1.

~ASET "FREAD_DELIMITER" to #
~ASET "FWRITE_DELIMITER" to #

These commands change the character considered the terminator;
the FREAD command changes which character is detected as the
terminator, and the FWRITE command changes which character is
written as the terminator.

~ASET "counter" to "FREAD_COUNTER"

Reads from the open file to a counter. This will grab four
bytes instead of the normal one (treated as signed; the
resulting range is from -2147483648 to 2147483647).

~ASET "FWRITE_COUNTER" to "counter"

Writes from a counter to the open file. This will write the
full counter instead of simply the first byte (treated as
signed; the resulting range is from -2147483648 to 2147483647).

~ASET "FWRITE" to "counter"
~ASET "$string" to "FWRITE"
~ASET "$string" to "FWRITEn"
~ASET "counter" to "FREAD"
~ASET "$string" to "FREAD"
~ASET "$string" to "FREADn"

These commands write values to and read values from,
respectively, the open file relative to the FREAD_POS or
FWRITE_POS counters. FWRITE and FREAD, when used with counters,
only write one byte at a time (from 0-255).
The SET "$string" to "FWRITEn" and "FREADn" commands will write
the first n characters (relative to FREAD_POS or FWRITE_POS)
from the file to the given string or read the first n
characters from the string into the open file, respectively.
Using ~ASET "$string.N" to "FWRITE(n)"~F will ensure that the
string will be at least N characters long when written.
FWRITE and FREAD, when used with counters, can be substituted
by FWRITE_COUNTER and FREAD_COUNTER to read in longer values
at a time (four bytes as opposed to one).

Another use of file commands (which takes more work, but not
much) is verifying whether a file exists. To do this, a 
programmer would type:

~ESET "file.xxx" to "FREAD_OPEN"
~ESET "FREAD_POS" to -1
~EIF "FREAD_POS" >= 0 "existslabel"

If the file does not exist, "FREAD_POS" will read -1; if it
does exist, "FREAD_POS" will be the number of characters in the
file (0 or higher). Setting "FREAD_POS" or "FWRITE_POS" to -1
is called "file end seeking" and is also very helpful for
finding the length of the file, as well as for placing stuff at
the end of a file.

Here's a quick example of file access.

~ESET "example.txt" to "FWRITE_OPEN"
~ESET "$zoosound" to "ROAAAAR"
~ESET "$zoosound" to "FWRITE"
~EDEC "FWRITE_POS" by 1
~E. "This line backs us up one space so that the terminator
~E. "character will be overwritten, allowing us to display the"
~E. "whole contents of the file."
~ESET "$ender" to " (click)"
~ESET "$ender" to "FWRITE"
~ESET "" to "FWRITE_OPEN"
~E. "We're closing the file because we're going to read from it."
~ESET "example.txt" to "FREAD_OPEN"
~EASK "Want to play your animal sounds tape?"
~EEND
~E: "yes"
~ESET "$tape" to "FREAD"
~E* "&$tape&"
~EWAIT for 30
~EZAP "yes" 1
~EASK "Want to play it again?"
~EEND
~E: "yes"
~ESET "" to "FREAD_OPEN"
~E. "Switching tasks for the same file again."
~ESET "example.txt" to "FWRITE_OPEN"
~E. "We're wiping the file clean."
~ESET "$winder" to "bzz-bz-zipfwip--(clik) "
~ESET "$winder" to "FWRITE"
~EDEC "FWRITE_POS" by 1
~ESET "$tape" to "FWRITE"
~ESET "" to "FWRITE_OPEN"
~ESET "example.txt" to "FREAD_OPEN"
~EZAP "yes" 1
~E: "yes"
~ESET "FREAD_POS" to 0
~E. "We're forcing the beginning position because we want to"
~E. "read all of the file every possible time, not just the"
~E. "first time."
~ESET "$tape" to "FREAD"
~E* "&$tape&"
~EWAIT for 30
~EASK "Want to play it again?"
~EEND
~E: "no"
~ESET "" to "FREAD_OPEN"
~EEND

This Robot will display first a roar and the sound of a tape
player clicking off before it asks if you want to play the tape
again. If no, the file is closed and the program ended. If yes,
rewinding tape sounds are stuck on the front of the text. The
player can then choose to re-view this text until "No" is
chosen.

>#COUNTERS.HLP:fac:File Access Counters
>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#SPRITES.HLP
:spr: 
$~9Sprites

Sprites allow the designer to have interactive entities on the
board composed of several characters. A sprite is a block of
characters drawn on the board or the vlayer that is then
displayed on the board, either beneath or above the overlay.
The biggest benefit of sprites is that they are cohesive;
unlike use of several Robots, there is absolutely no chance of
the sprite falling apart.

There are up to 256 available sprites, and sprites are
controlled in the following ways:

-Through sprite specific counters named SPRn_value
-Through control counters for all of the sprites
-Through commands for placing sprites and testing for collision

To setup a sprite you should set the SPRn_REFX / REFY / WIDTH /
HEIGHT counters to define where the sprite is and what its size
is. Then if you use:

~APUT cXX sprite pNN x y

where NN is the number of the sprite in hexadecimal (if you
write NN without the p in decimal it will be automatically
converted). If cXX is c?? then the sprite is drawn with its
normal colors as seen on the board, otherwise it's painted with
the given colors.

So, for example, to make a 2x2 sprite, you could draw it on the
board at the position [10, 10], assign it to sprite number 15,
then have it drawn at position [40, 5]. The Robotic for this is
as follows:

~ASET "spr15_refx" 10
~ASET "spr15_refy" 10
~ASET "spr15_width" 2
~ASET "spr15_height" 2
~APUT c?? sprite p0f 40 5

You can then move the sprite around by changing spr15_x and
spr15_y. For example, using:

~AINC "spr15_x" 1
~ADEC "spr15_y" 1

will move the sprite to the northeast by 1.

Now that you have sprites setup and displayed you can do
collision tests; these check if moving sprites will cause
collision (i.e. overlapping) with either the background (i.e.
customblocks) or with other sprites. This way you can prevent
sprites from moving on top of walls or on top of other
characters, or allow a sprite to damage another one when
striking.

This is done by using the following command:

~AIF c?? sprite_colliding pNN x y "collision"

This will go to the label "collision" if moving the sprite x by
y from its current position will cause it to collide with
something. If anything besides c?? is used then [x, y] are
absolute board coordinates instead.

If collision is gone to, then the spr_clistN counters will be
set to what it collided with and spr_collisions will be set to
the number of things that the sprite collided with. If the
sprite will have collided with the background spr_clist0 will
be set to -1. If for instance, the sprite also collided with
sprites 2 and 3 spr_collisions will be set to 3 and spr_clist1
will be 2, spr_clist2 will be 3. The values of spr_clistN with
values of n greater than spr_collisions - 1 are undefined.

sprN_static uses the SCROLLEDX and SCROLLEDY counters instead
of absolute board coordinates for determining collisions.

See the Sprite Counters and Robotic sections for other features
of sprites.

>#COUNTERS.HLP:spc:Sprite Counters
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#SMZXMODE.HLP
:095: 
$~9Super MegaZeux Modes

Super MZX modes (a.k.a. SMZX) allow richer color options at the
expense of halved horizontal resolution. The number of colors
per character doubles to four, while the number of total max
colors on-screen at one time squares to 256. However, each mode
works differently and has different limitations and uses.

In the editor, F11 switches between Super MZX modes (in the
order of normal->1->2->3->normal). To set Super MZX modes in a
game, use the ~Aset "smzx_mode" # ~FRobotic command, where # is
the SMZX mode.

Super MZX mode 1 is the simplest mode and the easiest mode to
use. SMZX mode 1 simply blends the foreground and background
colors to get the third and fourth character colors. It is
obviously limited (this mode only allows editing of the 16
base colors) but is useful for anti-aliasing and shading
effects.

Super MZX mode 2 is the most difficult mode to use, although it
has its benefits. It allows considerable control over the
palette and allows for some overlay and sprite translucency
effects. Its colors (values in hex) are determined as such:

-Color I is the background color number as the first and second
digits. (For example, if background color is 5, the hex number
of color I is 55.)
-Color II is the foreground color number as the first digit
and the background color number as the second. (For example, if
foreground color is 10 and background color is 5, the hex
number of color II is A5.)
-Color III is the background color number as the first digit and
the foreground color number as the second. (For example, if
background color is 5 and foreground color is 10, the hex
number of color III is 5A.)
-Color IV is the foreground color number as the first and
second digit. (For example, if foreground color is 10, the hex
number of color IV is AA.)

Super MZX mode 3 is the best for dynamic usage of the palette,
and the easiest to edit in general. Its colors are determined
around a base value in hex (background color number as first
digit, foreground color number as second). Color I's number is
the base, II's is base+1, III's is base+2, and IV's is base+3.
The numbers wrap around (so if your base is, for example, FF,
color II would be 00).

Character editing in Super MZX modes is noticeably different.
While the character set can be edited in MegaZeux's internal
character editor, certain changes occur. 1-4 selects the
desired color; space no longer toggles between colors (it
always sets here); right click no longer clears; clear mode is
gone. Also note that the char editor sets itself to mode 1
during SMZX char editing; keep this in mind if you have a
visible character pool outside of the editor window to help
visualize.

Palette editing for SMZX modes cannot be done in MegaZeux's
editor. Palette editing and creation must be done through
Robotic. Thankfully, people have created MZX files that greatly
ease the problem of creating SMZX palettes. PalzorII and Pal_ed
are two such programs. The commands for changing the palette
are:

~BSMZX_Rn
~BSMZX_Bn
~BSMZX_Gn

These change or read the value of color n's red/blue/green
value, respectively. n ranges from 0 to 255.

Lastly, SMZX palettes and character sets can be loaded and
saved like any other palette or character set. However, this
wasn't the case in DOS, so there is a deprecated way to load
an SMZX palette (SET "filename" "smzx_palette").

>#COUNTERS.HLP:szc:Super MZX Counters
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#CHAREDIT.HLP:079:The Character Editor
>#MAIN.HLP:072:Table of Contents
#VLAYER.HLP
:vla: 
$~9The Vlayer and Its Uses

The vlayer is an extra, global graphical layer, but it is never
directly seen. It can only hold character and color info. The
vlayer acts like a workspace allowing copying from/to overlay,
copying from/to MZMs, copying between places in the vlayer,
reading/writing individual graphical data to/from the vlayer,
and reading strings from the vlayer.

Another important aspect of the vlayer is the ability to
reference a sprite to the vlayer. This allows indirect display
of the vlayer through display of sprites. This can be
exploited to create the semblance of an extra overlay layer.

The vlayer defaults to 32768 characters large (256x128); its
size can be as large as roughly 16.7 million characters (2^24).
Its size can be determined by setting the counter "vlayer_size"
to the desired length of the vlayer. Doing this only sets the
maximum size; the actual vlayer will not be this large unless
the vlayer's dimensions are changed. All attempts to set the
vlayer's size above the maximum will be ignored.

To change the vlayer's dimensions, use the counters
"vlayer_width" and "vlayer_height". When one dimension is
given, the other becomes as large as possible to fill the given
vlayer. For example, if one has a vlayer 50000 characters large
and sets vlayer_height to 499, the vlayer's width will become
100 characters wide (for a total vlayer size of 49900
characters). 

All bad values of vlayer_size, vlayer_height and vlayer_width
(0 and below) will be changed to 1.

To manipulate the vlayer, instead of pure numbers in copy
commands, "#n" is used instead. For example, if copying a 2x2
block from {6,6} of the board to {0,0} of the vlayer is wanted,
the command would be:

~ECOPY BLOCK 6 6 2 2 "#0" "#0"

Here are the vlayer copy functions:

Board to vlayer: ~ACOPY BLOCK x1 y1 w h "#x2" "#y2"
Overlay to vlayer: ~ACOPY OVERLAY BLOCK x1 y1 w h "#x2" "#y2"
Vlayer to board: ~ACOPY BLOCK "#x1" "#y1" w h x2 y2
Vlayer to overlay: ~ACOPY OVERLAY BLOCK "#x1" "#y1" w h x2 y2

In the commands below, ~eCOPY BLOCK~f and ~eCOPY OVERLAY BLOCK~f
are interchangeable.

Vlayer to MZM:
~ACOPY (OVERLAY) BLOCK "#x1" "#y1" w h "@@name.mzm" m
Vlayer to string:
~ACOPY (OVERLAY) BLOCK "#x1" "#y1" w h "$stringN" c
Vlayer to itself:
~ACOPY (OVERLAY) BLOCK "#x1" "#y1" w h "#x2" "#y2"

There are several ways to give the vlayer working coordinates:

Pure numbers - ~E"#xxx"~F
Counter value - ~E"#&counter&"~F
Expressions - ~E"#('counter' + x)"~F

MZMs can be placed on the vlayer by using p02. Example:

~EPUT "@@visuals.mzm" image_file p02 x y

Reading and writing single characters or colors from the vlayer
requires the vch and vco counters.

For reading and writing characters use ~E"vchX,Y"~F.
For reading and writing colors use ~E"vcoX,Y"~F.

For example:

~ESET "vch10,10" '+'~f sets the vlayer char at {10,10} to a plus
sign.
~ESET "vco10,10" 15~f sets the vlayer color at {10,10} to white on
black.
~ESET "temp" "vch10,10"~f sets temp to whatever the character at
{10,10} of the vlayer is.

Remember that the vlayer is global. If many vlayers are wanted,
liberal usage of MZM saving and loading will help get around
this problem.

>#COUNTERS.HLP:vlc:Vlayer Counters
>#STRINGS.HLP:1st:Strings, Special Formatting, and Their Place in Robotic
>#MZM.HLP:mzm:Using MZMs
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#MZM.HLP
:mzm: 
$~9Using MZMs

MZM files are equivalents of the ANSI files used in older MZX
versions. MZMs, however, are much more powerful and can store
much more information. MZMs can be up to 65535 x 65535 tiles in
size. MZMs are useful for easy access of reused graphics and
reused, multi-Robot entities.

MZMs come in two modes: "board" and "layer".
  * Board mode saves color, param, ID, and under information.
    However, it cannot save the player, scrolls or sensors.
    Board mode can save Robots and most built-ins; MZMs saved
    in the editor will save fresh robots, while MZMs saved
    in-game keep the Robots' current states.
  * Layer mode saves only color and char information.

Any information not saveable will be replaced by a customblock
facsimile.

When loading a board MZM file to the overlay or vlayer, the
character used is the parameter stored. Outside of customblocks
and related, different characters could appear due to different
param settings (especially built-ins and Robots).

One can save MZMs in the editor; use the block action function.
MZMs saved in the editor from the board are saved as board;
from the overlay and vlayer, MZMs are always saved as layer.

Robotic methods of saving MZMs are:

~ACOPY BLOCK x y w h "@@filename" p
~ACOPY OVERLAY BLOCK x y w h "@@filename" p
~ACOPY (OVERLAY) BLOCK "#x" "#y" w h "@@filename" m

X/Y are the coordinates of the block's upper-left corner; w/h
are the width and height of the block; filename is the name of
the file (the @@ is required); finally, p determines the MZM
type. 1 saves as layer; 0 saves as board. 0 is integral for
copying non-graphical data (primarily Robots); 1 is proper for
copying graphical data, as the block's appearance will stay as
exactly as it was when saved. The last case is for saving from
the vlayer to MZM. The {x,y} coordinates MUST be in "#x" "#y"
format, and the m MUST exist.

The Robotic method of loading MZMs is:

~APUT "@@filename" image_file pNN x y

filename is the name of the MZM file (after the required @@),
x and y are the upper-left corner's coordinates, and NN is 00
for board, 01 for overlay, 02 for vlayer.

Finally, MZMs will neither be saved nor loaded if at the edge
of a board.

>#USINGTHE.HLP:_g:Alt+B OR Alt+Enter - Block action
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#TRIG.HLP
:tri: 
$~9Trigonometric Functions

Trigonometry can simplify some complex engines, and MegaZeux
can access several trigonometric functions with fair precision.
Accessing trigonometric functions in MegaZeux requires some
setup, however.

Because MegaZeux works solely with integers, you need to set
the counter "multiplier" to determine how the non-integer
working value is converted. For example, if your function
has a value of .86602 and "multiplier" is set to 10000, the
resulting value would be 8660. Numbers are always rounded
down from their values. The default value for the "multiplier"
counter is 10000.

Also, the counter "c_divisions" determines the precision of the
trig functions by determining how many times the circle is
divided. Sensible values for this include 360 (degree
precision), 21600 (arc-minute precision) and 1296000
(arc-second precision). The default value for the "c_divisions"
counter is 360.

The "divider" counter works solely on inverse trigonometric
functions. Its effect is to divide the number passed to an
inverse function before it is calculated. For example, if you
have "divider" set to 100 and try to calculate "acos50", MZX
will calculate the arccosine of .50 (50 divided by 100),
outputting 60 degrees. The default value for the "divider"
counter is 10000.

These are the trig functions MegaZeux can directly utilize.

~ASIN - sine
~ACOS - cosine
~ATAN - tangent
~AASIN - arcsine (inverse sine)
~AACOS - arccosine (inverse cosine)
~AATAN - arctangent (inverse tangent, takes signs into account)
~AARCTAN - atan2 (special form of arctangent, takes two values
~Ain the form of ARCTANdy,dx ("dy" is the first input, "dx" the
~Asecond))

NOTE: The inverse functions output degrees, not radians.

To use the counters you put the unit number after the counter
name. Here's an example.  To display the cosine of 30 degrees
with degree-based precision, the needed line would be:

~E* "&cos30&"

Trig functions can also take expressions and counters. However,
counters can only be inserted through expressions; a construct
like "&sinlocal&" will not work, but "&sin('local')&" will.

>#COUNTERS.HLP:mth:Mathematical Counters
>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#PARTIAL.HLP
:par: 
$~9Partial Character Sets

Partial character sets are smaller than full sets, as the name
definitely implies, but they only overwrite the characters they
are told to. This leaves the rest of the characters intact.
Heavy animations and changes that keep part of the character
set intact (such as the alphanumeric characters) are two issues
best tackled with partial character sets.

One can save a partial character set in the editor by
selecting a starting character value (aka "offset") and a
length value. These fields show up when you export a character
set, under the filename input.

To load partial character sets into your current set, you have
two options. You can firstly load it as you would a normal
character set; this replaces all characters from the start of
the target character set until the end of the partial set.
Secondly, you can load the partial set into a non-0 position of
the target character set.  In the editor, this can be done by
setting the offset field in the import character dialog, under
the filename input. The @@xxx prefix allows this in Robotic;
xxx is the number (in decimal) of the first character to
replace in the target character set.

>#ROBOTICR.HLP:087:Robotic Reference Manual
>#MAIN.HLP:072:Table of Contents
#NEWINVER.HLP
:1st: 
$~9NEW in MegaZeux!

December 24, 2012 - MZX 2.84c

Hey all, new version of MegaZeux here! And hopefully without
any crashes this time around!  Haha yeah right.

The most notable thing this release (besides fixed crash bugs,
as usual) is the new counter debugger! Give it a try and tell
us what you think!

Counter binary search has been replaced with a hash table in
versions of MegaZeux for most platforms. This has resulted in
slightly faster counter lookups, and MUCH faster creation of
counters, since MegaZeux doesn't have to keep the list ordered.
The hash table is turned off for NDS builds for now due to
tight memory constraints.

Otherwise, most of the new features are editor enhancements and
modifications. Notable mentions are reordering the board list
with 'M' and a custom undo history size.

FEATURES

+ The functionality of the F11 counter/string debugger has been
  expanded to include sprites, robots, and miscellaneous world
  and board variables. The ability to modify many of these vars
  is limited and a large portion are read-only. In addition,
  you may add new counters and strings, hide empty
  counters/strings (does not affect built-in variables), and
  search by name and contents. Export is still limited to
  counters and strings.
+ Max string length has been increased from 1MiB (1048576
  bytes) to 4MiB (4194304 bytes).
+ Board mods may now be selected from subdirectories of the
  game folder in the ALT+N dialog.
+ The title bar now displays the world and editing board/robot
  names based on context.
+ Fire Burns Space and Fire Burns Forever are off by default.
+ You may now specify the size of the undo history in the char
  editor, and the history affects the entire char set. Undo is
  still ALT+U, redo is now ALT+R.
+ You may now use the -/+ keys in the world editor to move to
  the previous/next boards in the board list, and Shift+Arrows
  to change to the boards linked by board edge.
+ You may now move the current board anywhere in the board list
  with M. You may not move the title screen board.
+ View mode in the board editor (V) will start from the current
  location of the screen now rather than at the top-left
  corner.
+ Config file options for default board settings added, as well
  as the ability to save these per-world from the editor.
+ Ctrl+G - Goto board position at X,Y.
+ png2smzx now requires less arguments and has an option to
  skip a char (generally char 32 will be useful to skip).

+ Debytecode: The robotic editor now asks for a confirmation to
  save the program on exit.

BUGFIXES

+ Fixed a bug in the 'glsl' renderer that caused the cursor
  color to be ignored (always white). This caused the cursor to
  not be visible if shown on a white background. (ajs)
+ Setting $string.length will not cause memory corruption now.
  In addition, its pre-2.84 behavior of intentionally
  allocating the string past the set length has been restored,
  but the length itself will still be set to the correct value.
+ Added bounds check to INC "$string" "value". Attempts to
  increase a string past its maximum length (4 MiB, or 4194304
  bytes) will now fail.
+ Fixed MegaZeux crash that could sometimes occur when a string
  was increased by itself.
+ Fixed MegaZeux crash that could occur when exiting the editor
  to a world file that failed validation.
+ Rolled string->storage_space into string->name to prevent
  buffer overflow errors and crashes. (Mr_Alert)
+ Fixed crash that would occur when attempting to type in a dir
  in the ALT+N dialog.
+ Fixed a bug where copy block $string would apply REL twice.
+ Thanatos Insignia (DoZ Q1 2011, 98485) will now play without
  freezing both normally AND after loading a save. Robots will
  not be incorrectly versioned with the save format magic now.
+ Fixed bug where ALT+M wouldn't always edit non-stored types.
+ Fixed bug where ! could not be used as a substitute for ~~.
+ Fixed a bug where tab-draw and block actions would carry
  between board and overlay editing. ALT+O now sets the drawing
  mode back to normal on a switch.
+ ALT+M now edits the overlay instead of the board while
  editing the overlay.
+ Quick-load (F10 during gameplay) will not work if the load
  menu (F4) has been disabled with the LOAD_MENU counter.
+ Fixed a bug where the listening mod directory would stay the
  same as the directory the editor was opened in.
+ The listening mod now continues to play after world and board
  changes, and also after the board mod has been changed by
  ALT+N or Shift+8/*.
+ LOAD_GAME will not incorrectly trigger JUSTENTERED anymore.
+ Palette/intensity changes made on the same cycle as a
  teleport player command are now properly taken into account.
  This fixes a game-stopping regression in Sponkgo's Legendary
  Journey where leaving the second stage's bonus area would
  leave the color intensity at 0.
+ SMZX mode is now disabled when leaving the editor if it was
  enabled in the editor via F11.
+ Fixed potential crash bug where robot bytecode files were not
  being validated before being loaded with LOAD_BC.
+ Fixed minor message box bug dating back to DOS where a
  message box starting with an unavailable option would begin
  with the cursor on a blank line.
+ Fixed crash that happened when typing over bounds while
  renaming a file in a file manager dialog. File and directory
  renaming now use a popup dialog akin to ALT+N.
+ Files with names longer than 55 chars may now be selected in
  file managers. The limit for typing in a file name is still
  55 chars.  You may not enter a blank line as a file name
  anymore.
+ Fixed segfault when attempting to read THIS_COLOR for the
  global robot. It will now always return -1.

DEVELOPERS

+ Overhauled txt2hlp. Error messages now differentiate between
  hyperlinks and labels and will take the display chars ~~ and &
  into account. Eventually, the goal should be to get rid of
  txt2hlp altogether and have MZX load straight from the .txt
  file.
+ Added compile option to use uthash for counter/string lookups
  as opposed to binary search. Ideally, this will vastly improve
  lookup speeds for large numbers of counters/strings, but will
  consume more memory. (Thanks to Lancer-X for the modified
  uthash header file.)
  
>#MAIN.HLP:072:Table of Contents

June 20, 2012 - MZX 2.84b

Less than three weeks after the last one, MegaZeux 2.84b is
here a few weeks early to fix a key regression regarding the
use of REL commands with the COPY x y dx dy command.  While
several new features have been added, this release was mostly
about rooting out as many crash bugs from MegaZeux as possible.
An official public beta release of debytecode has been pushed
off once again due to time constraints.

Most notable as far as new features go, pressing 'E' while a
game's title screen is running will now take you directly to
that world in the editor. A blank new world may still be
created with 'F8', and now with the 'N' key. The function key
corresponding to the new 'E' functionality is 'F9'.

A major new aspect of this version, which could be seen as a
bugfix or as a new feature, is MegaZeux's ability to validate
the MZX, MZB, MZM, and SAV file formats. Validation has been
rigorously tested and refined, and a comprehensive list of most
world files that fail any check is available on the MZX Wiki.
File load crashes and force-quit "Out of memory" errors in
these instances are nearly a thing of the past.

One final major change regards the file manager dialogs (Load /
Save Game, etc). These dialogs have been internally overhauled
to avoid permanent directory changes unless a valid world or
save file has been loaded.  If any bugs are experienced using
these, they should be reported to the MZX Bug Tracker.

FEATURES

+ Pressing 'E' or 'F9' on a title screen will now open the
  current world for editing.  Press 'N' or 'F8' to create a new
  world.
+ Multiple hosts may now be defined in config.txt. Update
  attempts will be carried out in the order they are defined.
+ A startup path may be defined in config.txt ("startup_path").
+ Specifying the backup filename with a directory, ex.
  "backup/file", will now silently attempt to create the
  directory if it does not exist.
+ MZM3 is now forward compatible (robots will be dummied out).

BUGFIXES

+ World validation has been strengthened, preventing
  disasterous loads of most non-world files.  Mostly
  intact/valid worlds, such as HUNTDRAK.MZX, can be loaded --
  corrupt/missing boards will be replaced with blank boards,
  corrupt robots will be replaced by robots with empty
  programs, and so on.  If more robots/scrolls/signs are found
  on a board than their data suggests there should be, the
  extras will be replaced with customblocks. Back up the
  version of the world with errors in this instance, as the
  robots' code or scroll text may still be salvageable from the
  world data.
+ Fixed a long-standing memory corruption bug in the shoot
  command introduced by the port.
+ Mac OS X: MegaZeux now uses /Users/[username] as the default
  starting directory. Apps previously would always start at the
  filesystem root. (ajs)
+ Fixed dangerous crash-causing bug where the editor would not
  chdir back to the correct directory after testing.
+ MegaZeux, after saving a world to a new directory, now chdirs
  to the new current world file's directory.
+ Changed behavior where a failed save file load would fade the
  still-running world out of focus. MegaZeux now leaves the
  world in focus.
+ All failed world/save loads leave the current world running
  and in the same working directory.
+ When startup_file is defined as a directory at the command
  line, MZX chdirs to the directory instead of attempting to
  open it as a world file.  In the config file, the directory
  is pruned off since there's a new config option for the
  startup path.
+ Fixed regression where the rel commands would be ignored for
  board to board copy x y dx dy.
+ Updated MZX_SPEED in the counter debugger, where it was still
  getting clamped from 1 to 9.
+ COLOR FADE IN and COLOR FADE OUT (and all built-in uses of
  them) now correctly respect any COLOR INTENSITY changes made
  before they are used.
+ In file selection dialogs, when attempting to make a
  directory that already exists with ALT+N, MZX now shows the
  correct file name and does not force the user to quit
  MegaZeux.
+ In file selection dialogs, when pressing ALT+D with a
  directory selected, MZX now correctly prompts to delete the
  selected directory instead of a file.
+ The option to import world files in the board editor now
  correctly takes the world version into account.
+ Savegame MZMs loaded into the editor now have their robots
  dummied out for safety purposes.
+ Fixed bug where INPUT STRING would not terminate lines longer
  than 71 chars after clipping them.
+ INPUT STRING and ASK do not allow either tabs (INPUT only) or
  line breaks (both) anymore.
+ Fixed bug where putting a scroll/sign in the editor buffer
  and then selecting something else could cause a crash on
  leaving the editor.

+ Temporary fix for MSVC bug where all window dialogs would
  freeze. (MZXGiant)
+ Temporary fix: board block actions will not corrupt robot
  source code in DBC anymore. (MZXGiant)

DEVELOPERS

+ Switched debian prereq. and darwin libpng12 to libpng,
  switched darwin and default ldflags to use '--ldflags'
  instead of '--libs'.
+ Darwin CC/CXX compiler can now be specified on the command
  line. (ajs)
+ Cleaned up broken ifeq structure in darwin Makefile.in so
  ARCHes other than i686 can be built.
+ Updated MSVC dirent.h to the latest version (MZXGiant)
+ Added updated MSVC dependencies. (MZXGiant)

>#MAIN.HLP:072:Table of Contents

June 01, 2012 - MZX 2.84

The first version of MegaZeux to be released in two and a half
years, this time with a vast number of bugfixes, several new
features, and hopefully no new bugs.

There's a new port to the Pandora platform from Exophase. There
are no binaries for this platform yet, as ajs has not had time
to set up the cross-compiler. Same goes for Android.

Another major (internal) change this time around is that
Exophase's experimental "debytecode" language modification has
been merged. This still has some major bugs open against it,
and missing features, so I won't be doing official releases
yet. You can add support for this feature by passing
"--enable-debytecode" to config.sh on all platforms.

Thanks to Terryn, Exophase and MZXGiant for their contributions
and to Lancer-X, Old-Sckool and Lachesis who reported and
tracked the majority of bugs this time round.

FEATURES
+ Added experimental port to Pandora. See arch/pandora/README
  for more information. (Exophase)
+ Directories may now be opened with FREAD_OPEN.  This
  functionality can be used in conjunction with FREAD_POS and
  SET "$str" FREAD. FREAD will set the string to "" when it has
  reached the end of the file listing.
+ MZX_SPEED can now be set up to 16 by a robot or from the F2
  dialog menu. (Lachesis)
+ Numbers can now be temporarily backspaced past their minimum
  value to make typing a new number more intuitive in dialogs.
  (Lachesis)
+ Chars 0 and 255 can now be selected from the Edit Chars
  submenu of the Global Info menu. Using char 255 on a kind
  that would have previously denied it now gives a warning
  dialog. (Lachesis)
+ New Counter: SPACELOCK represents the default space
  functionality for the built-in player. Setting this counter
  to 0 disables it, allowing the player to move as normal when
  space is pressed. Setting it back to 1 enables it again.
  Defaults to 1. (Lachesis)
+ New Counter: FREAD_DELIMITER allows you to change the
  terminating char for the string FREAD function.  The
  terminating char still defaults to '*'. A complementary
  FWRITE_DELIMITER function has been added as well. (Lachesis)
+ New Counter: ARCTANdy,dx takes two values and returns the
  angle with corrected quadrants as an alternative to using
  ATANdy with DIVIDER as dx, which was less intuitive and never
  documented properly. (Lachesis)
+ New Counters: MINv1,v2 and MAXv1,v2 return the minimum or
  maximum value between two inputs, respectively. Chain several
  of these in an expression or a loop for more arguments.
  (Lachesis)
+ New Counters: bchX,Y; bcoX,Y; bidX,Y; and bprX,Y are new
  shorthand access counters for BOARD_CHAR, BOARD_COLOR,
  BOARD_ID, and BOARD_PARAM.  The same limitations to those
  counters apply to the new ones. (Lachesis)
+ New Counters: uchX,Y; ucoX,Y; uidX,Y; and uprX,Y are new
  shorthand access counters for the board's under layer.  The
  same limitations apply to these as to their board
  counterparts.  Additionally, these counters will fail if the
  same spot on the normal board is occupied by a floor-type
  (space, [dir]water, lava, fake, etc...). (Lachesis)
+ New Counters: ochX,Y and ocoX,Y are new shorthand access
  counters for the overlay.  Like OVERLAY_CHAR and
  OVERLAY_COLOR, these are read-only to discourage the user
  from writing to these instead of using the much faster PUT
  [color] [char] OVERLAY [x] [y]. (Lachesis)
+ Pressing ALT+G from the world editor now goes directly to the
  Global Robot without having to skip through the Global Info
  menu. (Lachesis)
+ MZM3 has been enabled for 2.84 and all following versions.
  The difference between MZM3 and MZM2 is that MZM3 stores a
  copy of the world version, allowing the robot format to
  change. (Lachesis)
+ COPY can now take + and # prefixes to its arguments. COPY
  BLOCK and COPY OVERLAY BLOCK can now take + prefixes to their
  first set of coordinates. (Lachesis)
+ Subroutine versions of TOUCH, BOMBED, INVINCO, PUSHED,
  PLAYERSHOT, NEUTRALSHOT, ENEMYSHOT, SHOT, PLAYERHIT, LAZER,
  SPITFIRE, GOOPTOUCHED, PLAYERHURT, KEY[char], KEYENTER, THUD,
  and EDGE have been added. These should ALWAYS be used in
  conjunction with LOCKSELF/ZAP and #RETURN or #TOP to keep the
  robot stack under control.  Please remember that THUD and
  EDGE ignore LOCKSELF and their subroutine versions must be
  ZAPped. JUSTENTERED, JUSTLOADED, and the sensor labels have
  been excluded from this due to various reasons. (Lachesis)

BUGFIXES

+ Fixed a bug where LOAD_ROBOT or LOAD_BC would not reset the
  stack pointer for newly loaded programs. This could cause
  crashes if a robot popped the stack in the new program.
+ Fixed a bug where range checking of BOARD_X and BOARD_Y would
  sometimes not be done correctly, leading to crashes.
+ Strings in the debug menu list no longer interpret any color
  codes they may contain.
+ Fixed a bug where a string would not be interpreted correctly
  if it used a '.' character in a splice parameter expression.
  Expressions such as IF "$str#('$str2.length'-4)" = "blah"
  THEN "label" will now work correctly.
+ Fixed negative sprN_cheight et al from crashing. (Exophase)
+ Placement of objects on the player will be blocked with an
  error dialog like DOS versions, instead of silently failing
  after setup. (MZXGiant)
+ Fixed a bug where LOAD_ROBOT would not properly parse lines
  of imported code that had leading whitespace. (MZXGiant)
+ Fixed an integer wrapping bug in debytecode, disallowed
  numeric literals outside of the bounds of a signed short.
  (MZXGiant)
+ Fixed a bug that would corrupt the UI palette if "set color"
  was run against a color index over 15. (MZXGiant)
+ If either board dimension is less than the editor viewport,
  the character and colors used to indicate space outside of
  the board are taken from protected sets. In game, they are
  taken from the game's sets.
+ Increase limit on difference for RANDOM "A" TO "B" to
  UINT_MAX rather than INT_MAX - 1 as it was previously. Since
  the entire range represented by a counter is now usable,
  there are no cases where RANDOM will "break".
+ Fixed avalanche rings and potions to limit boulder placement
  to 1/18, matching the AVALANCHE command.
+ Fixed corruption and possible crashes when using VIEWPORT
  SIZE to set the viewport to a size less than 80x25 but
  greater than the current board dimensions. The viewport will
  now always be clamped to board size.
+ Fixed incorrectly changing horizontal mouse position on
  setting MOUSEY. (Mr_Alert)
+ Fixed overflow into protected character set when "Revert
  to..." is selected in the character editing dialog.
  (MZXGiant)
+ Music and SFX now mute when the updater launches and are
  restored when it is complete. (MZXGiant)
+ Fixed odd string behaviour when copying between strings that
  happen to be stored close to each other in memory. This fixes
  a regression introduced by the "crash when pasting to and
  from the same string" fix in 2.82b.
+ The size/offset parameters for strings can now be specified
  in either order (#+ vs +#) and will behave correctly.
+ Reverted bogus cycle-ending behaviour for SHOOT,
  SHOOTMISSILE, SHOOTSEEKER and SPITFIRE.
+ Improved cycle-ending compatibility with MZX versions prior
  to 2.80. Fixes games such as Kya's Sword and Stones & Roks
  II.
+ Restored shark's ability to move in goop.
+ MZX now clears SPR_YORDER upon loading a new world.
+ When transitioning between boards, MZX now compares the
  module filenames of the source and destination boards
  case-insensitively. A difference in case will no longer cause
  the board module to be incorrectly restarted.
+ Fixed rare rendering corruption in the load game dialog.
+ Fixed a bug where SEND "robot" TO "#return" could corrupt the
  program counter of the target robot if it had a stack pointer
  of zero.
+ Fixed some security issues with SMZX_PALETTE and LOAD_BC
  counters.
+ MZX now only lists/opens regular files or symlinks to regular
  files in file dialogs. Special files are now ignored.
+ Opening directories with FWRITE_OPEN is now rejected properly
  on all platforms.
+ Fixed a bug where a file would be re-opened for read/write,
  even if the file was missing or an I/O error occurred before
  saving.
+ Fixed a bug where MZX could occasionally crash due to label
  list corruption when copying robots from heap locations
  greater than 2^32 bytes apart (only affected 64bit builds).
+ Stopped SET "var" <command> from assembling. Some invalid
  uses of command tokens were already being ignored, but this
  was just luck.
+ Sprites with color c?? (inherited "natural" colors) will
  correctly inherit the colors of special characters such as
  the player and other self-colored built-ins.
+ Debytecode's legacy expression converter should use
  is_string() instead of its own (buggy) hand-rolled version.
  Fixes crash when converting CoAZ.
+ The editor no longer incorrectly clamps the intelligence of
  sharks, spitting tigers and spiders to <=4, and no longer
  clamps the HP of dragons to <=4. (Lancer-X)
+ MZX now accepts SET EDGE COLOR "string" in addition to SET
  EDGE COLOR c??.
+ Fixed NDS port initialization on DSi devices. (asiekierka)
+ Fixed a bug in the joystick code where centering an axis
  clears the previous axis button. (iamgreaser)
+ Fixed a bug that allowed vlayer->board COPY BLOCK to
  overwrite the player. Blocks that would overwrite the player
  are now ignored.
+ Fixed a 2.81e regression that allowed SENDs to self to ignore
  LOCKSELF.
+ Setting $str.length now makes $str the length specified.
  (Lachesis)
+ Caps Lock no longer interferes with dialog box text input.
  (Lachesis)
+ Increasing the size of a string with $str.length, $str.N, or
  with a splice now wipes old string data with char 32s.
+ Dialogs (especially "Exit gameplay - Are you sure?") now
  require the user to have actually hit ESC to close, making
  escaping busyloops and message loops much easier. (Lachesis)
+ Added a compatibility fix for different label caching in 2.80
  through 2.83 that allowed constructs such as : "LABEL" / SEND
  "ALL" "LABEL" on an unlocked robot to continue instead of
  getting caught in a loop. The altered label caching caused
  #98485 Thanatos Insignia to lock up in an unescapable
  busyloop in GIT versions. (Lachesis)
+ MOD "[lead-in file]*" now works properly. In previous
  versions of the port, this construct would result in the
  lead-in file failing to play and the wildcard mod restarting
  when the player re-entered and re-exited the board.
  (Lachesis)
+ Fixed a bug where mod "*" would cause the mod to restart when
  entering another board with the same playing mod. (Lachesis)
+ ALT+D (Default palette) now requires a confirmation.
  (Lachesis)
+ The COMMANDS counter is now saved as a 32-bit variable.
  (Lachesis)
+ The LOOPCOUNT counter has been moved to save-only data and is
  now saved as a 32-bit variable. (Lachesis)
+ Fixed a bug where not all whirlpools were being considered as
  such, notably during the transport board scan. (Lachesis)
+ The abilities of PLAY "&file&" to play at multiple
  frequencies and to parse multiple files have been restored.
  (Lachesis)
+ As of MZX 2.84, BOARD_COLOR will now ignore the under color
  of any object with a BG color of 0 that is on top of
  something.  Worlds that relied on this between 2.80 and 2.83
  are unaffected. (Lachesis)
+ Setting BIMESG to 0 will now disable Game Over's
  auto-centering of the message row. (Lachesis)
+ The DIVIDER counter's documentation has been updated to
  explain its true purpose.
+ Fixed an editor bug where canceling a world load could cause
  MZX to forget the filename of the current world. (Lachesis)
+ Pressing ALT+M in the world editor now edits anything with
  parameters, not just Robots, Signs/Scrolls, and Sensors.

DEVELOPERS

+ Source tarballs are now generated in XZ (LZMA2) format.
+ Make hlp2txt utility work correctly on Windows platforms.
+ Updated and repaired MSVC project for Visual Studio 2010.
  (MZXGiant)
+ Win32 binaries are built ASLR-capable (via pefix).
+ Version control was changed from SVN to Git; the repo is at:
  http://github.com/ajs1984/megazeux
+ The EGL backend now supports Mesa's EGL implementation on
  X11.
+ Imported libmodplug 0.8.8.4 and rebased all patches.
+ Introduced SOCKS4/4a/5 support transparently into the network
  layer. (MZXGiant)

>#2823CLOG.HLP:283:New in Versions 2.82 to 2.83
>#281CLOG.HLP:281:New in Versions 2.81 to 2.81h
>#280CLOG.HLP:280:New in Versions 2.80 to 2.80h
>#OLDERVER.HLP:099:New in Versions 2.60 to 2.70
>#OLDESVER.HLP:100:New in Versions 2.01 to 2.60
>#NEWIN200.HLP:1st:New in Version 2.00
>#ANCENVER.HLP:103:New in Versions Through 1.03
>#MAIN.HLP:072:Table of Contents

#2823CLOG.HLP
:283:
$~9New in Versions 2.82 to 2.83

December 29, 2009 - MZX 2.83

It's been a year since the last release, due in part to my
reduced free time, and less contribution from other developers
in 2009. I'd also like to believe that 2.82b was such a good
release, there was no need to rush.

There's over 30 bugs fixed this time. A few features I had to
withhold for 2.82b have been added; sample loop markers and
some changes to the board file format necessitated the bump to
2.83. Logicow's GLSL renderer has finally made it in (various
bits had to be re-written to extend portability to other
platforms).

There's a new (semi-complete) Android port this time; I hope to
complete it, and provide binaries for Android 2.0 phones, in
2.83b.

Thanks go out to the usual suspects -- Terryn, Mr_Alert,
Logicow, kvance, Lancer-X, revvy and Exophase -- for supporting
development this year.

USERS

+ Added support for loop markers in WAV and OGG files. The WAV
  loop support uses the "smpl" chunk used by ModPlug Tracker
  and Wavosaur among others. Only the first loop is used, and
  only forward looping is supported. The OGG loop support uses
  the "LOOPSTART" and "LOOPLENGTH" tags as used by RPG Maker
  VX. (Mr_Alert)
+ Added OpenGL Shader Language (glsl) renderer which uses
  shaders to render and scale the video. This renderer is
  compatible with Open GL >=2.0 and Open GL-ES 2.0 video cards
  only. A variety of shader programs have been provided and
  these can be customized. Performance of all MZX modes
  (including SMZX) is excellent. (Logicow, ajs)
+ Files will no longer be silently overwritten by save dialogs
  if the user enters an existing filename without the default
  extension. (revvy)
+ The string editor in the counter debug menu (F11) now escapes
  newlines and backslashes to prevent UI corruption.
+ Fixed a bug where the LOAD_GAME counter handler could
  continue to use the old board state after load, causing
  crashes. (Lancer-X)
+ Fixed a bug where status counters containing numbers >6
  characters would cause MegaZeux to crash or behave strangely.
+ Fixed a bug in the robot editor's find/replace function that
  caused crashes when replacing a string with another longer
  string, with a replacement at the end of a line.
+ Programmatically writing to a read-only "built-in" counter
  will no longer allocate it general heap space. This prevents
  writes from showing up in the F11 counter debugger that are
  inaccessible from robotic.
+ Fixed a bug that caused the SMZX mode 3 palette to become
  corrupted upon entering the char editor (the editor would
  re-write colours 2-4 and not restore them from backup
  correctly).
+ Fixed a bug where a robot program would never progress if the
  subroutine stack was popped more times than it was pushed
  (via return or top).
+ On UNIX platforms a desktop/menu entry is now installed by
  default, using the existing icon. (Sci-freak)
+ Clamp score to >= 0 if world <= 2.70. Fixes "Gates: The
  Puzzles" and possibly other old titles depending on this
  behavior. (Exophase)
+ Fullscreen modes will now automatically use your current
  desktop resolution if using any hardware renderer (i.e. not
  the default software renderer). To get the old behaviour back
  you must set fullscreen_resolution explicitly.
+ Fixed a bug where web and thick web would be treated the
  same.
+ Fixed a bug in the updater where modified/replaced files
  would be considered for deletion.
+ Fixed a bug on case-sensitive filesystems where saving a
  game, world or MZM could fail to overwrite any existing file
  by the same name (if matched case insensitively).
+ MZX no longer applies masking to chars 32-127 in signs or
  scrolls when playing a world. Previously, even the 
  mask_midchars option would have no effect on the display of
  signs or scrolls. This has been broken since 2.80g.
+ Re-worked board editor's Alt+H option to provide minimal
  editor (one row) status info, rather than completely hiding
  the help.
+ The checkres utility now checks the global robot for missing
  resources too.
+ Chests can be added with Hi Bombs (omission noted by zzo38).
+ Fix IF c?? Sprite p?? # # "label" so that a non-wildcard
  parameter is respected (previously it would always just check
  sprite 0).
+ NDS port updated from dsmzx2 release. (kvance, ajs)
+ Updated SDL to 1.2.14 in Windows x86, Windows x64 and Mac OS
  X builds.
+ Security checks are no longer applied to filenames in module
  or sample playback in "listening only" modes in the editor.
+ Module volume is applied immediately before playback upon
  switching boards. This prevents one cycle of audio "leaking"
  at the wrong volume.
+ Prevent crash with negative string clip where clip + offset =
  0. Clip is now correctly limited to total string length.
+ Help file is now optional for MZXRun, even with
  CONFIG_HELPSYS=1 builds.
+ Fixed crash when robot editor macros expanded other macros.
+ The lock icon is no longer missing from the Items THING menu
  (F4).
+ A world to start up with can now be passed to MegaZeux
  without the startup_file= prefix. This makes megazeux
  consistent with other applications.
+ SHOOT, SHOOTMISSILE, SHOOTSEEKER and SPITFIRE now end the
  cycle, to restore compatibility with pre-port MZX and fix
  games such as Kya's Sword and Stones & Roks II.
+ Have IF [dir] PLAYER [color] [thing] [param] "label"
  interpret SEEK direction wrt robot coordinates, rather than
  player coordinates. Other directions are not affected.
+ Zapping a label at the end of a robot program will no longer
  corrupt the robot list (which usually caused crashes).
+ Entering lines in the robot editor with leading or trailing
  spaces will be trimmed before the line is compiled.
+ The single quote characters encasing S_CHARACTER parameters
  in the robot editor will now use the protected (GUI) charset
  rather than the game one.
+ Added a "system_mouse" config.txt option that allows the
  mouse cursor to be replaced with the system mouse cursor,
  rather than being drawn by MegaZeux.
+ Disallowed placing player clones with SET "board_id" 127.
+ Relaxed file name limit on board MOD file. The board MOD can
  now be as long as the limit imposed by file dialog's input
  box (previously limited to 12 characters).
+ Truncation of currently open input/output file names will now
  only occur at MAX_PATH bytes (typically 512 characters). The
  previous limit was 13 characters.
+ Relaxed limit of INPUT string and bottom ("*") messages from
  80 characters to ROBOT_MAX_TR (512) characters. In the case
  of bottom messages this can be usefully exploited to ~~200
  characters.
+ Progress meter will be shown for world decrypt on console
  platforms.
+ Fixed a bug where a malformatted BMP header would be written
  (length too short, didn't include dummy channel in BMP
  palette). (Mr_Alert)
+ Optimized audio locking; do file I/O outside of critical
  sections to decrease stalling, particularly on platforms with
  slow I/O. (Mr_Alert)
+ Added support for MacOS 10.6 (Snow Leopard) and removed
  support for 10.3.
+ Loading a save game from robotic will now correctly restore
  intensities to their saved values.
+ Copy/pasting a block either with COPY BLOCK or the editor,
  where the copy would exceed the limit on robots/signs/scrolls
  /sensors, will no longer place junk at the target
  co-ordinates. Instead, the object's background will be copied
  in isolation.
+ Pasting from the clipboard, expanding a macro,  or importing
  .txt or .bc files that would cause a robot to exceed the 64k
  limit now has the operation ignored at the point it exceeds
  the limit, rather than adding an unlimited number of
  unrecognized lines.

DEVELOPERS

+ MZXRun compilation can now be disabled. Compilation of
  pre-2.82b style non-modular builds requires
  `--disable-modular --disable-mzxrun'.
+ Disabling SDL can now be done with --disable-sdl and the
  resulting configuration will automatically disable any
  SDL-dependent components. This is useless to anybody except
  developers doing new ports.
+ Game directory, utility directory and resource directories
  can now be specified and will be respected on "make install".
  (Sci-freak, ajs)
+ Added experimental port to Android. See arch/android/README
  for more information.
+ Ported opengl1 and opengl2 renderers to OpenGL ES 1.x and
  glsl renderer to OpenGL ES 2.0, used increasingly by mobile
  devices.
+ Removed SDL dependency from NDS port. It only used it for
  timing and stuffed events.
+ On Windows platforms, binaries are processed with the `pefix'
  in-tree tool to eliminate data section differences in
  programs with identical texts. This minimizes the amount of
  content required to be sent for updates.
+ Updated Wii port: improved audio and video support, added USB
  mouse support, numerous optimizations and improved file
  selector. (Mr_Alert)
  
>#MAIN.HLP:072:Table of Contents

December 29, 2008 - MZX 2.82b

This release contains plenty of important bug fixes, ranging
from regressions such as the broken command-line editor macro
expansion to third party bugs like the Windows "directx" SDL
video driver breakage.

There are also some new ports and features. MegaZeux now runs
on the Wii (port by Mr_Alert) and AmigaOS 4.x (port by myself
and Spot from os4depot). The Windows x64 port has matured
immensely and can now be considered stable. MacOS X builds now
have clipboard support. The hardware stretching renderers now
have a couple of fixed aspect ratio modes.

The biggest feature of this release is the introduction of a
portable network layer, which is currently being tested by the
new built-in updater (F7/U).

Internally, MegaZeux is now modularized and builds as several
DLL and EXE files, which should make redesigning parts like the
help system and editor a little easier, as well as allowing us
to ship a "mzxrun" executable for the first time since 2.69c.
This "mzxrun" executable is now used by a majority of the
console ports.

Contributions from Revvy, Mr_Alert, Terryn and Exophase have
helped make this another solid release.

USERS

+ Writing to $str.length (which previously did undefined
  things) will now truncate or enlarge the string to the size
  specified.
+ Removed filename size limit for FWRITE_MODIFY and
  FWRITE_APPEND. (Revvy)
+ Added support to the checkres tool to check worlds in
  non-local directories. (Revvy)
+ Fixed an old bug with saving games and worlds from Robotic
  where a board could be prematurely "optimized", renumbering
  robot IDs within the same cycle. For commands like DIE this
  could cause unpredictable behaviour or simply crashes (if
  invoked in the same cycle). As a special case, end the cycle
  if either of these SET specials are used.
+ Mistaken or malicious file I/O such as set "$test" to
  "fread(-1>>1)" will no longer crash MegaZeux. The read size
  will be truncated to a contextual maximum for the current
  file.
+ Fixed a crash using "fwrite0" in conjunction with an empty
  string.
+ Fixed a bug where checking sprite_collisions on a disabled
  target sprite would unconditionally trigger (regardless of
  whether a collision was present or not).
+ Un-grouped the handling of the KEY and KEYn counters so that
  different compatibility checks can be applied to either
  counter. Fixes "Bocco Chronicles 1" and probably several
  other titles.
+ Fixed a crash when using RIDn or ROBOT_ID_n in the same cycle
  as DIE for another robot positioned earlier in the board
  scan.
+ Fixed poor sanity checks on BOARD_ID counter writes. Illegal
  character IDs such as -1 can no longer be used to bypass the
  check (causing subsequent crashes).
+ Windows builds now use a patched version of SDL 1.2.13
  containing a fix for the directx+F10 issue.
+ Fixed a bug where one robot could send another robot to
  "#return", with an address outside its program. In such
  cases, the robot will now terminate.
+ An "mzxrun" binary is now shipped alongside the
  editor-capable MZX binary.
+ Fixed TIME/TIMERESET overflows with very large values. Board
  timeout is now programmatically limited to 32767, which is
  consistent with the Board Info control.
+ Clamped CHAR_X/CHAR_Y properly so that negative numbers can
  no longer be used to corrupt the editor charset and
  potentially other process memory.
+ Fixed recent breakage of SHIFT+F{1,2,3,4} so that the
  percentage of time spent displaying the original character
  and the '!' are equal.
+ Removed some bogus handling of lines containing "only" ';',
  ',' or ' '.
+ Honor user's robot character selection if they are holding
  shift when pressing return or space (would previously always
  return char 247).
+ Backspacing a line and then expanding a macro no longer
  restores the original line contents immediately after the
  expansion.
+ MacOS 10.x clipboard support (via Cocoa Pasteboard). Alt+Ins
  can be entered with Fn+Alt+Numpad0 on a Macbook or Powerbook
  keyboard.
+ Robot editor S_CHARACTER fields no longer bogusly escape
  characters such as ". In addition, rendering glitches are no
  longer encountered when using the ' S_CHARACTER (which is
  completely reasonable).
+ Fixed robot editor glitches where the game charset SPACE
  would be used in places where the protected UI charset should
  be used instead.
+ The introductory help message is displayed if the load dialog
  is cancelled prior to loading a game. Hopefully the screen is
  now never totally blank.
+ The F7/F8 cheats can now be used freely in MZXRun (in
  MegaZeux proper they remain usable only in editor tests).
+ Saving to a directory above the MegaZeux startup directory,
  then attempting to save to this location again, will no
  longer crash MegaZeux. Instead, the parent directory will be
  changed into before the dialog is displayed.
+ Fixed numerous crash bugs with the scroll editor; it should
  be relatively usable now.
+ Writing to $str+0 is no longer interpreted in the same way as
  a plain write to $str. Instead, it behaves like writes to
  non-zero offsets (as more of a paste than a replace).
+ Display of current X,Y position of robot in the robot editor
  status bar.
+ Fixed directory rename so that it no longer displays garbage
  and/or crashes MegaZeux (Alt+R to rename a directory in any
  file picker).
+ In the robot editor, lines can now be split at a midpoint
  with enter and two consecutive lines merged together with
  backspace. (Exophase)
+ Fixed use of status counter 6 and display of status counters
  in general, which has been broken since 2.80.
+ Fixed swapping to encrypted worlds if initially the user
  decides to not decrypt the world. Previously, this would
  either crash, or loop forever.
+ When using the OpenGL or overlay renderers, in either
  windowed or fullscreen mode, the aspect ratio can now be
  preserved as either 4:3 (most similar to DOS) or 64:35 (most
  similar to the port). The display will be letterboxed or
  margins applied as appropriate. See the "video_ratio"
  configuration option for more information.
+ Fixed a bug on some systems where numlock could not be used
  as a key, only as a flag. The numlock "key" is now masked out
  of "key_code" and similar; hopefully this won't break any
  games.
+ Restored the meter widget from the old DOS MZX for use with
  the world loader and saver routines. This reassures users,
  especially on consoles, where loading a world can take a long
  time. (Mr_Alert)
+ On Windows, directx.bat now passes %cd% through to `start' so
  that features such as the updater continue to work.
  (MZXGiant)
+ Pasting into a string with set "$str+N" with an N > 
  str.length will no longer crash MZX.
+ "Exit to DOS" is now "Exit MegaZeux" to reflect the
  multi-platform nature of the program.
+ Setting a substring size to zero with $string#0 will no
  longer return the whole string; it will instead return the
  empty string.
+ Accessing a substring with an offset >= $string.length will
  no longer return the last character from the string; it will
  instead return the empty string.
+ Writing beyond MAX_STRING_LEN (1MB) or using negative offsets
  (which has the same effect) no longer crashes. Instead, the
  write is ignored.
+ Fixed crash when pasting to and from the same string,
  specifically in conjunction with $str+offset.
- Removed the legacy "force_resolution" option which was
  replaced long ago by the more accurate
  "fullscreen_resolution" option.

DEVELOPERS

+ Ported to OpenSolaris. You need to install `SUNWxorg-headers'
  if you want X11 clipboard support.
+ Removed dependency on SDL_image on non-win32 platforms when
  enabling the icon branding feature (see pngops.c).
+ Ported to AmigaOS. You need to install the clib2 version of
  libSDL and miniGL, and the build system assumes you are using
  a cross compiler.
+ Added experimental port to the Wii. See arch/wii/README for
  more information. (Mr_Alert)
+ get_path() in util.c now returns <0 for failure, or the
  length of the path for the given file. (Revvy)
+ Added the make time WHOLE_PROGRAM=1 flag which enables
  compilation of the core binary in GCC's "-fwhole-program
  --combine" mode. This makes all symbols static and improves
  optimization, somewhat like MSVC's LTO does.
+ Added a valgrind.supp file to suppress bugs in third party
  libraries when valgrinding MegaZeux.
+ Cleaned up all the ports and documented making new ports. The
  platforms "linux", "solaris" and "obsd" are now called
  "unix", and the "linux-static" platform is now "unix-devel"
  and available on all UNIX derivatives/clones.
+ Added a special hack to enable linking with --as-needed for
  DT_NEEDED link optimization for GNU ld platforms.
+ Updated MSVC projects. Fixed all warnings emitted by MSVC
  2008, and implemented icon support with existing mingw
  resource files.
+ Now uses the GNU ld "debuglink" feature on all platforms to
  enable shipping of a side-by-side symbol package. Optimized
  release builds can now be debugged with minimal user effort.
+ MegaZeux now provides the option for "modular" linkage,
  factoring out the "core", "editor" and "network" features to
  shared objects that other binaries can link against. This
  feature works on the unix, mingw, amiga and darwin ports.
+ Added RPM .spec file. Capable of building (at least) Fedora
  10 RPMs.
- Removed HOST_CC feature for cross compilation; since the
  utilities now intimately depend on the MZX runtime, they must
  be built with the same compiler.
  
>#MAIN.HLP:072:Table of Contents

June 10, 2008 - MZX 2.82

Despite the increase in minor version, this release mostly
targets bug and regression fixes. However, there ARE some
additional new features, such as the introduction of the
LOAD_MENU and mouse pixel counters, and refinement of the
{FREAD,FWRITE}_COUNTER counters. (There are several other
smaller features that are documented in the changelog.)

SAVs from older worlds (requiring compatibility hacks) no
longer fail to play (Darkness, etc. are affected). We've also
done a good bit to fix compatibility with 2.70 and older.

A new tool, "checkres", is now routinely packaged, allowing you
to check your games for missing resource files (PALs, CHRs,
etc.) before passing them on to other people. This should be
especially handy for DoZ game submissions.

The Nintendo DS port (Kevin Vance's "DsMZX") has been merged
into this release. I'll provide binaries for GP2X, PSP and NDS
this time, but I can't guarantee they'll work.

Both of the snags from the last DoZ have been addressed -- the
help system should no longer crash and the Block Action crashes
should be reduced in frequency. However, there are still issues
with pasting in the robot editor that remain unfixed (they're
just really hard to reproduce). With your bug reports, I look
forward to fixing this.

As usual, thanks go out to Revvy and Mr_Alert for their
contributions to the bug-fixing effort, and to Terryn for his
unwavering dedication to creating and organising bug reports,
and for testing our bug fixes.

USERS

+ Fixed and improved quality of the half-width renderer for the
  GP2X port (Mr_Alert).
+ The numpad now works correctly when numlock is disabled. Keys
  are no longer ignored by the MZX editor, and games should
  recognize them as before.
+ Added a tool, "checkres", which extracts all resources from a
  MegaZeux world or board file and lists them (or lists only
  those which are not found in the game directory). ZIP files
  are also supported (to a more limited extent). (ajs & Revvy,
  ideas from Exophase & Terryn).
+ Removed the bogus "F1 for Help" option from error dialogs,
  and finally got rid of the "** BETA **" banner on title
  boards in play mode.
+ Obsoleted support for the AMS, DBM, DMF, MDL, MT2, PSM, PTM
  and UMX module formats. As noted for several versions in the
  help file, these are not loadable by MikMod. It is extremely
  unlikely any game uses these obscure formats, but denying
  their use is now enforced (at a robotic level).
+ Fixed crash when writing to an MZX string at an illegal
  offset (< 0).
+ Fixed returning from a subroutine invoked by a jump from a
  MZX text box class command so that it no longer skips the
  next impending line (after the text box).
+ Assembled single non-alphanum/punctuation characters as
  bytecode CHARACTER instead of bytecode STRING. Fixes bogus
  auto-quoting for commands like SCROLL CHAR (Revvy).
+ Switched the Win32 package back to using the "windib" SDL
  video driver, instead of the "directx" SDL video driver. The
  windib.bat file has been replaced with directx.bat, which has
  opposing semantics.
+ SAM/GDMs with converted WAV/S3M counterparts of zero length
  will be automatically re-converted. This hack can be used to
  procedurally regenerate WAV files from SAMs, or transparently
  work around on-disk corruption.
+ Strings are now limited to a maximum length of 1M. I'm open
  to suggestions over a better limit, but there must be a limit
  (set "$string.X" notation grows a string arbitrarily, so
  robotic can crash MZX when a string is resized beyond a
  reasonable limit).
+ Strings, when grown, will fill gaps with ' ' instead of
  garbage. This can be useful when the string grows after using
  the set "$string.X" notation; the rest of the string is no
  longer garbage, allowing the debugger to be used.
+ A robot that does a "put c?? Thing p?? [dir] player" and
  overwrites itself will no longer leak commands. Instead, if
  the robot overwrites itself, its program will end.
+ Fixed message edges always showing up black, instead of 
  whatever color 0 is. (Revvy)
+ Changed starting/max health and lives minimum to 1 instead of
  0. (Revvy)
+ Some help system (F1) bugs have been fixed, hopefully
  mitigating some of the crashes people have been seeing.
+ Fixed a bug on Linux where fclose() on a robot-opened file
  could, on world reload, occassionally crash (due to a stale
  handle). Fixes loading Taoyarin saves multiple times in a
  row.
+ The new option "gl_vsync" has been added to allow the SDL
  "flip on vsync" in the OpenGL renderers to be forcibly
  enabled or disabled. This fixes a problem where speed 1 would
  only be as fast as the video refresh rate.
+ Setting the music volume to 0 (when using the ModPlug engine)
  now ensures that no music is audible. Previously, setting the
  volume to 0 would be equivalent to setting the volume to 1,
  which was still audible.
+ Upon exiting the initial load screen, and not entering the
  editor, the screen is now updated. This fixes rendering
  glitches in the MZX game window when overlapping the window
  with another, at the slight expense of CPU time.
+ If loading a save game from the title screen (or when no
  world has been loaded) MZX no longer sends JUSTENTERED to all
  robots. This restores compatibility with MZX 2.70 and is
  consistent with loading a save from another board.
+ Counters with 10 digits and a negative sign are no longer
  truncated in the debug menu.
+ Correctly clamped (rather than truncating) the value passed
  through to a SET COLOR. Restores compatibility with 2.70, and
  fixes Xenogenesis.
+ Improved clipboard copy behaviour on Linux. Some actions are
  still mysteriously broken.
+ Fixed replacing with a blank string in conjunction with the
  replace all Ctrl+F action in the robot editor. The cursor can
  now no longer become negative, fixing numerous possible
  crashes on search/replace.
+ Fixed loading the intrinsic SMZX palette when switching to
  SMZX modes from a game not in the same directory as the
  "smzx.pal" file.
+ Reloading a world that requires switching between SMZX and
  non-SMZX modes will now respect the world's intrinsic palette
  on the title screen. Fixes problems loading non-SMZX games
  after having an SMZX game loaded.
+ Clamped array offsets on boards. Some older MZX worlds are
  corrupted and have the endgame_{x,y} coordinates outside of
  the limits of the endgame board. Fixes "Fourth Power".
+ Where possible, versioned all counters that the port
  understands. This ensures that in the unlikely case that a
  game made with an older version of MZX (actually, with an
  older world magic) uses a counter that did not exist in that
  game's era, the port will no longer try to interpret it.
  Previously, only rid? and key? were versioned.
+ SAV files will now be stamped with the world magic of the
  world they were loaded from. This allows compatibility hacks
  to apply to SAV files as they would to worlds (ajs, Terryn,
  Mr_Alert).
+ Added LOAD_MENU counter like ENTER_MENU, F2_MENU et al. to
  allow control (from Robotic) over whether the LOAD_MENU can
  be brought up.
+ Made FREAD_COUNTER and FWRITE_COUNTER read in a DOS dword
  (32bit) instead of a DOS word (16bit). This allows modern
  post-port MZX counters to be fully represented in files.
  Compatibility with older worlds is preserved.
+ Added a new config option "board_editor_hide_help" which
  changes the default hide setting of the help text on the
  primary board editor.
+ Numerous fixes for bugs found by valgrind. (Nightwatch)
+ Icon support is now fixed and works on all platforms. On
  Windows, the icon cannot currently be changed (it is loaded
  from the EXE's resource section). Use ResHacker if you really
  want to change it.
+ Fixed a bug where either LOAD_ROBOTn or LOAD_BCn (where n was
  equal to ROBOT_ID) would alter the robot's line number rather
  than completely restart it. Due to complexities in robot
  context, this lead to the first line being skipped.
+ Added a new tool "downver" which supports drag-and-drop
  downgrading of a world or board from the version of MZX it is
  packaged with to the previous version of MZX. This tool may
  be unsafe to use -- be careful.
+ Fixed a bug in the robotic assembler which would
  occassionally emit corrupt programs with SAVE_ROBOT. These
  programs, if loaded by LOAD_ROBOT, could cause a crash.
+ Added a config.txt (or command line) option "startup_editor"
  which, if set to a non-zero value, will start MegaZeux in the
  editor with a blank world.
+ Fixed a bug where a robot's WALK processing, on entering a
  transporter, could allow subsequent commands (such as GO) to
  corrupt the board. WALK now ends the cycle in the special
  case that a robot goes through a transporter.
+ You can now directly import bytecode into the robot editor
  via the Alt+I menu. The extension for the bytecode file must
  be .bc for it to be loaded.
+ A game loading SAVs via the LOAD_GAME counter will no longer
  crash MZX if the SAV attempted is from an incompatible
  version of MZX, or in any way corrupted.
+ Fixed a crash when auto-completing lines that were greater
  than 241 characters in length after completion.
+ Added mouse pixel counters MOUSEPX and MOUSEPY. (Mr_Alert)
+ Commenting a line of maximum length (241 characters) can no
  longer grow the length of the line beyond this limit.
+ Fixed a bug causing the software renderer to fail to center
  when using a boxed fullscreen resolution. Also fixes a bug
  where the PSP platform would ignore an override of the
  force_bpp option. (Mr_Alert)
+ Fixed a bug causing macros loaded from config.txt to be
  expanded incorrectly. Relatedly, fixed a bug where #<string>
  in the robot exitor would "disappear" on entry, if there was
  no correspondingly named macro.

DEVELOPERS

+ Builds no longer initialize the SDL audio subsystem if audio
  is permanently disabled with --disable-audio.
+ Added fixes for OpenBSD to allow PNG screenshots and X11
  clipboard support to work. Tested with OpenBSD 4.2 and 
  GCC 3.3.5.
+ Updated Win32 builds with SDL 1.2.13.
+ Build and package two utilities, txt2hlp (for helpfile
  generation) and checkres, on Win32.
+ Dependencies are now correctly tracked in the build system.
  Modifying a header will automatically regenerate the minimal
  set of object files that depend on this header.
+ Out of the box MSVC support. The file "msvc.zip" in the root
  of the source package now provides a Visual Studio 2005
  project and pre-compiled dependencies. There may be stability
  issues with the resulting binary. See also the documentation
  in arch/msvc/README.txt.
+ The Nintendo DS port (a.k.a. 'dsmzx') has been merged. This
  is the most exotic port thus far, and adds features such as
  player focus (on the second display). Sound isn't working
  yet, and large games still won't play (due to lack of
  memory). See docs/nds.txt for more information. (kvance)
+ Many stack-heavy functions have been de-bloated and allocate
  large storage on the heap (if performance is not critical).
  This helps out platforms with a small, fixed stack size (such
  as NDS).
+ The built-in help system can now be disabled for embedded
  platforms. The startup check for the help file will not be
  performed if the help system is disabled, and so this file
  can be omitted from distributions.
+ The package.sh script now supports OS X, PSP, GP2X and NDS
  packaging.
+ The OS X port no longer requires Xcode. The new build system
  and package.sh can create a universal Application and
  corresponding DMG file. The new infrastructure deprecates the
  old macosx.zip method.
+ Most of the internal dependency on SDL has been removed.
  Therefore, MZX can be built (but not yet work) without SDL
  present. The only remaining component to convert is MikMod,
  but this can be disabled, so port authors can start using the
  feature right away (see config.sh). (Mr_Alert)

>#NEWINVER.HLP:1st:NEW in MegaZeux!
>#281CLOG.HLP:281:New in Versions 2.81 to 2.81h
>#280CLOG.HLP:280:New in Versions 2.80 to 2.80h
>#OLDERVER.HLP:099:New in Versions 2.60 to 2.70
>#OLDESVER.HLP:100:New in Versions 2.01 to 2.60
>#NEWIN200.HLP:1st:New in Version 2.00
>#ANCENVER.HLP:103:New in Versions Through 1.03
>#MAIN.HLP:072:Table of Contents
#281CLOG.HLP
:281:
$~9New in Versions 2.81 to 2.81h

December 8, 2007 - MZX 2.81h

Another bugfix release with a couple of new features, in time
for the Winter 2007 Dualstream Day of Zeux. The major new
features of this release are automatic module renaming in the
editor, PNG screenshots and many improvements to MZX on
embedded platforms (like PSP and DS).

MegaZeux can now be compiled in MZXRun mode (like the old DOS
implementation) and by disabling features such as unnecessary
renderers and audio support, can be made approximately 70%
smaller.

Thanks again to Terryn for relentlessly tracking down many
serious bugs; we've tried to fix all the issues that have crept
up in the last 5 months.

Thanks too to Exophase, Mr_Alert and Wervyn for contributing to
this release; your time and help is invaluable.

Happy Holidays!

USERS

+ Added a more lenient WAV file loader so that ModPlug isn't
  relied on as much to play malformed WAV files (mostly old SAM
  conversions) (Mr_Alert).
+ Added SCORE and mzx_speed to the counter debugger
  (Mr_Alert, ajs).
+ Added a 16-bit software renderer and a half-width renderer
  for the GP2X port (Mr_Alert).
+ Made the mouse cursor in the "opengl2" renderer look more
  like the mouse cursor in the other renderers (Mr_Alert).
+ Setting vlayer_size, vlayer_width or vlayer_height to values
  less than or equal to zero would crash MegaZeux. Limited the
  smallest vlayer size to 1x1.
+ Setting vlayer_width or vlayer_height to a value larger than
  vlayer_size would crash MegaZeux. Limited the largest size of
  either dimension to a maximum of vlayer_size.
+ If selecting a module with a non 8.3 filename, MZX will now
  ask you if you want to rename it to 8.3, and do so in an
  intelligent way. This means that music can be selected in the
  editor and correctly saved (Wervyn).
+ The OpenBSD compiler detected some serious string bugs in
  MegaZeux. These have now been fixed and should eliminate some
  more potential crashes.
+ Fixed a bug where an ENERGIZER item or use of the INVINCO
  counter would cause the original player color to be corrupted
  at the end of the colour blitz.
+ Fixed a long-standing bug where set "$string" to "FWRITEn"
  would be cheerfully ignored.
+ Fixed a bug where a corrupt robot list could crash MegaZeux
  (e.g. the list from Star Quest from DoZ'02).
+ FEATURE: Screenshots are now saved in a palettized PNG file
  format. For platforms without libpng, PNG support can be
  compiled out, and BMP will be used instead.
+ Fixed a bug where changing boards in the editor could
  sometimes corrupt memory, later causing a crash (either
  testing or coming out of testing a board).
+ Fixed a sensor bug that happens when a sensor can't go
  anywhere it is told to, and the player is on it (Exophase).
+ Fixed using ABORT LOOP in some situations. Using it outside
  of a loop still has undefined semantics and this has been
  documented in the help file (Exophase).
+ Setting a board option below its numeric limit is no longer
  possible (Exophase).
+ Fixed problems with going over Robot name character limits
  using the .@@ command (Exophase).
+ Fixed problems with LOAD_ROBOT freezing on a robot with no
  newline at the end of the file.
+ Fixed a problem with "Replace All" in the robotic editor that
  could sometimes cause a line to exceed 240 characters and
  crash the editor.
+ Fixed a problem with "Replace" in the robotic editor which
  could cause a line to temporarily become 241 characters and
  then truncate silently to 240 characters.
+ Fixed a bug that caused the original game palette to be lost
  when testing a game in the editor that switched between
  Regular/SMZX1 and SMZX2/3 modes. MegaZeux should now try much
  harder to preserve the user palette, regardless of game
  edits.
+ Fixed a bug causing board switching to not correctly alter
  the x,y viewport scroll leading to the display of raw memory
  and potential crashes, with differently sized boards.
+ Fixed stack corruption caused by SCROLL CHAR SOUTH, detected
  by Ubuntu's SSP (Stack Smashing Protection) enabled binary.

DEVELOPERS

+ Made the build system less verbose by default (like Linux).
  This should help make warnings (due to coding errors) easier
  to identify. If you don't like the new syntax, or need the
  command debug, you can build with "make V=1".
+ Updated Win32 builds with SDL 1.2.12.
+ Rewrote the build system to not use recursive Makefiles.
  Variable propagation was starting to be a problem, and
  recursive designs are generally discouraged.
+ Refactored the graphics rendering code to modularize the
  renderers and reduce code duplication (Mr_Alert).
+ GDM2S3M switched over to use inttypes.h instead of home-brew
  types.
+ MegaZeux now compiles on OpenBSD (and probably other BSDs).
+ Made all unnecessary global symbols static. This should
  improve compiler optimisations and correctness (Mr_Alert,
  ajs).
+ Fixed compilation of MegaZeux against SDL 1.3 SVN. However,
  this SDL version is still in development, and MegaZeux does
  not work correctly when compiled against it.
+ MegaZeux now builds with the experimental MINGW-x64 branch,
  enabling x64 binaries for Windows.
+ MegaZeux now builds with MSVC if you apply the patch from
  contrib/,megazeux-r326-replace-c99-variable-arrays-with-
  malloc-free.diff . This patch is required for MSVC because it
  makes non-compiler-specific changes (which involve converting
  from C99 variable length arrays to malloc/free) which are
  slower and should not be used with competent C99 compilers
  like GCC. Microsoft Visual C++ Express Edition 2005 was used
  to build libogg, libvorbis, libsdl and MegaZeux itself. Only
  32bit builds were tested.
+ MegaZeux now has size optimisations which can reduce binary
  size when features are disabled. For example, all renderers
  can now be disabled, and when module engines are disabled,
  audio will not export any symbols.
+ The entire audio subsystem can now be disabled. This further
  reduces binary size on embedded platforms. However, SFX
  editing still remains enabled (though useless) until editor
  modularity is implemented.
+ The PSP port is now officially supported, and compiles out of
  the box. See docs/psp.txt.
+ Renamed macos platform "darwin", to reflect its true nature
  (use Xcode to build as a real Application, instead of just a
  UNIX binary). Also fixed some bogosities with robo_ed's X11
  includes on OS 10.5.
+ The editor can now be disabled, a la MZXRUN from the old DOS
  versions. Configure with --disable-editor to shrink MZX by
  about 150k.
+ MegaZeux can now be compiled with size optimisations
  (--optimize-size to config.sh) for a 20% space saving.
+ MegaZeux's core now builds with -W (basically all GCC
  warnings) plus some additional warnings that aren't switched
  on by this flag. All warnings have been fixed.
  
>#MAIN.HLP:072:Table of Contents

July 4, 2007 - MZX 2.81g

Again, no significant new features have been introduced in this
release. However, there have been many essential bugfixes,
including improved compatibility with games made in older
versions of MegaZeux.

Additionally, improvements have been made to the opengl2 and
overlay2 renderers, improving performance for most users. A
port of MegaZeux to the GP2X console has been added. MegaZeux
has been backported to C (rather than C++) and can operate
correctly on a CPU without a floating-point unit.

Particular thanks go out to Mr_Alert (for his valuable bug
fixes), Lancer-X (for fixing what I was too lazy to) and Terryn
(for finding many annoying bugs that nobody else could).

USERS

+ Fixed a bug in the audio code. The linear resampler was not
  taking volume into account, which broke changing the volume
  of samples (WAV and Vorbis) which cannot natively alter their
  volumes.
+ Fixed a regression in the overlay editor caused by the new
  editor space semantics.
+ Screenshots are now rendered to a separate texture using the
  8bit software renderer. This means that the hardware scalers
  will not affect the quality of the screenshot. It also fixes
  a bug when using opengl2, which would dump only a white
  screen.
+ Temporarily reverted a bugfix that broke Zeux IV - Forest of
  Ruin. I'm not dropping the bugfix, I just can't immediately
  see what's wrong.
+ Fixed a bug where setting the viewport to negative
  coordinates would crash MegaZeux. There was code to handle
  this, but it was wrong.
+ Fixed a bug that permitted the mouse y coordinate to be
  warped to row 25, which does not exist. This bug caused some
  of the renderers to crash, and the software renderer to draw
  in memory it did not possess.
+ Fixed a bug where games made before 2.68 could have available
  the "key?" counters, unsupported in that version. This caused
  collisions with counters with the key? name used with
  inc/dec/mul/div/mod. Fixes "Doom Keep".
+ Imported libmodplug 0.8.4, which adds MIDI/PAT and ABC format
  support, fixes some bugs in the mixer, and should build on
  more platforms.
  NOTE: MID files currently cannot be selected in the editor,
  because they do not play correctly.
+ Improved the performance of the "opengl2" renderer, by
  removing the convoluted 3D drawing commands and replacing
  them with 2D ones. Reduced the quad count by using an
  intermediary 80x25 texture. MegaZeux now depends on fewer GL
  features. [LogiCow]
+ Introduced an "fsafegets" to work around problems where
  robots exported by a Windows version of MegaZeux would not
  load on other platforms. This was due to differing EOL style
  and broke at least one game (Termination).
+ Renamed "force_resolution" to "fullscreen_resolution" to
  better match its semantics with the scaling renderers. The
  new name is less accurate for software render modes, but most
  people using software will not want to change it from the
  default anyway.
+ Fixed a bug where the variable-length string allocator would
  prematurely bail out when reading a string (of indeterminate
  length) from a file with the set "$var" to "FREAD" syntax.
+ Fixed a bug where more than 256 errors would crash the
  robotic checker.
+ Improved performance of the overlay2 (faster) renderer
  (Mr_Alert).
+ Made the transparent overlay "really" transparent when used
  in conjunction with sprites (Mr_Alert).
+ Fixed a bug reported by Mr_Alert where MZX would not handle
  short, non-looping mods in the editor. The editor would try
  to destroy the mod again, even after the callback had
  destroyed it (premature termination).
+ Fixed a bug with SWAP WORLD where file translation would
  occur but the result would mistakenly not be used. This broke
  some uses of SWAP WORLD on non-Windows platforms (Mr_Alert).
+ Fixed a bug where using JUMP to MOD ORDER right after
  switching boards would fail due to the board music not having
  been loaded yet (Mr_Alert).
+ Fixed a bug where games made before 2.80 would inadvertently
  trigger "PLAYERHURT" due to using the SET command to reduce
  the amount of health (Mr_Alert).
+ Fixed a bug where player clones were generated when entering
  transports during FREEZETIME (Lancer-X).
+ Debug menu is now eradicated on leaving the editor
  (Lancer-X).
+ Debug menu is now properly painted over when the board size
  is < the editor viewport. Fixes various graphical glitches
  (Lancer-X).
+ Fixed a crash bug when playing older MZX games from read-only
  media (such as a CD) or where file-system permissions
  prohibited creating SAM conversions (Lancer-X).
+ Fixed bug where certain file formats would not be
  automatically converted if their extensions were mixed or
  upper case (e.g. OGG/SAM/GDM).
+ Restored functionality of "if lasttouch DIR" which has been
  broken since MZX 2.02.
+ Fixed a bug where attempting to decrypt a read-only world
  file would result in a crash (Mr_Alert).
+ Fixed several bugs where an error loading a world file would
  result in crashes in several different situations (Mr_Alert).
+ Fixed a bug where a robot using the BECOME command to change
  into a PushableRobot or vice versa would freeze (Mr_Alert).
+ Fixed memory leaks in the file selection dialog, the counter
  debugger, the collision list and the global robot (Mr_Alert).
+ Updated counter list (see docs/counter_list.txt in the
  source) (Terryn).
+ Fixed a bug where pressing escape when editing the effect of
  a ring or potion would result in an invalid parameter which
  would later cause a crash if edited again (Mr_Alert).
+ Fixed a bug in which robot-driven text boxes using option
  commands (the ? command) could overflow by two characters and
  spill over the side (Lancer-X).
+ Fixed the list box searching mechanism (used in the file
  manager and F11 counter list) and made the existing function
  more understandable. (Lancer-X).
+ Fixed a bug in which the message string given to the 'ask'
  command could spill over. Now, the 'ask' dialog resizes if
  possible, and clips when no further resizing can be performed
  (Lancer-X).
+ Clipped the 'input string' message properly, to prevent
  similar overflow.
+ Fixed a bug with the EXPLODE, DIE, DIE ITEM and BECOME
  commands when used with the global robot (would clear the
  global robot, eventually corrupting memory when in the
  editor). Presumably, these commands are bogus for the global
  robot, and have been disabled.

DEVELOPERS

+ Rewrote config.sh to use POSIX sh compatible functions, so
  that there is no dependency on the BASH interpreter.
  Surprisingly, some distributions still don't enable BASH by
  default (using csh, ash or zsh instead).
+ Ported most of MegaZeux back to C. Many more changes were
  required than I anticipated; MZX was using more C++ features
  than I expected. The only exception is audio.cpp, which
  cannot be ported back to C because it uses ModPlug's C++
  classes directly (but I plan to split this file up shortly).
  NOTE: The changes required were enormous, so I might have
  introduced some weird bugs! Please test!
+ Enabled GCC's -W flag for even more warnings, switching off
  unused parameter warnings (useful for delegates). Mostly
  typing fixes, but it found a bug in string handling.
+ No longer suppresses char-subscript warnings, and fixed up
  any remaining abuses in the tree.
+ Added manpages for 'megazeux' and other binaries for the
  Debian packages. Complied with the Debian packaging
  guidelines by providing a copyright note, listing significant
  contributors to MegaZeux.
+ Added support to the build system for supporting icons
  modularly. See contrib/icons/README for more information.
+ The debug build (make DEBUG=1) now enables GCC 4.x's stack
  protector. This breaks compatibility with GCC 3.x, but you
  can just remove the flag if you don't want to use it (the
  stack protector will improve stack corruption detection and
  provide more usable debug traces).
+ Custom Random() implementation to provide a more uniform
  number distribution. Factored out for future (better)
  implementations.
+ The audio backend (audio.cpp) has been modularised to support
  the use of mikmod instead of modplug. This should enable
  ports of MZX to platforms without an FPU, and improve
  performance on platforms with weak FPUs.
+ Added GP2X port to config.sh, based on work done by Simon
  Parzer.
  
>#MAIN.HLP:072:Table of Contents

January 30, 2007 - MZX 2.81f

This release is mostly about the new renderers, the first of
which was introduced in the previous version. There's also a
few important bugfixes, and a lot of internal tidy-up work. I'd
like to thank Mr_Alert, Quantum P. and LogiCow for contributing
to this release. Thanks guys.

USERS

+ Renamed the force_32bpp config option to force_bpp, in
  preparation for 16bit OpenGL render modes. This option now
  takes 8, 16 or 32. 16 is reportedly broken on Windows, so
  stick to 32 for now.
+ Added infrastructure for "pluggable" renderers. This code
  isn't perfect, but it's far better than the mess in 'e'.
  Defaults to the 'software' render mode.
+ Added Logicow's alternative OpenGL renderer. For more
  information about this renderer, see config.txt. NOTE: This
  code may be buggy! Please test!
+ Added Mr Alert's YUV overlay renderers. One does full YUV
  macropixel approximation, the other (faster) render does
  chroma supersampling. See config.txt for more information.
  NOTE: This code may be buggy! Please test!
+ Simplified Exophase's OpenGL renderer present in 'e', and
  fixed a few bugs that caused it to not work for some people.
+ Really made MegaZeux use 'directx' by default on Windows. The
  code in 'e' was non-functional. Use 'windib.bat' to run
  MegaZeux with the SDL windib driver.
+ The OpenGL renderers now have a 'filter' option that allows
  you to choose linear (where pixels are interpolated, looks
  "blurred") or nearest (where nearest-neighbour approximation
  occurs, looks "sharp").
+ Mouse warping was broken when using any of the hardware
  renderers. There should be code in there now to take account
  of this (thanks Mr_Alert).
+ Added an option 'editor_spaces_replace' which allows you to
  revert MZX's space overwrite behavior to the semantics of 'd'
  (the feature was removed in 'e'). By default, the behavior is
  unchanged (the same as 'e').
+ F6 (the debug menu) can now no longer be enabled anywhere but
  in the editor Alt-T test mode. In 'e', it was possible to
  enable on the title screen, but could not be enabled in a
  game. Like the cheats, this option is now visible only in
  test mode.
+ Fixed a bug where the global robot could be exited via some
  legal commands, in an abnormal fashion. The bug resulted in
  all the code up to the offending command being executed over
  and over.
+ Fixed a bug in the audio code. The linear resampler was not
  taking volume into account, which broke changing the volume
  of samples (WAV and Vorbis) which cannot natively alter their
  volumes.
+ Fixed a regression in the overlay editor caused by the new
  editor space semantics.
+ Temporarily reverted a bugfix that broke Zeux IV - Forest of
  Ruin. I'm not dropping the bugfix, I just can't immediately
  see what's wrong.
+ Screenshots are now rendered to a separate texture using the
  8bit software renderer. This means that the hardware scalers
  will not affect the quality of the screenshot. It also fixes
  a bug when using opengl2, which would dump only a white
  screen.
- The force_height_multiplier option has been removed. A lot of
  code wasn't properly designed to handle it, there have been
  mouse warp bugs with it for years, and nobody seems to use
  it. If people want stretching, they can choose one of the
  four hardware renderers to achieve this.
- Removed the 'lame/1337' menu feature.

DEVELOPERS

+ OpenGL can now be disabled via config.sh. This allows
  MegaZeux ebuilds to be constructed on systems that do not
  have any form of OpenGL support. (Although MZX runtime loads
  the OpenGL library, 'e' required the headers to build
  correctly. This is now no longer the case.)
+ On Windows, due to an ATi driver bug, I have provided a means
  of linking directly to opengl32.dll, instead of relying on
  the dynamic loader. This reduces binary portability, but
  fixes many bug reports of being unable to fullscreen on ATi
  video cards. See OPENGL_LINKING for more information.
+ Improved support for cross compiling with mingw32 on Linux,
  combined the win32 Makefile with this new support.
+ Rewrote the config.sh script. All of the options have
  changed, and the broken platform auto-detection has been
  removed. See ./config.sh for more information.
+ Rejigged MegaZeux's headers so that they can be used in both
  C and C++ mode. Renamed fsafeopen.cpp to fsafeopen.c.
  Hopefully by 'g' most of MegaZeux should be ported back to C,
  instead of the "C++" it is now.
+ Fixed up the 'txt2hlp' utility which Terryn has been using a
  version of to build the internal MZX help system. This binary
  is built in the source distribution, but it is not
  distributed with the MegaZeux binaries.
+ Moved some antiquated Greg code out into 'old'. No attempt
  has been made to make it compile, it is provided purely for
  reference.
+ For the windows binaries, "windib.bat" is now generated by
  package.sh and auto-generated for the name of the MegaZeux
  executable.
+ Updated Xcode package from Quantum P. (see macosx.zip).
+ Fixed an invalid assumption in config.sh where /bin/sh was
  chosen as the shell script interpreter. This should have been
  /bin/bash, as 'sh' is not required to support functions,
  which config.sh uses.
  
>#MAIN.HLP:072:Table of Contents

January 19, 2007 - MZX 2.81e
 
+ Made grabbing in the editor not combine background color
  - only uses "special" in game colors for player. tell me if
  anything ends up being weird because of this.
+ Possibly fixed an obscure bug where moving something happened
  immediately if it was sent to a label by a robot further
  east/south than it and it moved north or west (has to do with
  the way robots are reverse scanned). Tell me if this changed
  any behavior for the worse and I'll change it back or try to
  work out something new.
+ Added GDMs to ctrl + n; this will, of course, auto convert
  and play the s3m.
+ Added ability to preset player locked status from board
  settings.
+ Instead added ability to debug variables (counters and
  strings) ingame with F11. There's also an option to export
  the current variables to Robotic program that sets them.
+ Fixed bug where moving a block with the player into an
  overlapping region leaves a space where the player was.
+ Fixed bug with a robot indirectly sending itself to a
  subroutine via send all or send name causing it to loop the
  send.
+ Added compatability hacks for key# prior to MZX 2.69 worlds
  and ridNAME falling through in MZX 2.70 and earlier worlds.
+ F6, F7, F8, and F11 debug/cheat keys only work in editing
  mode now (as things were prior to the port) You can still
  save/load in the editor so if you want all of these things
  you can play the game from the start there.
+ Space in the editor no longer deletes something of similar
  type that is beneath; not sure what the point of this was
  anyway.
+ Fixed bug causing cursor to clipped be out of bounds in SMZX
  char editor if changing to smaller multichar edit region.
+ Accidentally messed up screen centering in fullscreen for
  32bpp mode, fixed.
+ Added hardware scaling option. You can now supply a window
  resolution besides 640x350 and allow for window resizing if
  hardware scaling is on; this will also scale fullscreen
  output to fill the entire screen. This can slow down
  rendering somewhat.
+ Fixed bug causing flip block to crash in the editor.
+ Made blocked directions relative to the player for put dir
  player.
+ Fixed bug where putting something to a direction relative the
  player overwriting the robot could crash MZX.
+ Fixed ability to input in input boxes by clicking on their
  question string.
+ Removed the bogus patch to Modplug and correctly fixed it in
  the build system.
+ Added 'debian' subdirectory for building Debian and Ubuntu
  upstream packages. Hopefully MegaZeux will be in the primary
  pool in a few months.
+ Added OS X xcode project files (see 'macosx.zip'). Fixed many
  bugs relating to endian that caused MegaZeux to be buggy on
  big-endian architectures (like PPC). Credit goes to Quantum P
  for finding these bugs and engineering high quality
  solutions.
+ Made 'directx' the default video render again on Windows.
  NOTE: This overrides the default SDL behaviour, but will not
  be applied if you set SDL_VIDEODRIVER yourself.
+ Repaired the 'linux-static' target so that it no longer
  includes a system C++ library, which caused unpredictable
  results on distros without a static version.
+ Fixed a locking bug with the audio code that caused hangs at
  startup on OS X. Also provided a mutex implementation using
  GNU pthreads as a temporary workaround for an SDL bug on the
  Linux platform.
+ Added PlayStation Portable (PSP) port. This code was written
  by Exophase and is highly experimental. It may not work at
  all for you. Please see docs/build.txt for more information
  regarding this port.
+ Fixed mouse movement from being affected by height_multiplier
  when not in fullscreen mode.
+ Fixed height_multiplier config.txt option allowing you to
  enter really stupid values (like negatives, 0, and values too
  large for the resolution).
+ Added in an extra video mode check to stop MZX from crashing
  on video modes that the video card can not reproduce.
+ Fixed Avalanche to a constant placement rate of 1/18 (this
  caused MZX to deliver an uneven number of boulders, and to
  crash with certain board sizes).
+ Fixed sprite collision box to stop MZX from crashing when
  stupid values are entered.
+ Fixed setting the viewport size to weird values like some old
  MZX games do.
+ Default fullscreen resolution is now 640x480; this can be
  changed in config.txt .
+ The config.txt option force_32bpp is now enabled by default.
+ Seeking with mod_position when using a .WAV file as
  background music fixed (thanks Mr_Alert).
- Removed ability to change SMZX mode ingame (F11).

>#MAIN.HLP:072:Table of Contents

December 10, 2006 - MZX 2.81d

NOTE: This release was made by Alistair Strachan (ajs) and not
      by Exophase. As such, any problems present in this
      release that were not present in 2.81c should be reported
      directly to ajs.

+ Fixed a compilation failure on Linux, due to SDL no longer
  depending on libX11. Now we manually link X11 into MZX if
  necessary.
+ Various build system improvements, fixing bugs in the
  prefixing of dependencies.
+ New libmodplug 0.8 imported, fixing many endian problems on
  big-endian machines, integrating all of our local patches to
  0.7.
+ Fixed bug causing MZX to freeze when starting up on Win9x
  machines.
+ Fixed a warning generated by GCC 4.1.
+ Updated the GPL boilerplates project-wide to the newest FSF
  address.
+ Fixed a string range check causing an obscure crash in
  certain games.
+ Updated the build.txt documentation.

>#MAIN.HLP:072:Table of Contents

December 14, 2005 - MZX 2.81c

+ Oops, accidentally broke shift + F2. Fixed that.
+ Also accidentally broke &+counter& for full hex
  representation. Fixed.
+ Fixed memory leak problem with playing certain WAVs in a
  loop.
+ Fixed inconsistency of bad viewport sizes behaving
  differently on current versions from old DOS versions.
+ Accidentally broke joystick stuff in config.txt (has to do
  with way configure options were being read), fixed.
+ Fixed bug causing crash when loading MZBs larger than the
  current board size.
+ Made cursor hidden in alt + V in editor.
+ String comparison failed with nulls in the strings, fixed.
  Also should be slightly more optimal.
+ Fixed bug when using negative numbers for
  if sprite_colliding "counter".
+ Fixed math operations (inc, dec, etc) not working on string
  indeces. 
+ Added ability to force screen to 32bpp. Fixes some slight
  rendering issues, and if you have problems with fullscreen
  let me know if this helps (try it without first though). See
  force_32bpp in config.txt. 
+ Fixed sprite clipping bug with respect to overlay. 
+ Fixed bug where pressing enter on things besides robots,
  scrolls/signs, or sensors in the editor would clear whatever
  was underneath it. 
+ Accidentally broke SFX with optional PC speaker chains
  (played both, should only play PC speaker when digital music
  is off, fixes Bernard the Bard).
+ Made last character in char selection for F3 and alt + C
  remembered (note that they're remembered in two different
  places for both).
+ Accidentally broke life animations, fixed.

>#MAIN.HLP:072:Table of Contents

November 26, 2005 - MZX 2.81b

+ Fixed inability to make proper .savs of worlds with strings.
  (they'd crash when loaded..)
+ Fixed PC speaker audio bug causing a constant high pitched
  noise to be played instead of PC speaker audio sometimes.
+ Fixed some issues with long pathnames.
+ Fixed a bug causing Caverns to crash in recent versions (long
  story, it was most likely due to an error in ver1to2).
+ Now when you set mzx_speed in a game you can no longer change
  the speed from the F2 menu. Setting mzx_speed to 0 reallows
  this (and doesn't set the speed).
+ When loading a game its speed is now set to the speed MZX
  started with (whatever's in config.txt, or the default of 4).
+ Added backup_ext config.txt option to specify the extension
  of backup files (default is .mzx).
+ Fixed backup_interval for config.txt possibly being broken.
+ Fixed a bug messing up the death board on some old MZX games
  (like Nick Brick 2)
+ Escaped more things and made displays always in escaped form
  for certain character sequences. It should be impossible to
  type non-escaped forms. The following should be used:
  \0 for 0 (this probably won't work in strings, but in chars
  should)
  \t for tab (character 9)
  \n for newline (character 10)
  \r for carriage return (character 13)
  \" for double quote
  \\ for slash
+ Copy + paste on escaped character won't unescape them
  anymore.
+ Fixed error message for invalid lines in Robotic.
+ Fixed inability to import text files from other directories.
+ Huge overhaul of the source (proper types for things,
  directions, equalities, conditions, chest items, and
  potions), if anything is suddenly broken now let me know.
+ Made scrolls/signs only display text (letters, numbers, etc).
  in the default char set. That should be enough for now.
+ Added mousewheel support for robot editor and robot box
  display.
+ Fixed inability to load MZMs from other directories in the
  editor.
+ Wrapped audio stuff in proper mutex, hopefully this fixes
  some issues (like crashing when changing mod_frequency a
  lot).
+ Long current directory paths no longer write out too much in
  the file loader (instead the last bit is shown with a ...
  prefixing the beginning)
+ Decided to be nice and make board_scan not crash. Don't use
  it. It's only there to make one legacy game work. If you use
  it I will personally scold you. And don't tell other people
  to use it (that means you CJA). Use
  copy block x y w h "$str" t
  instead. If you don't know what that means read the help
  file, it explains everything.
+ Removed ability to copy + paste after changing board
  dimensions of the source under any circumstances (alt + R,
  alt + Z, import world, import board).
+ Fixed appearance of ghosts in F10 menu.
+ Prevented char editor from counting moving the cursor as an
  undo step if nothing was actually drawn.
+ Made pressing escape on initial char selection/board
  selection/param selection for things cause it to cancel
  placing anything.
+ Made it impossible to set board width/height to 0 again
  (oops).
+ Made starting lives and starting health take effect
  immediately for the first alt + t.
+ Added ability to play OGG from alt + l (but not the other
  mods, don't want to clutter that up).
+ Made it so if no note follows an embedded SAM in a play
  string it's played at native frequency.
+ Accidentally made loading worlds in the editor not change the
  current directory, fixed that.
  
>#MAIN.HLP:072:Table of Contents

November 20, 2005 - MZX 2.81

+ Fixed a bug where MZX world/save names > 12 chars could cause
  weird things to happen (like doors breaking).
+ Fixed problems with help file/charsets loading when loading
  MZX outside of the directory MZX is in. This should fix file
  associations on Windows as well.
+ Changed board selector so when board 0 is "(no board)" it
  doesn't actually refer to the title but to no board.
+ Made import world not overwrite the title string.
+ Fixed bug that causes crash when trying to flood fill an area
  with the color it already is in the SMZX char editor.
+ Redid audio engine. Everything is unified now, meaning that
  anything you can use as a mod you can use as a sam and
  vice-versa.
+ The new audio engine uses its own master resampler that has
  three interpolation modes - see config.txt for more
  information.
+ sam 0 filename will play a file at its native frequency (note
  that SAMs that have been converted from WAVs are set to be
  played at 8363Hz).
+ Added support for OGG vorbis audio files.
+ Fixed bug causing SFX volume control in F2 menu to not work.
+ Removed limitation on number of SAMs that can be played
  simultaneously.
+ Fixed bug where the mouse got "stuck" in the black border
  edges of non 640x350 fullscreen resolutions.
+ Fixed issues with message boxes being part default palette
  part current palette, they now always use the current
  palette.
+ Added mod_position counter. What these actually set/return is
  dependant on the type of file loaded. Modules use the current
  row, OGGs use the current PCM sample.
+ Added mod_frequency counter. There are a few things to note
  here: Modules have a "nominal" frequency of 44.1KHz. Other
  data types have their own nominal frequency to prevent output
  from sounding differently depending on the audio_sample_rate
  in config.txt. For OGGs and WAVs the nominal frequency is the
  one the file is encoded at. Changing the frequency can cause
  a noticeable one time popping sound, so it might not be
  desirable to slide it. This is much more prominent with
  lowering the frequency than raising it. This value is capped
  so it can't reach below 16.
+ Changed alt + L to play back at natural frequency instead of
  8363Hz.
+ Fixed bug causing sensor deletion while the player is on top
  to destroy the player.
+ Fixed bug causing imported boards to possibly crash after
  being tested.
+ Fixed bug causing save_game and save_world to not work if a
  file with the given name isn't already present.
+ Changed function counter matching removing restriction on
  number of digits for parameters. 10+ digit inputs should no
  longer fail (for instance, abs-123456789)
+ Made counter/string names internally variable length instead
  of a fixed 14 chars. There is now no longer a name length
  limitation.
+ Changed alt+8 for mod * to just * in the hotkey listing.
+ Fixed crash when referencing (by param) sprites > 256.
+ The string system has been redone. Strings are now
  dynamically sized and don't have an artificial maximum
  length. Writing to string.N will guarantee that the size of
  the string becomes at least N, while reading in this way will
  return 0 if out of bounds to maintain the illusion of null
  termination. Be careful when using this.
+ $str.length returns the length of string $str (this is faster
  than iterating through it to find when chars hit 0).
+ Vlayer is dynamically sized. The vlayer_width/vlayer_height
  counters still work as per usual, but the vlayer_size counter
  has been added to adjust the maximum size. The default is
  32768.
+ Fixed bug not allowing things to move over goop.
+ Fixed bugs causing current directory to be changed when
  importing things from other directories.
+ Properly implemented support for volume "string".
+ Fixed a few commands not working when they should from the
  global robot (such as put to dir of player).
+ Fixed a bug where going to a label at the end of a robot
  would treat it as if it's the first of its name in a sequence
  of labels.
+ Fixed a bug involving moving the a block with the player not
  moving what was underneath the player.
+ New help file, thanks MUCHLY to Terryn for pulling off this
  enormous effort! (This is what you're reading from.)
- Save files from 2.80 are not compatible due to several
  changes in the save format.

>#NEWINVER.HLP:1st:NEW in MegaZeux!
>#2823CLOG.HLP:283:New in Versions 2.82 to 2.83
>#280CLOG.HLP:280:New in Versions 2.80 to 2.80h
>#OLDERVER.HLP:099:New in Versions 2.60 to 2.70
>#OLDESVER.HLP:100:New in Versions 2.01 to 2.60
>#NEWIN200.HLP:1st:New in Version 2.00
>#ANCENVER.HLP:103:New in Versions Through 1.03
>#MAIN.HLP:072:Table of Contents
#280CLOG.HLP
:280: 
$~9New in Versions 2.80 to 2.80h

June 6, 2005 - MZX 2.80h

+ Fixed a bug which could cause crashes when quitting the game.
+ Fixed some bugs when changing boards and other things that
  can cause duplicate players.. I think.
+ Fixed a bug that could cause crashes when adding boards.
+ Improved response time in editor for slower computers/high
  load situations.
+ Fixed some endian issues with the GUI.
+ Fixed some crash when moving the mouse cursor around in the
  editor.
+ Fixed bug where you if you had a robot whose name is the same
  as the global robot it wouldn't get messages (fixes yoyo in
  Weirdness).
+ Fixed debug box not moving with text input.
+ Fixed bug with duplicate player appearing when killed and a
  new one can't be put at 0, 0.
+ Added copy/paste for outside of MZX to/from the robot editor.
  It only works in Windows and X11, and functionality may be
  limited in X11 right now (currently seems to work in native
  X11 apps and GTK 2.6 apps but not earlier GTK or QT, also try
  shift + insert to paste).
+ Fixed bug in resizing involving overlay blanking.
+ Fixed clear messages/projectiles not working (and damaging
  the game instead).
+ Fixed behavior of P key in editor for wildweasel.
+ Fixed random in Robotic not correctly swapping the range if
  they're given in the wrong order.
+ Fixed clip length in [ messages.
+ Fixed crash when changing volume without a game loaded.
+ Redid internal GUI system, fixes some minor things.
+ New file loading/saving window - press del to delete a
  file/dir, alt + n to create a new directory, alt + r to
  rename a file/dir.
+ Added PC speaker volume control to F2 settings and
  config.txt.
+ Fixed yet another crash bug with resizing boards.
+ Fixed inability to type * in text placement in the editor
  (although this adds inability to turn on mod * while F2 is
  on...).
+ Added ctrl + n in the editor to load a module for listening
  only (won't set the current board's module, and will let you
  choose ones from different directories).
+ Fixed crash on macros with more variables than can be
  displayed in their configuration.
+ Fixed bug that causes char selection cursor to reset to 0 on
  unhandled keys (and continuously do so for lock keys).
+ Tweaked ctrl + dir in text entry boxes.
+ Added gdm2s3m in-tree to the contrib/ directory. gdm2s3m no
  longer needs to be installed on the system before compiling
  mzx.
+ Improved the build system to automatically build .c and .cpp
  files with compound system CFLAGS/CXXFLAGS, respectively.
+ Made package.sh automatically ship the source package with a
  Makefile.dist to warn the user that they need to run
  config.sh before 'make'.
+ Rectified inconsistency in source copyrights.
+ Added multi-character editor. Select multiple keys in the
  character selection with shift. The char editor also now has
  the ability to perform operations (delete, copy, scroll, etc)
  on subblocks. Hold down shift or press alt + b to highlight a
  region (press escape to remove the latter). Blocks copied
  like this will be pasted to where the cursor is at. Other
  small things in chareditor tweaked/changed... No longer press
  tab to toggle through set/clear/toggle draw modes, instead
  tab for set mode and shift + tab for clear (no more toggle).
  Mouse behavior is modified as well. In non-SMZX left click
  sets, right click clears. Shift + F2 will cut a block (clear
  + copy).

  alt + x/alt + i can now be used to import/export partial
  charsets while in the char editor. You can do so for several
  in series: put a # in the name of the charset then set the
  First for the first number # will be replaced with and the
  Count value to indicate how many in series to work with. For
  instance, saving s#.chr with first = 0, count = 3, starting
  at offset 100, with a 2x2 char selection will save charsets
  s0.chr from 100, s1.chr from 104, s2.chr from 108, and
  s3.chr from 112.

  *** NOTE *** Series import/export will only work correctly
  with char selections that are one in height (they can still
  be split up another way in the editor itself). If you want to
  use partial charsets on your edits, it's important that you
  select all the chars in a row.

+ Made characters for the editor/GUI use another charset that's
  protected. Please notify me if any characters are incorrect.
  Modify mzx_edit.chr to change this charset. The same thing
  goes for colors. It doesn't work for SMZX, which also might
  look a bit different in the editor...
+ Added option (defaults on) to protect chars 32-127 in input
  boxes and strings in the robot editor.
+ Mouse warping goes to middle instead of top corner now, so
  there isn't a bias towards moving up.
+ Hopefully fixed another bug with the cursor and changing
  boards...
+ Fixed module looping problem in modplug...
+ Added libmodplug 0.7 with both patches (see contrib/)
  in-tree. Removes system dependency on libmodplug.
+ Made auto-backup on by default. (3 count)
+ Made if touching idle, beneath always false instead of like
  nodir.
+ Fixed bug that caused bad things to happen if you pressed too
  many different keys too rapidly.
+ Made mouse wheel emulate up/down in dialog boxes and list
  menu.
+ Added ctrl + backspace to intake (delete previous word).
+ Made modulo operator use floored instead of truncated mod
  (uses positive remainder instead of negative).
+ Fixed crash when testing after using ctrl + z to clear a
  board.
+ Fixed bug where sending other robots to subroutines caused
  the return address to be to the next instruction like local
  subroutine calling works.
+ Fixed bug where going to a label on the last line of the
  robot could screw the game up.
+ Fixed a bug where the editor froze if you tried to fill the
  board with players. (eheh...)
+ Fixed a bug that could cause crashes when sending all sensors
  something.
+ Fixed some crashes when exporting/saving fails.
+ Fixed import world's ability to go over the board limit and
  cause crashes.
+ Allowed input of decimal numbers for params.

>#MAIN.HLP:072:Table of Contents

April 1, 2005 - MZX 2.80g

+ Fixed crash on alt + x in robot editor.
+ Fixed missing line on alt + h in robot editor.
+ Introduced incorrect enter action in robot editor (didn't
  reset to beginning of the line), fixed.
+ Fixed garbage appearing when moving from a larger to smaller
  board and being outside of that board's scroll region.
+ Fixed bug that could cause glitches/crashing when resizing
  the board.
+ Fixed error with global next option not retaining the three
  checkmark options correctly.
+ Added work around so that move block moves the player (won't
  move it on inter-board moves).
+ Fixed bad palette loading for Linux introduced in 2.80e or f
  or something
+ Made it so block highlighting doesn't highlight the debug
  window.
+ Made the debug window move if necessary when home/end is
  pressed.
+ Added autorepeat buffering so previous keys can be resumed.
+ Fixed bug with swap world possibly not working (crashing??)
  off Windows.
+ Fixed more problems with garbage/crashes when resizing with
  the cursor in a position causing the scroll to go off the
  edge.
+ Fixed incorrect text cursor offset with
  force_height_multiplier on.
+ Redid way directories are loaded internally so you can load
  dirs with over 4096 entries now. Might be faster (unsure)
+ Chest contents list menu looked funny, fixed.
+ Changed default.spl to smzx.pal so you can load it more
  sanely.
+ Export block wasn't getting the last selected line. Fixed.
+ Hacked scroll editor so it wouldn't crash when removing
  lines. Scroll code either needs to be 100% overhauled or
  replaced by robots somehow...
+ Fixed config files not being closed.
+ Added include file option for config files. Use it like this:
  include "config file"; e.g., "include subconfig.cnf" will
  load subconfig.cnf's options.
+ Fixed freadN not terminating strings.
+ Fixed graphical glitch when using the mouse in the char
  selector.
+ Fixed save games crashing when they can't load fopened files.
+ Fixed some other problems with save games and fopened files.
+ Accidentally had title screen running a bit slow...
+ Value strings starting with ( not parsed as an expression if
  they don't end with the ).
+ Fixed problem with key_code being triggered for keys that
  aren't in-game.
+ Added extended macros. This allows for parameter based macros
  to be entered in the robot editor via a window or by command.
  See macro.txt for more information.
+ Fixed player cloning after flip/mirror and player placing.
+ Added random seeding that was mysteriously missing...
+ Finally added drive changing for Windows builds.
+ Fixed mousex/mousey for resolutions other than 640x350 (only
  applies to fullscreen).
+ Fixed crash on weird invalid death/endgame boards...
+ % and & messages clip correctly now.
+ Fixed potential crash on double closing the files.
+ Fixed crash bugs with placing sensors and maybe scrolls.
+ Fixed sending sensors when you have robots of the same name
  (fixes Weirdness chapter 1).
- Removed the unimplemented if player dir and if not player dir
  commands from RASM.
  
>#MAIN.HLP:072:Table of Contents

December 26, 2004 - MZX 2.80f

+ Fixed a bug that could cause crashes when auto-quoting params
  in the robot editor (eg, set x 1 -> set "x" to 1).
+ Fixed a bug that could crash the robot editor if you added a
  new line prior to the first line of a marked block, then did
  an action on it.
+ Fixed a bug where clearing the first and only line could
  cause it to appear as if it hadn't been cleared at all.
+ Unified global and global next parameter setting so that
  nothing is lost between first/next but information can be
  cancelled without application.
+ Fixed E/S block markers appearing in the robot editor when
  they should be off the screen.
+ Left click position in robot editor mysteriously disappeared
  after having been added somewhere after 2.80d. Re-added.
+ Added option to hide the hotkeys help and horizontal border
  in the robot editor with alt + h. Also added a config.txt
  option to have it default this way.
+ Search/replace in the robot editor. ctrl + f to find or
  replace/replace all, ctrl + r to repeat either search or
  replace (depending the last one you did, if you cancelled
  this does nothing).
+ The load_game counter sequence was broken; fixed.
+ Hopefully fixed all means of overrunning the current line max
  length in the robot editor...
+ Fixed robot editor validation not showing every 13th line.
+ Fixed aesthetic problem with validation report...
+ Fixed crash with setting message column less than 0.
+ A couple things added for 2.80e mysteriously disappeared in
  source handling. Re-added.
+ Changed max board size prevention to auto resize the lower
  dimension to the max that can be handled with the higher
  (ex, 30000x25000 becomes 30000x559).
+ Added flood fill to char editors (alt + f).
+ Added single depth undo to char editors (alt + u).

>#MAIN.HLP:072:Table of Contents

December 19, 2004 - MZX 2.80e

+ Fixed a bug causing problems with static overlay if a
  non-overlaid sprite is displayed so it's clipped off the edge
  of the screen.
+ Fixed a bug in the display of c?x color boxes in the F2 menu
  in the robot editor.
+ Fixed a bug that caused incorrect thisx/thisy for one cycle
  after copyblock.
+ Fixed a bug preventing calls to nonexistent subroutines from
  passing that point in the robot.
+ Fixed crash on sam 0 "file".
+ Fixed a bug where loading new SFX may not correctly overwrite
  previous ones.
+ Fixed a bug where you could only load/unload so many mods
  before MZX couldn't load anymore.. same bug as the SAMs but
  went unnoticed!
+ Fixed a bug that caused you to be infinitely stuck in the
  global settings dialog box when you press previous on the
  next page.
+ Fixed a bug where going to next then exiting would not save
  the changes from the previous page.
+ Fixed a bug that could cause crashes while ending modules.
+ Fixed a bug that could do the same kind of thing with sams.
+ Fixed an allocation bug when loading MZX worlds that could
  lead to crashes.
+ Fixed a bug that caused MZX to crash if you interpolated an
  expression with a value equal to or greater than 1 billion.
+ Fixed a bug where mixing ccheck1/2 with sprites from board
  and vlayer could cause problems (that's the short version of
  the explanation, I'll spare you the long one).
+ Fixed a bug that could cause certain old MZX games to crash
  after the title screen
+ Somewhere broke missiles between 2.80c and 2.80d. Fixed.
+ Fixed error in lit bomb anim sequence setup in char ID
  editor.
+ Reworked a lot of robot editor code; adding/deleting lines
  while marked areas are active should work more naturally now
  and it's hopefully no longer possible to crash it in the same
  ways it was previously.
+ Fixed crash when setting mesg row to less than 0.
+ Fixed mouse presses not working in the robot editor.
+ Made MZX ignore alt + tab so you can safely switch in your WM
  without it triggering...
+ Added numerical key entry for number boxes. Use 0-9 to add to
  the most significant digit and backspace to take it away.
+ Added config.txt option to make MZX pause when key focus is
  lost (when clicking on another window, perhaps) or when it's
  minimized. Music will still continue.
+ Added save/load position to the editor. Works for loads
  in between boards as well. Press ctrl + num to save to slots
  0 through 9 and alt + num to load from that slot. Please
  press shift + 8 or the numpad * key instead of alt + 8 to set
  mod wildcard.
+ Fixed a further bug that could cause playing samples to
  crash.
+ Added config file option to revert the robot editor to the
  default palette when loaded.
+ Fixed bug in shoot command.
+ Fixed error when making save name in editor but cancelling.
+ Auto-backup - see config.txt for details.
+ Joystick key mapping - see config.txt for details.
+ You can now load game-specific config files by creating
  game.cnf for the corresponding game.cnf (for instance,
  caverns.cnf). This is mainly useful for joystick key mapping.
  Note that these settings will NOT go away if another game is
  loaded that doesn't have a .cnf.
+ Alt+enter finally works as block action in the robot editor.
+ Loading a .mzx/.sav from another directory indirectly (via
  command-line or robotic) will now actually change the current
  working directory.
+ Fixed bug that crashed MZX with ctrl + i in the robot editor.
- Fixed maximum board size to about 16.7 million tiles (128MB)
  for now.
- MZX now ignores the mouse scroll wheel instead of
  interpreting it as a click.
  
>#MAIN.HLP:072:Table of Contents

October 9, 2004 - MZX 2.80d

+ Fixed cursor going invisible when escaping from import in the
  editor.
+ Fixed robot editor entry when pressing OK on global info.
+ Fixed lack of name for MZB import/export (any MZB's exported
  in prior beta versions still won't have a name).
+ Fixed some problems with setting the mouse position.
+ Fixed problem with exits not bringing you all the way to the
  edge if width over 400 or height over 200.
+ Fixed bug that cleared too much when increasing both width
  and height while resizing the board.
+ Fixed problem with 1 char shortcut commands with spaces
  immediately after them.
+ Fixed problems with load_robot and load_bc (caused crashes
  and infinite loops).
+ Optimized RASM heavily (this should be most noticeable when
  doing a lot of external robot loading from text files).
+ Fixed inability to use absolute paths in loading a game from
  command line.
+ Fixed lastshot/lasttouch conditions with directions not
  working.
+ Fixed char editor in robots not going into SMZX mode when
  proper.
+ Cleaned up source code so it passes -Wall without complaint
  and in the process corrected some glaring code errors that
  may have corrected random problems.
+ File opening broken in 2.80c, fixed.
+ Implemented MZM2 saving and loading and rewrote mzm.cpp (if
  anything is changed or fixed regarding MZMs, attribute it to
  this). MZM2s can be of larger dimensions, smaller filesize
  for same amount of data, and can store robots.
+ Fixed bug that could cause MZX to crash when making new
  strings.
+ Block operations to overlay when overlay was off caused
  crashes - fixed.
+ Fixed a problem with sprite ccheck2 against other sprites.
+ Optimized function counter lookups a bit; speed gain for all
  counter accesses (especially ones that begin with certain
  characters such as _).
+ Fixed disassembly error with ' ' character.
+ Fixed assembly error where condition extended dir (such as
  blocked opp seek) was not getting compiled with the dir
  extension.
+ Fixed editor bug where the param was not being cleared when
  overwriting things by double placement.
+ Fixed inability to use counters with
  playercolor/bulletcolor/missilecolor.
+ Added ability to use counters in place of p?? in the robot
  editor. Note - even though this expands functionality of the
  editor this does not require a version number change because
  the worlds will still be playable in older MZX versions (and
  will display correctly in the robot editor - you simply won't
  be able to correctly edit the commands).
+ Mouse correctly limited to screen edges now.
+ Fixed inability to overwrite robots with pushable robots and
  vice-versa, as well as scrolls with signs and vice-versa.
+ Possibly fixed problem with windowing error when editing
  global robot (?).
+ Fixed disappearing cursor after color selection box with
  mouse (and other places?).
+ Fixed bug in sprite clipping that caused some to be clipped
  off inappropriately.
+ Made board_id/board_param counters readable.
+ Added bound checks for all counters using
  board_x/board_y/overlay_x/overlay_y.
+ Fixed potential direction corruption bug causing directions
  not to work sometimes even if they display correctly in the
  robot editor.
+ Fixed copy overlay to MZM copying to overlay too.
+ Fixed a bug where debug window could display the wrong amount
  of robot mem and potentially even crash MZX.
+ Fixed help_menu counter not doing anything (durr).
+ Changed sprite draw order so they're drawn underneath the
  message bar, debug box, and time remaining display.
+ Changed put p?? in Robotic so it will put default params if
  available.
+ Fixed a bug that could cause copies from overlay to vlayer to
  not end up at the correct destination.
+ Fixed a bug where c?x and cx? would not display correctly in
  the robot editor.
+ Optimized copy blocks a bit using variable length arrays
  instead of malloc.
- Removed ability to put robots, scrolls/signs, and sensors
  (with the put command in Robotic).
  
>#MAIN.HLP:072:Table of Contents

August 16, 2004 - MZX 2.80c
+ Fixed issues with the commands counter not being reset.
+ Color intensity now gets reset when you enter the editor
+ SAMs got cut off sometimes now.. fixed.
+ Fixed bug where loading a world with empty boards could
  change the starting, endgame, and death boards.
+ Fixed bug where you could text enter off the bottom of the
  board, causing problems.
+ Fixed bug involving cutting/clearing the entire robot in the
  robot editor while not at the first line.
+ Fixed robot name entry for global robot not disappearing on
  small boards.
+ Fixed bug where you could duplicate the player by holding
  down a direction as a saved game loads.
+ Fixed bug where you could go to line 0 in the robot editor.
+ Saving an MZM now auto-adds the .mzm extension...
+ Fixed black screen on quicksave.
+ Fixed bug where opening a file didn't close the old one if
  one was open (so it'd eventually crash MZX).
+ Changed Alt+backspace behavior in intake so it doesn't exit.
+ Added clipping for refx/refy/width/height for sprites (less
  than 0 at initialization, greater than board width/height at
  draw).
+ Fixed direction parsing for move all.
+ Fixed bug where creating things on top of the player would
  use a slot for robots/scrolls/signs/sensors instead of just
  copy to the buffer.
+ Added ability to use chars as immediates in Robotic commands
  (ie, set "$str.0" 'a').
+ Added options to enable oversampling and specify resampling
  mode in the config file (higher quality audio).
+ Building with patched modplug that fixes loading 2-channel
  mods outputted by FT2. If you're building yourself, see
  build.txt.
+ Fixed inability to mouse click in alt + h mode.
+ Fixed ability to mouse click outside of board range.
+ Should work better for Linux users; case insensitivity for
  file opens has been added.
+ Fixed close bug that was affecting Linux builds (may affect
  more).
+ Keypad enter works where normal enter works now.
+ Fixed disappearing cursor when cancelling out of abandon
  changes box when loading a new world in the editor.
+ Fixed problems when loading/saving robots outside of ID range
  (do not hardcode ID's people).
+ Fixed problem with NO BOARD exits being set to something else
  when empty boards were being stripped or when worlds were
  being imported.
+ Fixed bug where auto-decrypting worlds didn't work if the XOR
  value was negative.
+ Fixed problem with rid not working the first cycle.
+ Fixed inability to interpolate (with &&'s) counter names
  larger than 14.
+ Added new robot mem counter in debug box (only kb precise,
  rounds up).
+ Fixed ability to clone the player on non-title board after
  testing.
+ Lengthened size of mod name buffers.
+ Fixed bug where send x y doesn't work from the global robot.
+ Fixed a few bugs that could cause MZX to crash.

>#MAIN.HLP:072:Table of Contents

August 11, 2004 - MZX 2.80b

+ Made it possible for robots to move through teleporters.
+ Fixed bug with pressing shift in text entry boxes.
+ Made it so alt + tab does not switch draw modes in editor.
+ Fixed a disassembly error for color intensity N percent
  command.
+ Fixed problem with looping on mods that do not loop
  explicitly.
+ Fixed alt + dir scrolling in the char editor.
+ Fixed not being able to click the rightmost char in the char
  editor.
+ Re-added unmark (alt + u) to robot editor (mysteriously
  disappeared??).
+ Fixed key label so it returns proper unicode values.
+ The player and pushable robots can now be pushed by the push
  command.
+ Fixed bug where you could clone the player by switching
  boards.
+ Fixed bug where you could either turn off overlay or switch
  to boards that don't have it while in overlay edit mode...
+ Fixed bug where remains of debug window would not be cleared
  in editor if the board width is too small.
+ Fixed bug where turning off the menu with a board too small
  would mess things up.
+ Fixed bug where run lengths were saved one too large... this
  could fix stability problems in at least occasional cases
  (with saved worlds or save games, at least).
+ Fixed placing solid things beneath robots (like bombs).
+ Added support for a keyboard plus in the char editors.
+ Fixed previous button in SFX editor.
+ Made robot name box disappear when robot char box comes up...
+ Fixed bug where mods restart after pressing P if they're the
  same mod as what was playing before.
+ Fixed problem with changing params (with P) in the editor.
+ Fixed bug where null boards were not being pruned from old
  worlds upon load.
+ Made file name saving box larger (for saving games and
  worlds).
+ Fixed bug where default (100%) palette intensity values would
  not be applied to the palette a game loads with.
+ Fixed bug where exporting char sets that are full size caused
  a 0 byte charset to be exported (8bit wraparound).
+ Added support for forms such as :line.
+ Fixed sporadic incompletion of strings without trailing
  quotes at the end of the line.
+ Fixed bug where clearing/cutting the last line of a robot
  crashed MZX.
+ F4 in robot editor now works more generally.
+ Made line numbers in robot editor error report start at 1.
+ Added ctrl + G to go to a line in the robot editor (ala
  nano).
+ Made it possible to change a robot's color in the editor
+ Fixed bug where spitfire, seekers, and missiles didn't hurt
  something immediate adjacent to whatever shot it.
+ Fixed editing of spitfires.
+ Made default speed 4 again (5, bleh).
+ Re-added quicksave/quickload.
+ Re-added F8 clear (always works - be careful).
+ Fixed autorepeat problems for spacepressed/delpressed.
+ Wrapped around sprite values so LogiCow's bad code would work
  (HTMCIAB).
+ Cleared block commands in between board changing and other
  things like that.
+ Fixed bug where MZX would crash if put dir player overwrote
  the robot doing it.
+ Fixed bug where playing SAMs would eventually crash MZX
+ Fixed some mod * problems (hopefully?).
+ Fixed bug where pasting blocks over the edge of the board in
  the editor would cause MZX to crash.
+ Uses new GDM2S3M source that fixes some bugs. If your
  converted GDM's have problems, delete the S3Ms it generated.
- Removed export text in the board editor. Don't think anyone
  wanted it...
  
>#MAIN.HLP:072:Table of Contents

August 9, 2004 - First release, MZX 2.80 BETA

+ All ASM files have been rewritten to ANSI C compliant C++;
  this mainly involves the mammoth game2.asm.
+ Everything graphics related has been replaced with an SDL
  driven engine, including text mode rendering (also capable of
  rendering SMZX modes).
+ All keyboard and mouse events are now also handled by an SDL
  driven engine. All internal keyboard/mouse routines use SDL
  keycodes; no attempt was made to convert to MZX's old format
  at this level.
+ All world/board/robot loading and saving code has been
  entirely rewritten and is more modular now.
+ All robot handling code has been rewritten from scratch, and
  is more sane/efficient now (allocation, message sending,
  sensors, etc.)
+ All counter handling code has also been rewritten from
  scratch. This includes the functionality of builtin and
  "function" counters. It also includes a new string framework.
+ The robot interpreter has been almost entirely rewritten.
+ The main game playing code (game.cpp) has been almost
  entirely rewritten.
+ All module/sample playing code has been rewritten to use
  modplug and SDL. PC speaker effects are emulated.
+ The main part of the editor (edit.cpp) has been almost
  entirely rewritten.
+ The robot editor has been entirely rewritten, utilizing a
  modified (fixed) version of RASM (released by me over a year
  ago)
+ All other source files (for instance, window handling code,
  scroll displaying, char editor, etc.) have been largely
  overhauled, some to more of a degree than others. At the
  very least, everything has been reformatted and made to work
  with the new systems.
+ key_pressed and key_code now return unsigned chars instead of
  signed, so if the game checks for negative values, it won't
  work. The same goes for reading back characters for strings.
+ Boards may now be as large as 32767x32767. Please do not make
  boards this large. :)
+ You may now have up to 250 boards.
+ Boards may have up to 255 robots, 255 scrolls, and 255
  sensors.
+ There is no robot memory per board limit. However, individual
  robots may only be up to 64k large. If you include the global
  robot, this means that you effectively can have up to 16MB of
  robot memory per board.
+ The same applies to scrolls, which have separate memory
  spaces and may only be up to 64k in length each (so you could
  have almost 16MB of scroll text per board, but who would want
  that??).
+ The robot stack need not be initialized, and will be
  dynamically resized as necessary (useful for recursion). This
  refers to lines such as
  . "#*-1-2-3-4-5-6-7-8"
  at the beginning of robots. They're no longer necessary or
  useful (they will be ignored, like any other comment).
+ You may have a virtually unlimited number of counters active.
  The theoretical limit is some 4 billion. The effective limit
  depends on memory available.
+ The same goes for strings, which may now have any name, so
  long as it begins with a dollar sign ($). The same
  conventions regarding strings in 2.68+ still apply (see
  268_info.txt for more information).
+ Local2 and local3 no longer have dangerous side-effects.
  Local4 through local32 are also available per-robot now.
+ The following are now natively supported: XM, S3M, MOD, MED,
  MTM, STM, IT, 669, ULT, WAV, DSM, FAR, AMS, MDL, OKT, DMF,
  PTM, DBM, AMF, MT2, PSM, J2B, and UMX.
+ You can now perform repeated copies by selecting "Copy
  (repeated)" from the block command window. This will cause
  you to repeat the copy indefinitely until you press escape.
  Also, after the first paste is made, you may press ctrl +
  direction to move in steps that are the size of the copy (you
  really have to try it to get a good idea of what I mean).
+ Press alt + H to hide/unhide the menu/information occupying
  the bottom 6 lines of the screen.
+ Right click is similar to pressing insert (grabs whatever's
  under the cursor).
+ Exporting char sets now gives direct options to set the
  size/offset for partial charsets. The old format (prefixing
  the name) will not work.
+ For saving files, you may make filenames larger and use mixed
  case (as opposed to all caps).
+ Now when you import worlds their exits will actually work.
+ Loading worlds results in all empty boards and empty
  robots/scrolls/sensors within the boards being removed. When
  you delete a board, you won't be presented with a gap in the
  board list anymore.
+ You may once again select ASCII as a default charset and
  revert to it in the char editor. You may also select a
  default SMZX charset.
+ Anywhere you can enter a line of text you can now press ctrl
  + left and ctrl + right to go to the previous/next word.
+ This isn't totally limited to the editor, but now everywhere
  a selection box shows up (such as for files, boards, items)
  you can press multiple keys to seek to a specific entry.
  Furthermore, in file selection boxes you can press backspace
  to go up a directory.
+ The SMZX char editor has been changed quite a bit. First, to
  use, you must be in SMZX modes 1-3 (toggle using F11). Within
  the editor, press keys 1 through 4 to change the "current
  color." You can place this color with space, and you can
  toggle repeated placement on/off using tab (sorry, no
  clear/toggle in this mode, they got in the way far more than
  they helped). You now move in increments of 1 char naturally
  instead of "half chars." Right click grabs the current
  "color" underneath the cursor.
+ You are now able to type invalid code within a robotic line.
  You will see that it's invalid due to the way the line is
  color coded. If you try to escape while any lines are invalid
  or if you press alt + V, a window will be brought up
  describing the nature of all erroneous lines. It will also
  let you mark each line to be deleted or commented out on
  exit. If all invalid lines are marked with anything besides
  ignore, you can exit safely. You may also mark invalid lines
  using ctrl + I, D, and C (to mark as ignore, delete, and
  comment respectively). ctrl + C may also be used to comment
  out a normal line, and then uncomment.
+ alt + O is still available, but you may only change macros
  here (see the config file for the other rarely used options).
  This does give you more room to modify macros, though. They
  may be up to 64 characters in length, and you may set up to
  around 45 or so in this window. (To get larger, you'll have
  to use the config file.).
+ Command line params have changed.
+ MegaZeux configuration information is now stored in a file
  called config.txt.
- There are some slight discrepancies in robot size; if you
  highlight the last line then leave it, it will register as a
  compilation of that line. Yet, when you exit, the line will
  be discarded, so this addition is not permanent. This
  shouldn't be problematic.
- alt + enter and alt + escape no longer work; use the
  alternatives (alt + b and alt + u).
- You cannot click on help options to make it happen (for
  instance, you can't click on L:Load and expect it to bring up
  the load window).
- You cannot import or export ANS files. Use MZM instead.
- Some things that worked in the DOS version only worked due to
  chance, such as there being default (but valid) values for
  sprite widths or heights and thus sprites could be displayed
  before new values were set. They will not work here.

>#NEWINVER.HLP:1st:NEW in MegaZeux!
>#2823CLOG.HLP:283:New in Versions 2.82 to 2.83
>#281CLOG.HLP:281:New in Versions 2.81 to 2.81h
>#OLDERVER.HLP:099:New in Versions 2.60 to 2.70
>#OLDESVER.HLP:100:New in Versions 2.01 to 2.60
>#NEWIN200.HLP:1st:New in Version 2.00
>#ANCENVER.HLP:103:New in Versions Through 1.03
>#MAIN.HLP:072:Table of Contents
#OLDERVER.HLP
:099: 
$~9New in Versions 2.60 to 2.70

**NEW in 2.70***

+ Robotic code now loadable and savable to files, either to
  text files or compact but human-unreadable bytecode files.
  Other robots' code can be written to or read as well.
+ Defaults changed to more accepted values.
+ The swap world bug should be fixed. You should now be able to
  swap worlds back and forth with no trouble.
+ "atan" now works with any input/output value.
+ The "load_game" command now should work without any problems.
+ It should now be easier to compile MZX from the source.
+ It's not really a bug fix, but the palette is now returned to
  its original colors.
+ Robots can now 'put' things underneath themselves: eg. put
  c04 carpet p?? under.
+ The title screen menu now works: e.g. the menu you get when
  pressing 'Enter' on the title screen.
+ "key_pressed" now returns the twos-complement of the key
  value, i.e. the one used for :key?
+ The mouse can scroll across the whole screen after a screen
  refresh / transition to/from SMZX mode.

>#MAIN.HLP:072:Table of Contents

**NEW in 2.69c***

+ Sprite limit expanded from 64 to 256.
+ New sprite flag added: sprN_ccheck mode 2.
+ Vlayer added.  This is a virtual, unseen layer 32767 in size
  used to store graphical data.
+ World loading and saving through Robotic now possible.
+ Special class fwrite_modify; this allows editing of a file as
  opposed to overwriting.
+ File end seeking added.
+ Char file offsetting added.
+ File seeking added to editor.

>#MAIN.HLP:072:Table of Contents

***NEW in 2.69b***

+ Fixed the fwrite_append problem RoSS mentioned.
+ Fixed the string problem Nanobot mentioned.
+ Added ridNAME as an alternative to robot_id_NAME.
+ Added mouse_mx and mouse_my to determine mouse motion in
  "mickey" units.
+ Added two local counters "local2" and "local3", local2 uses
  walk_dir and is_locked (so walking and locking will affect
  it), local3 uses last_shot_dir and last_touch_dir (so
  shooting and being touched will affect it).
+ Added the builtin string "robot_name" to determine the name
  of the robot invoking it.
+ Reverted back to BWSB 1.20a again, in the hopes that it will
  alleviate swap world crashing a bit.

>#MAIN.HLP:072:Table of Contents

***NEW in 2.69***

+ if "$stringN" = "literal" should now work.
+ Embedding && or () in names for save/load files for MZM
  saving and the like should work now.
+ Expressions won't be activated in pre-2.68 games, meaning if
  they used the constructs which would be valid expressions
  they should be okay.
+ More minutiae.
+ key_code, a more useful key_pressed alternative, added.
+ SMZX mode 1 returns.
+ SMZX mode 2 added.

>#MAIN.HLP:072:Table of Contents

***NEW in 2.68***

+ Expressions added.
+ Trigonometric capabilities added.
+ MZM file capabilities added.
+ Board and overlay can now copy block to each other.
+ Saving and loading of SAV files through Robotic added.
+ String commands totally redone.
+ Now, instead of using value/sqrt_value/abs_value you may use
  a value with the counter directly as such:
   * sqrtN
   * absN
+ fread_pos/fwrite_pos and page should work correctly now; when
  you increase the pos it should bump up the page too.
+ pixel_x, pixel_y, char were broken in 2.65; fixed in 2.68
+ strings had some bugs in 2.62b+, should be fixed now because
  of a separate implementation.
+ MZX Robot files are now saved to save files, so if you have a
  read and/or write file open and the game is saved, if the
  game is loaded the file will be restored at the position it
  was at.

>#MAIN.HLP:072:Table of Contents

***NEW in 2.65***

+ Shows current mod playing in debug window
+ Misc new counters: (ro = read only, wo = write only)
 * fread_counter (ro), fwrite_counter (wo): reads/writes a full
   counter from file
 * board_w (ro), board_h (ro): returns current board
   width/height
 * robot_id_(name) (ro): returns the ID number of robot "name"
 * r(number).(counter) (ro): returns the value of the local
   counter for the robot with the given ID. Note that you
   cannot write to another robot's counter.
+ You can now save partial charsets in the editor.
+ Sprites added; limit set at 64 global.
+ Counters now representable in hex.
+ Subroutines added.

>#MAIN.HLP:072:Table of Contents

***NEW in 2.62***

+ Strings added; limited to ten strings.
+ "mod_order" counter: reports the current order (that is,
   pattern) the playing module is at. Used in conjunction with
   the jump mod order command it can be used to save/restore a
   mod position between boards...
- MZX 2.62 files are no longer forward compatible. That means
  that a file made in MZX 2.62 will NOT work in any previous
  versions (but it WILL work in future versions, so long as
  they set the version string correctly).
- The string reading from files may not work correctly on the
  first read (that is, it might truncate the first character of
  the string). For this reason put a junk string in the first
  part of the file and read it first.

>#MAIN.HLP:072:Table of Contents

***NEW in 2.61***

+ Game speeds have been normalized.
+ Original startup color scheme implemented!
+ Redocumentation of a few features left undocumented.
- Password protection has been fully removed.

$***

>#NEWINVER.HLP:1st:NEW in MegaZeux!
>#2823CLOG.HLP:283:New in Versions 2.82 to 2.83
>#281CLOG.HLP:281:New in Versions 2.81 to 2.81h
>#280CLOG.HLP:280:New in Versions 2.80 to 2.80h
>#OLDESVER.HLP:100:New in Versions 2.01 to 2.60
>#NEWIN200.HLP:1st:New in Version 2.00
>#ANCENVER.HLP:103:New in Versions Through 1.03
>#MAIN.HLP:072:Table of Contents
#OLDESVER.HLP
:100: 
$~9New in Versions 2.01 to 2.60

~E2.60 release:

+ File access
+ Menu activation/deactivation
+ Current key pressed detection
+ Easy access to all 16 bits of a counter
+ Pixel editing of a char set
+ Single Byte editing of a char.
+ Real player distance
+ :key# added: gives twos-compliment of key value.
- SMZX removed.
- inter robot targeting removed.
- Random color startup removed.

>#MAIN.HLP:072:Table of Contents

~E2.51ak1.0 release:
 + Added Numerous new Counters
 + Added new inter robot targeting system
 + Added new SMZX mode, dynamic resolution setting
 + Fixed fatal crash when taking a picture, also increased
  the number of picture you can take to 99
 + Removed Built-in ASCII charset
 + Added Random color start up

>#MAIN.HLP:072:Table of Contents

~E2.51s3.2 release:

 + Removed password protection
 + Added new counter BIMesg to turn off built-in messages

>#MAIN.HLP:072:Table of Contents

~E2.51s3.1 release:

 + Fixed damage table, now works correctly
 + Fixed unworking Alt+s
 + Fixed screenshot name
 + Fixed strange missile color when firing

>#MAIN.HLP:072:Table of Contents

~E2.51s3 release:

 + Fixed bug involving savegame name being overwritten by mod
  name
 + Fixed overlay transparency weirdness. Now, background of
  lower layer will ALWAYS show through if background of
  overlay is 0
 + Added in kev's refresh screen support. Press Alt+w on the
  title screen or editor screen, and = in the game(don't ask,
  has to do with mzx's keyboard handler). Use this if your
  charset gets corrupted in windows.
 + Screen shot saving rotates file name(starts with screen0.pcx)
 + Fixed bug involving incorrect loading of mzx health etc.

>#MAIN.HLP:072:Table of Contents

~E2.51s3final release:

 + Fixed bug involving mod * settings being lost when loading
 + Should have fixed ems problems some were reporting, if not,
 just try to get more conventional memory. Enclosed document
 (convmem.txt) should help you.
 + Fixed a bug involving direction checking.
 + Pressing ']' at most any time will now save a screenshot to
  screen.pcx
 + Pressing Alt+8 in the editor will set the current mod to *.

>#MAIN.HLP:072:Table of Contents

~E2.5.1s2beta release:

 + Added MOD "*", which allows a board to use whatever module
  the previous board was using; this necessitated a change in
  the .SAV file format (still need changes in the editor UI
  to access this feature outside of Robotic)
 + inmate's semantics for MOD "SOMETHIN.MOD*" aren't
  immediately possible, although a rough hack is in already
 + char edits are now not displayed until the beginning of the
  next cycle; the deferred display should eliminate a lot of
  flickering
 + an (at least partial) fix for the infamous UNDER bug
 + MOUSEX, MOUSEY and BUTTONS are now buffered.
 + more sane magic handling
 + can load MZX 2.51 and 2.51S1 worlds, but will only save
  2.5.1spider2 format

>#MAIN.HLP:072:Table of Contents

~E2.51s1beta release:

 + Increased counters to 1000.
 + Added following counters: (ro) is read only, (r&w) is read +
   write
   * (r&w) MOUSEX, MOUSEY - Location of mouse cursor over the
     screen.
   * (ro)  BUTTONS - Status of the buttons (none=0,left=1,
     right=2,both=3)
   * (ro)  MBOARDX, MBOARDy - Location of mouse cursor over the
     board.
   * (ro)  SCROLLEDX, SCROLLEDY - Length the screen has been
     scrolled in each direction.
   * (ro)  PLAYERX, PLAYERY - Location of the player
   * (r&w) CURSORSTATE - Turns on & off the hardware cursor
     (0= off, 1= on, 0 default)
 + Added new independent counter like LOOPCOUNT, named LOCAL,
   it's now possible for a robot to search the screen or
   something without wasting a counter.
 + New .MZX and .SAV formats for MZX2.51S1.
 + .SAV files from 2.51S1 are incompatible with 2.51, and
   vice-versa
 + 2.51S1 is capable of loading 2.51 .MZX world files.
 - 2.51 is not capable of loading .MZX files created or opened &
   saved in 2.51S1

>#MAIN.HLP:072:Table of Contents

$~ENEW in version 2.51: ALL NEW music/sound code! 32-channels;
$~Ebug-free; support for stereo, 16-bit, GUS, and PAS-16;
$~Esupport for many formats and effects; up to four
$~Esimultaneous sound effects!

Note that the new music support requires that you CONVERT all
non-MOD files using the included program, 2GDM. See 'MegaZeux's
Sound System' for details on the NEW music system.

>#SOUNDEFX.HLP:1st:MegaZeux's Sound System

Note- This is a direct translation from the file WHATSNEW.251,
included with MegaZeux. If you haven't used version 1.03 or
before, you probably won't understand much of this list.

~ENew in version 2.51: (quick fix before I do 3.00!)

 * Bug where moving north or west towards a board that is
  larger than 100 tiles in a dimension may not work properly
  fixed.
 * Bugs in 2GDM.EXE preventing proper conversion of some S3Ms
  fixed.
 * A rare bug preventing internal MOD conversion fixed.
 * "Error opening MOD" will no longer appear during normal
  gameplay.
 * Exporting ANSis now adds a color to the end returning text
  to normal grey.

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.50:

 * FOR ALL YOU 2.07 USERS- THE MAJOR UPGRADE is the new sound
  code! Support for stereo, 16-bit, more cards, 4 sound
  effects channels, 32 music channels, higher quality, and
  faster sound code! Less bugs! More formats supported! All
  non-MOD files MUST be converted to GDM using the included
  2GDM.EXE program. Formats supported- MOD (up to 32 channels),
  WOW/OCT/NST, S3M, 669, and MTM.

 * Volume controls (overall and SAM) added to F2-Settings (saved
  in .CFG file)
 * SAMs play at 2x volume.
 * MTM support added to 2GDM.EXE. Other formats aren't added
  because they aren't needed (not used often enough) or in the
  case of XM, because they support too many advanced features
  that MZX does not support. Partial XM support MAY be added
  later.
 * Many minor bug fixes in 2GDM.EXE's conversion routines.
 * Internal MOD conversion (in MegaZeux) sped up considerably.
 * For all those that upgraded from 2.07, see 2.49g and 2.48b
  WHATS-NEW for more stuff, including a couple interesting
  new Robotic features

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.49g:

 * New Import function added- You can import an ANSi to any
  position on the board.
 * Full SAM sound effect support as in the original 2.07 version
  (but using the new MOD code for up to 4 simultaneous
  channels)
 * The OPEN Robotic command will now push the Robot out of the
  way if the door would be blocked by the robot.
 * REL PLAYER and REL COUNTERS now affects the THISX/THISY
  counters (giving the distance FROM the player/counters TO
  the Robot) and the prefixes also affect the IF [dir] BLOCKED
  command, allowing you to check for blocked status next to
  the player or an arbitrary position.
 * [ box message statements now clip their message to 64
  characters (the maximum) on display. Note that all other
  box-message statements are NOT clipped!
 * Color codes are allowed in ? and & box message statements
 * Invalid sound card settings no longer cause a lock-up
 * You can hold down the mouse button to cycle through RGB
  values in the palette editor
 * Changing something to an explosion no longer can cause weird
  colors
 * What's New section of help sorted by version
 * Placing a robot over the player is prevented with a warning
 * The "Alt+N- Music" lights up properly in the editor now
 * When changing from a larger board to a smaller board, you
  can no longer accidentally have the cursor outside of the
  board size.
 * GUS owners don't need to enter # of SFX channels, since
  MegaZeux cannot support GUS sound effects anyways.
 * File boxes (loading MODs, worlds, etc.) can now hold as
   many filenames as memory allows.
 * GUS setup shown properly on configuration screen
 * 2GDM.EXE rewritten- In THIS release, it can only convert
  MOD, NST, WOW, OCT, 669, and S3M files! The final (2.50)
  release will have support for the remaining file formats.
  It is being rewritten to fix many small bugs and make it
  smaller and faster, as well as possibly add more file
  formats.
 * 2GDM.EXE- F00 effect in MODs deleted during conversion
 * 2GDM.EXE- Bad effects S8x, S0x, and Xxx deleted during S3M
  conversion
 * 2GDM.EXE now works properly from other directories
 * INTERNAL MOD loading support. You can now load MODs, NSTs,
  WOWs, and OCTs from within the game without having to
  convert them to GDM first. The only exception is 15-
  instrument MODs- they must first be converted. Note that
  all other formats, such as S3M, 669, etc. must still be
  converted. NST/WOW/OCT support was only added because they
  are extremely similar to MODs, and MODs were required for
  backward compatibility.
 * Insert doesn't display those "Lo bomb selected" messages,
  etc. if the player is Attack Locked or settings say he
  cannot bomb.
 * Minor bugs in ANSi import corrected. (problem fixed- caused
  errors on import of ANSis with more or the same number of
  lines as the current board size maximum)
 * "Ammo <10" and "Ammo >9" entries in Global Chars changed to
  "Small Ammo" and "Large Ammo" to prevent confusion.

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.48b:

 * ALL NEW music code! Features include faster, NO BUGs, 32
  channels, more formats supported (sorry, no MID or XM) etc.
 * Bug where selecting "(no board)" to add a board caused an
  error if that wasn't the first "(no board)" on the list.
 * Bug where if a robot line entered consisted of only
  semicolons, spaces, and commas, it would screw up that
  robot's program, fixed.
 * Command line options (-port,-dma,-irq) added for setting
  sound card parameters. Only needed if auto-detection fails.
 * Minor help corrections.
 * Save/load during testing in editor disabled.
 * Pressing \ no longer causes problems during gameplay.
 * Bug where "Restart board" for death option in global
  options didn't function properly on first board, nor did
  restart-if-zapped. (fixed)
 * Filling in the overlay no longer locks up if you fill over
  something of the same color and picture.
 * Overlay no longer messed up when resizing board.
 * Lock up on Import World removed.
 * Setting the counter "INVINCO" to 0 works properly.
 * Hopefully fixed rare lockups after robot box messages.
 * Added confirmation for board deletion in editor.
 * All included worlds are NO LONGER password protected. (The
  old password was "megahertz".)
 * Minor bugs in passage search algorithms corrected.
 * Obscure bug involving REL prefixes if used in "infinite-
  loop" type constructs (fixed)
 * In editor- Alt+Dir to move 10 spaces now works as expected
  with draw mode on. (IE it will draw in ALL 10 spaces)
 * Bug where passages on screens wider than 256 spaces didn't
  work properly. (fixed)
 * Bug where fire-to-player's-right would lock up and kill him
  FIXED.
 * Counters can be used in ALL strings in &COUNTER& notation.
  For example, SEND "ROBOT" "LABEL&COUNTER&" will replace
  &COUNTER& with a number. This works for ALL strings -
  counter names, labels, robots, etc. See Robotic help for
  details.

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.07:

 * Labels and NON-valid counter-regulated options in robot box
  messages are not blank lines; Instead they are just removed
  from the message.
 * Passage (stairs/caves/whirlpools) search algorithm
  corrected.
 * Digitized sample SFX works properly with the note B now.
 * Bug where getting multiple energizers in a row screwed up
  player's color is fixed.
 * Bug where chests with invinco potions will die when taken
  is fixed.
 * Filling in editor, with a robot/scroll/sensor over itself,
  is now handled properly.
 * Whee!! More minor help typos fixed.

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.06:

 * Yet more cursor safeguards inserted. (Where do you GET
  these problems!? :)
 * Saving a game no longer asks for overwrite confirmation if
  the file doesn't really exist.
 * Help and tutorial- Minor textual errors fixed
 * Save dialog boxes only allow entry of 12 characters now,
  instead of 13.
 * Help file can be accessed from any directory.
 * -l cmd line option will no longer cause a loading error with
  an oversized filename. (it will instead be ignored)

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.05:

 * Cursor bug fixed. (If it isn't, then get a new BIOS! :p)
 * MegaZeux now utilizes overlaid code, for almost 50k core
  memory savings.
 * LOCKSCROLL cmd fixed
 * Moving into the lower-right corner of full-size boards no
  longer warps you to the upper-left corner.
 * SET COLOR and COLOR INTENSITY don't blow up if the color is
  not from 0 to 16.
 * Code for activating 16 background colors is now shorter and
  uses BIOS calls for compatibility.

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.04:

 * Slight modifications to Robotic Tutorial (help file)
 * Sending a robot a message, when it hadn't done anything yet
  that turn, activates it immediately. This helps with
  synchronized activities, such as large, multi-robot
  creatures.
 * Alt+Numerics feature of BIOS keyboard routine DISABLED (IE
  Alt+3 will no longer break to DOS)
 * Counters' code optimized.
 * The temp file ~EDITRSZ.TMP created when resizing a board is
  now deleted when finished.
 * a KEYBOARD CODE kink was worked out (hopefully got 'em
  all...)
 * Made printer code more general (should work on any printer
  in text mode)
 * PALETTE BUG on some SVGA cards FIXED. (black now looks like
  black) If it still isn't, please notify me.
 * HOME and END will jump to the top/bottom of a box
  message/help/scroll.
 * PgUp/PgDn/Mouse navigation work properly in box
  messages/help/scrolls
 * HOME and END in dialogs works properly now- Unless you are
  editing a number, they will jump to the FIRST item and the
  NEXT or OK button, respectively. In a string, they will
  still jump to the start/end unless you are already there,
  then they will jump to the proper dialog location.
 * Robots (especially when there are lots of them) sped up.
 * DUPLICATE SELF and COPY ROBOT cmds sped up some, except when
  used by global robot.
 * Palette intensities reset when going into editor after the
  title screen changes them.
 * MODULO "str" # will no longer crash if # is 0.
 * Extreme palette activity no longer causes snow or (on EGA)
  screen breakup. Palette activity also sped up.
 * Bug fixed- If a SAM/MOD command had to free up board memory
  (showing the little "freeing up board memory..." meter) then
  that robot stopped running.
 * Bug fixed- If the robot changed it's surroundings (IE
  Putting a SPACE to it's NORTH) and then did a RANDNB or
  RANDB, the new surroundings weren't always taken into
  consideration.
 * DIVIDE ERROR crash/bug fixed. (It was related to usage of
  RANDNB and RANDB)
 * CHAR "A" vs. CHAR 'A' question added to F.A.Q.
 * README.TXT changed- Boot disk/support info added.
 * Help on cmd ."@@string" corrected.
 * SPEED defaults to 4 (settings) and is saved in MEGAZEUX.CFG.

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.03:

 * Intensity of palette (and other stuff?) now resets after a
  test game.
 * Messed-up black color on certain graphics cards- Attempted
  to fix.
 * Minor bug in VER1TO2.EXE fixed
 * Robot section of Tutorial corrected (the descriptor scrolls)
 * Speeds based on real time (IE speed 3 will be the same on
  ANY computer, unless the computer itself is so slow that it
  forces a slower speed.)
 * CAVERNS has game over screen fixed
 * MOVE PLAYER [dir] "label" command now works properly.
  (Before, the label was almost always ignored)

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.02:

 * Bugs with Enter in text mode on small boards fixed
 * Bugs with slime fixed
 * If you have screen faded out (COLOR FADE OUT) and go to
  another screen, it no longer fades it in for you
  automatically.
 * HELP.DOC- CHANGE CHAR ID section fixed
 * Fill really does now fill properly on boards larger than
  127x127. :)
 * Sped up sensor interactions somewhat
 * Fixed problems with boards not scrolling with the player,
  in the game on over-sized boards. Run FIX.EXE in all
  directories containing version 2.01 or 2.00 .MZX/.MZB files.
 * Nothing can give you negative coins, gems, etc. (such as
  thieves)
 * Minor robot speed improvements
 * Turning Music Off (Settings in Game) really keeps it
  off... :)

>#MAIN.HLP:072:Table of Contents

~ENew in version 2.01:

 * Sensor command CHAR'X' fixed
 * TAKEing health now counts as hurting the player for the
  :playerhurt label
 * Can load help from any drive/directory
 * Copy block in editor now properly clips the block's
  destination
 * Move block in editor now properly clips the block's
  destination
 * ."@@new_robot_name" command added
 * If the player runs up against a player bullet, it won't
  hurt him
 * JUSTENTERED, JUSTLOADED, and GOOPTOUCHED labels fixed
 * UNLOCKSCROLL and locked scrolling in general fixed
 * Global info now properly sets endgame/death boards
 * Robot ASK command works properly now
 * Help- internet address/address validity date corrected
 * Help- CHANGE CHAR ID help section- added note about how the
  numbers are also listed in the Global Edit Chars menus
 * ENTER can now exit robot box messages/scrolls
 * Message line (bottom) shows color correctly
 * EXCHANGE/RESTORE w/DUPLICATE SELF fixed
 * Attempted to fix cursor problems in editor. If it doesn't
  work now, then I have no solution, as I use documented BIOS
  routines with many safegaurds.
 * Minor speed improvements
 * Minor size reduction
 * Fill in editor now works with board sizes over 127x127

>#NEWINVER.HLP:1st:NEW in MegaZeux!
>#2823CLOG.HLP:283:New in Versions 2.82 to 2.83
>#281CLOG.HLP:281:New in Versions 2.81 to 2.81h
>#280CLOG.HLP:280:New in Versions 2.80 to 2.80h
>#OLDERVER.HLP:099:New in Versions 2.60 to 2.70
>#NEWIN200.HLP:1st:New in Version 2.00
>#ANCENVER.HLP:103:New in Versions Through 1.03
>#MAIN.HLP:072:Table of Contents
#NEWIN200.HLP
:1st: 
$~9New in Version 2.00:

 * All code has been rewritten or at least stepped through line
  by line, except for the music code.
 * New user interface style and startup screen. Lots of neat
  little items like shadows, nicer colors, etc. Mostly
  aesthetic but nice. Mouse support also improved.
 * Keyboard code rewritten (again) All Alt+lock, shift-lock,
  and ctrl+lock problems, as well as most other keyboard
  problems, should not be a problem anymore. You may have to
  use the -keyb2 command line option. If a key locks, tap it
  a couple times.
 * No flicker- The game engine now page flips.
 * Better string input- ANYWHERE you can enter a string, you
  can now move with the cursors and insert in the middle...
 * Better character selection box- Shows all the characters.
 * New default character set- Much nicer, more general use
  characters.
 * Now detects processor to avoid lock ups on an old 8086/8088.
  If an invalid graphics card is found, DOS services are used
  for printing.
 * Different command line options. (use -? to get info on them)
 * Context sensitive help.
 * Bombs and Sensors under the player no longer mess up floors,
  etc.
 * CHANGEing something to lava, fire, etc. now works correctly.
 * Transporting onto a Sensor works properly.
 * New conditions- MUSICON and PCSFXON
 * Changing things to spaces CLEARS them, to avoid screwing up
  floors.
 * Restart position not changed during a save/load
 * Label- :playerhurt for when player is hurt, not sent on
  invincible hurts
 * Maximum Robot commands per cycle is 40, not 25
 * Global Robot runs normally in freeze/slow time
 * Choice of 100x100, 200x50, 400x25, 80x125, or 60x166 for
  each board.
 * Character editor remembers character you were editing.
 * Robo-P renamed to Robotic
 * Scrolls now allow proper use of mouse, pgup, and pgdn.
 * Scrollborder became Scrollcorner.
 * :gooptouched auto label added, for when the player touches
  Goop.
 * Messages like "You got a red key" are now "You got a key" so
  palette fiddling won't make strange words. :)
 * Within Robotic messages (box/line) a &INPUT& will be
  replaced by the exact text of the currently inputted string
 * Notes in play of same freq. won't run together
 * Explosions won't destroy entrances, lava, water, ice, or
  goop
 * Robots are stopped from firing if there is already a bullet
  of the same dir/type in that dir.
 * Other things will push the player ONTO a Sensor.
 * The above will trigger the SENSORON label.
 * If player is on an entrance without having been there before
  the update, use it. (I.E. can now be pushed onto entrances)
 * Teleporting or walking onto a screen and starting on a
  Sensor will trigger the SENSORON label
 * Non-players/puzzle pieces now transport properly.
 * PLAYERLASTDIR (0-4) and PLAYERFACEDIR (0-3) as counters.
 * Points for killing enemies (3) and points for rings/potions
  (5)
 * Way to disable edging spaces on message row- ENABLE MESG
  EDGE, DISABLE MESG EDGE.
 * Cmds- LOOP START, LOOP # TIMES, ABORT LOOP, uses Robot
  counter LOOPCOUNT
 * Counter limit increased to 50 plus built-in.
 * New passage search order- 1) Same type, same color 2) Same
  color 3) Same type, same foreground 4) Same foreground 5)
  Same type 6) Default player position
 * Palette import/export
 * If the starting board is deleted, change starting board to
  title.
 * "Sets of five" numerical input actually increase by fives
 * Holding the mouse button on a numeric arrow button cycles
  the num.
 * Removed the "." Directory from file menus
 * Six (not four) status counters.
 * CHANGE blah p?? blah p?? (notice the p?? added for the first
  thing)
 * Doors, if can't move, don't advance in anim. I.E., doors
  won't get "stuck" if they are blocked.
 * PERSISTENT GO command, like /"nsew" but WAITS to move if
  blocked.
 * No chest message on empty.
 * Startup "help" screen on first use.
 * Explosions Leave Empty doesn't mess up ANY floors, etc.
 * Much better fill routine.
 * Entering a non-cmd with the first character as a [, ., :,
  etc. automatically formats it. Leading and trailing spaces
  and quotes are cleared first.
 * Save/Load game/etc. are accessed through F-keys in the game.
 * Removed special menu for Alt+M (modify) in editor
 * In editor, keeps track of whether world has been modified.
 * Ceiling layer - non-interactive, but overlays things and
  looks neat. Included in editor- Edit, display toggle.
  Robots - changing it by character, copying areas of it, and
  filling an area of it by cmd or string (I.E. set area to "A
  string") Char of 32 is see-thru. Layer during game can be on,
  off, or static (I.E. not Scrolling, just showing upper left
  portion).
 * Robot commands to change the mode of saving.
 * Limit any one Robot/Scroll to 31k.
 * Allow placing shooting fire in editor.
 * Make all enemies without speed arguments move 1/2 their
  speed.
 * Player CANNOT be overwritten, you must place him anew to
  move him.
 * First line of Robot now shows if it is a box mesg.
 * Speed 1 in game does NOT page flip, for speed.
 * Inputted strings allow input of spaces.
 * Time limits- Out of time zaps to entrance automatically,
  THEN RESETS TIMER. Counter TIMERESET holds reset value for
  timer, and the TIME counter holds the current time.
 * MOD code has only an error on no memory. Errors for loading
  MODs and SAMs (I.E. not enough memory) are active if the
  debug menu (F6) is shown. SAMs have errors for file errors/
  out of memory. These errors are always in the editor/testing
  games.
 * First test of a game doesn't give GAME OVER.
 * Sound effects aren't cut off across screens.
 * Placing a bomb while upon a passage no longed warps to title.
 * Sensors are pushable by things other than the player.
 * New Sensor-activated label- SENSORPUSHED, when the Sensor is
  pushed, with or without the player on it.
 * Label- JUSTENTERED when the player just entered the screen
  or the game is started. (NOT restored)
 * Command- Can lock/unlock board Scrolling temporarily-
  LOCKSCROLL, UNLOCKSCROLL.
 * IF ALIGNEDROBOT "Robot" "label"
 * Damage editing- Changing the amount of damage things
  inflict.
 * Load title screen directly when loading game for title.
  Prevents music on first board from playing, and saves time.
 * New Robot-specific auto-counters- (read only) THISX, THISY.
 * Anywhere a number can go in a Robotic command, a counter can
  too. Wherever there is a number, character, or color, you
  can use a counter name in quotes instead.
 * Cmd line- load MZX file. (-lxxxxxxxx.MZX)
 * Config file for options, ask "OK?" on startup. Removed all
  config cmd line options.
 * Cmd- SCROLLVIEW X Y. (upper left hand corner is specified)
  Based off of current player position.
 * Cmd- SWAP TO WORLD "world.mzx" as if starting the world up.
  Skips any title screen. (you could put a message there) The
  other world can have a "Only play from swap" option set.
 * Quicksave key in game- Saves without asking for filename and
  confirmation.
 * Quickload key in game- Same idea.
 * Option (default off) on world to clear messages, bullets,
  and spitfires from a screen when exited.
 * Label JUSTLOADED sent to as soon as the game is started or
  restored. (including the title screen and actual playing)
 * Shows character number on char edit and char selection.
 * Shows color number on color selection.
 * Multiple spots to SAVE/RESTORE/EXCHANGE PLAYER POSITION. (8)
 * RESTORE/EXCHANGE PLAYER POSITION with the option to
  duplicate the Robot to take his place. When the player moves
  back, the Robot is, of course, deleted.
 * Remove RANDOM POS/SIZE options.
 * Allow labels to interrupt in a Robot's box-message code and
  have the message still show uninterrupted.
 * Show a pic of the item next to it in the THINGS menus.
 * Different bullet pics/colors for player, neutral, and enemy
  bullets.
 * Status shown counters won't show if the value is 0.
 * Prefixes that affect only the first or last x y pair of a
  command. (REL COUNTERS LAST, REL SELF FIRST, etc.)
 * Mod fading commands (background)
 * Allow lives/health to max out at 65535.
 * Score as a counter.
 * Maximum of 150 boards. (not 127)
 * Cmd- COPY BLOCK x y x y x y.
 * Label for SpitFire hitting a Robot- "spitfire"
 * Label for Lazer hitting a Robot- "lazer"
 * Cmd- CLIP INPUT (chops first word + spaces off of input)
 * Cmd- IF FIRST INPUT "str" "label"
 * KEY1 through KEY9 labels. (like KEYA thru KEYZ)
 * Allow viewport sizes down to 1x1.
 * PUSH Robot command- push things to dir without moving there.
 * ONE global Robot. (No ID) Stored separate from a board, and
  is active on ALL boards.
 * Robots- Allow importing of a character into a CHAR EDIT
  command.
 * Robots- Have SCROLL CHAR, FLIP CHAR, and COPY CHAR commands.
 * Full backward compatibility w/old MegaZeux via a conversion
  program. (VER1TO2.EXE)
 * Editable built-in sfx. (including to digitized)
 * Elements- Goop, which is like Water from ZZT.
 * EGA/VGA palette editor, with easy fading. Commands- COLOR
  INTENSITY # PERCENT, COLOR INTENSITY "counter" PERCENT,
  COLOR FADE IN, COLOR FADE OUT, SET COLOR # TO r g b, SET
  COLOR # TO INTENSITY # PERCENT, SET COLOR "counter" TO
  INTENSITY "counter" PERCENT. (note- the FADE OUT/IN cmds
  are "quick" fades, IE not in the bk, but they actually
  stall the game a bit. They also end the current cycle.)
 * Display counters within strings, IE. * "You have &GEMS&
  gems." (use && for &)
 * Robot command- LOAD CHAR SET "file.chr"
 * New default characters for global chars and char set.
 * When adding another board, copy most of the options (can
  attack, etc.) from the current board, including MOD file.
 * Edit ANY character/color from Global Chars.
 * Char editor- Revert to ASCII, Revert to MegaZeux, changed
  REVERSE to NEGATIVE.
 * Alt+Y Debug info LABELs each line.
 * Block command- Paint (w/color).
 * Board editor- Scroll when cursor is five spaces from the
  edge.
 * Fade in/out between screens and program areas.
 * Ice does NOT keep pushing you against something. If you are
  blocked, cease movement.
 * Make sound test available in editor as an option, from the
  sound effects editing screen.
 * Can't test a save-locked game w/o pw, and it no longer locks
  up from this.
 * REMOVED Scroll coloring on line by line. (using ! codes)
 * Export .ANS file.
 * Energizer will return player color to old color.
 * Capture and throw away ctrl+C, PrintScreen, SysRq, and
  Pause.
 * Return in editor at end of program can now add a blank line.
 * Allow marking of a section of Robot, in lines. You can now
  Copy, Cut, Clear, or Paste blocks.
 * Remove useless "pro" mode.
 * Robot commands- DIVIDE, MULTIPLY, MODULO.
 * Different player pics per direction.

>#NEWINVER.HLP:1st:NEW in MegaZeux!
>#2823CLOG.HLP:283:New in Versions 2.82 to 2.83
>#281CLOG.HLP:281:New in Versions 2.81 to 2.81h
>#280CLOG.HLP:280:New in Versions 2.80 to 2.80h
>#OLDERVER.HLP:099:New in Versions 2.60 to 2.70
>#OLDESVER.HLP:100:New in Versions 2.01 to 2.60
>#ANCENVER.HLP:103:New in Versions Through 1.03
>#MAIN.HLP:072:Table of Contents
#ANCENVER.HLP
:103: 
$~9New in Versions Through 1.03

1.03 release: QUICK FIXES, LIMITED DISTRIBUTION

 * TELEPORT command fixed
 * Gives error on attempt to test pw-protected world
 * "Explosions leave Empty" won't screw up floors, etc. (except
   web)
 * Placing a bomb over an entrance no longer warps to the title
   screen
 * INPUT STRING allows input of spaces

>#MAIN.HLP:072:Table of Contents

1.02 release: NEW:

 * Miscellaneous help errors fixed
 * Miscellaneous errors in Caverns fixed
 * Miscellaneous speed/efficiency code updated
 * AVALANCHE fully fixed, now can be entered into a robot
 * Timing code fixed (may fix some problems)
 * Slight modification to keyboard code (may fix some problems)
 * Added -keyboard2 option

>#MAIN.HLP:072:Table of Contents

1.01 release: FIRST "NON-BETA" RELEASE:

 * JUMP MOD ORDER 'num' has now been documented.
 * AVALANCE corrected to AVALANCHE.
 * Robot command GO DIR "LABEL" fixed.
 * Some minor help errors fixed.
 * Fixed bug where a BECOME THING command, if becoming a space,
   fake, or other "under"-type object, would not erase anything
   already under the robot.
 * REL TO PLAYER and REL TO SELF now work with the TELEPORT
   command.
 * If a robot (from WALKing) is sent to the EDGE label and none
   exists, it then attempts to find a THUD label as well.

>#MAIN.HLP:072:Table of Contents

1.00g release: FIRST PUBLIC RELEASE:

 * Removed ALL joystick support- Didn't work, couldn't get it
   to.
 * PW protect- lot simpler, faster, and easier to hack. :)
 * GLOBAL INFO- Toggleable game over music (you should correct
   this in all your pre-1.00g games)
 * Fixed misc. bugs in games. SOMEONE NEEDS TO TEST THEM ALL
   AGAIN FROM START TO FINISH.
 * Strings w/o quotes that begin with C or P are not
   capitilized funny.
 * Settings box no longer turns off music.
 * Alt-A in editor (param) gives error if there is not a legal
   "thing".
 * ALLIGNED fixed to ALIGNED (spelling error inherited from
   ZZT)
 * Fixed bug where if slow time or freeze time was active when
   player touched a door, player was copied.
 * Help- fixed slight bugs
 * Fixed minor problems in Caverns, Forest, and Chronos
 * MOD not required for SAM
 * Level not speeded up if MOD not playing
 * MOD not require a speed command (speed properly done)
 * Help uses Alt-P to print
 * Speed defaults to 3 not 4

>#MAIN.HLP:072:Table of Contents

6th beta release: NEW:

 * Fixed bug where slow/stop effects didn't work on title.
 * Fixed bug in command MOVE PLAYER where it would occasionally
   create junk.
 * Fixed bug in robot editor where if "Show Colors" option
   (Alt-O) was off, any color with a ? for the second digit
   showed an incorrect first digit- cV? for cF?, etc.
 * The direction UNDER now works with the PUT thing dir PLAYER
   command.
 * Dir/drive support added to loading MZX fileboxes.
 * HELP IS IN ONE FILE- MZX_HELP.PKG (note- memory minimum is
   still maintained.)
 * Fixed bug where fire could hurt you indirectly even if
   lavawalker was in effect.
 * Fixed bug where nothing (except player) could push a
   pushable robot head on. (only if it was in a string of
   things to push)
 * Fixed bug where shooting fire would destroy entrances.
 * Fixed bug in Put commands that would erase before placing,
   so putting things over a fake or floor erased the
   fake/floor. (etc)
 * Change command- Didn't change params properly if you were
   changing between like objects (IE text to text) Also made
   more robust against attempts to change things to
   robots/scrolls/signs/sensors/players.
 * Put commands- Made more robust against attempts to put
   robots/scrolls/signs/sensors/players.
 * Fixed bug where no player on a board would really mean no
   player!
 * With Shift-F1 through Shift-F4 in editor, the key used to
   stop the flashing is not interpreted but ignored.
 * Sensor/Robot interactions! (See help)
 * PageUp will change menus in the editor now. (along with
   PageDown)
 * Removed all refrences (except in file format) to double
   speed robots and projectiles. Code increase is not worth it.
 * RANDB, RANDNB directions added!
 * Misc. help corrections and bug fixes, finished help. (except
   for minor changes)
 * Alt-O (options) no longer clears the command line at the
   bottom
 * Character insert in robot editor now inserts the characters
   corresponding to 10 and 13.
 * If you select base 16 in Alt-O options (robot editor) then
   ALL numbers are shown in hex, including when editing the
   line. (previously, the current line was shown in base 10 at
   all times.)
 * Chronos-Stasis finished. (not tested outside of myself)
 * Forest of Ruin finished except for ending. (see above)
 * Repeat (F4) and Delete line (Alt-D) added to robot editor
 * Copy, Cut, and Paste line (Alt-C/T/P) added to robot editor
   (note- paste REPLACES current line)
 * Export robot (Alt-X) added to editor. Exporting from current
   line or top of program both supported.
 * Import robot (Alt-I) added to editor. Importing only looks
   for *.TXT in the filebox. Import always REPLACES the current
   robot program.

>#MAIN.HLP:072:Table of Contents

5th beta release: NEW:

 * Fixed bug in teleport command where screen was not updated
   if player ended up in the same position.
 * Fixed bug where mouse didn't select right item on game menu
 * Fixed bug where adding a new robot/scroll/sensor when the
   current item was a robot/scroll/sensor would reset the color
   to lt.grey
 * Caverns all finished (hope I got all the bugs)
 * The DEF.COLORS option doesn't reset when changing/adding
   boards now
 * SAM now works right...
 * In fact, added new code for MOD and VOC- a LOT less "out of
   mem" or "error loading" errors.
 * Fixed bug with locked doors (not locks, but real doors)
 * Saving games and files is MUCH faster in almost all
   circumstances. Save meter more accurate as well.
 * Board import/export fixed- robots/scrolls/sensors were
   messed up
 * Pgdn, Pgup, Ctrl/Alt Home, Ctrl/Alt End added to robot
   editor.
 * Ctrl/Alt Left + Right used to jump 10 chars in character
   selection boxes.
 * Save area in character editor (F-2 and F-3) stays the same
   between calls to the character editor, including when
   loading games.
 * Character editor shows not only current char pic, but those
   of the three chars before and three chars after as well.
 * Fixed bug where a robot with no program would majorly mess
   up things.
 * Misc. bug fixes, help typos, and optimizations.
 !ADDED 14 COMMANDS (all commands finished)
 !ADDED  2 DIRECTIONS (randp, randnot)
 * Help brings up Robot Table of Contents within robot editor
 * Quotes not required around strings of one word not matching
   any reserved word, IE a word used for ANYTHING else,
   anywhere. They are added automaticaly, though.
 * EDITOR OPTIONS in robot editor (Alt-O) Choose number base,
   upper case or lower case, and whether to display colors.
 * Bug fixed in editor- Now colors like c7? (with ? at end)
   work right.
 * Calibrate Joystick button added to Game options (F2) Tony-
   See if this helps.
 * Speeded up certain file operations. This MAY fix the
   "lockup" bug when accessing Help during a MOD- I think that
   the lockup may of been just a really slow file access.
 * Added X position indicator to bottom left of robot window,
   to facilate creating box messages that aren't too long.
 * Fixed bug that allowed entering ANY character at the mixing
   rate prompt.
 * INPUT STRING, IF STRING "str" "label", IF STRING NOT "str"
   "label" robot commands added.
 * UNDER/BENEATH direction added to IF dir PLAYER thing "label"
   command.
 * Clarified options at startup- Music device became Device for
   Digitized Music and Sound.
 * Added four more mixing rates. Choose from 7500 up to 25000
   in jumps of 2500. (eight rates total)

>#MAIN.HLP:072:Table of Contents

4th beta release: NEW:

 * Note- SAVE GAME FORMAT CHANGED. Delete all your .SAV files.
   .MZX file format NOT changed- compatibility still
   maintained.
 * Scroll border/etc. colors changable using robot commands-
   SCROLLBASE COLOR, SCROLLBORDER COLOR, etc. (see help)
 * Removed Alt-Minus and Alt-Plus keys in editor- Useless and
   dangerous. (they were only for testing purposes.)
 * Various bug fixes
 * Joystick support- UNTESTED! Tony- I need feedback!
 * Mixing rate options at startup.
 * A warning is given and verification is necessary if you try
   to save a .MZX file over an already existing file.
 * You can now choose from some additional music output
   devices.
 * Help is in seperate files, MZX*.HLP, to save memory. (lots!)
 * I FINALLY THINK THE MEMORY AND FILE CODE WORKS PERFECT!
   Except for speed. Something to work on...
 * Char editor shows values of bytes along left side, for use
   with robot command CHAR EDIT.
 * Yet more help
 * Robot editor! See the top box for keys to use (Import/eXport
   not implemented yet)
 * Robots as well! See Help, Robo-P Reference, Command
   Reference, and look at commands for help using them. Some
   are not done yet.
 * Video mode returns to default VGA mode (text 16x9) on exit
 * File lists sorted
 * Directory support and DRIVE support in file boxes WAS added,
   but was taken out due to problems since changing the current
   directory makes it almost impossible to find the current
   .MZX file to read boards from.
 * Custom Critical Error Handler (no dos grey messages if the
   drive is invalid or something like that)
 * Password displayed as *'s when inputting, except on
   protection menu. (Do YOU think it should be *'s on
   protection menu? 'T'? CP?)
 * Enemys-hurt-enemys option added (GLOBAL info, SPEC. button)
 * "Show Robots" option added (Shift F2)
 * More help added
 * Fixed sensor bug (The player couldn't move onto it in most
   cases)
 * Fixed a bug where if you tried to Grab something via the
   Modify menu and the current thing was a scroll, sign, or
   robot that had no copy anywhere else on the current board,
   then the memory allocated to that object was not freed.
   (whew!)
 * A few more optimizations
 * Mouse disapears after a certain period of time of non-use
 * Boulders from the AVALANCHE potion, and explosions from the
   BLAST potion can't appear over an entrance anymore
 * Fixed some bugs in Text Export
 * Removed .BIN import- Waste of program space
 * Made ALL options (protection, ANSi import) available in
   unregistered- now registration is only for the games
 * Removed "suicide key" from game. Think about how it could
   screw up carefully planned cinemas, story sequences, etc.
 * Mouse support in character editor
 * Test function added
 * Speeded up saves and board switches
 * Slowed down all file access (okay, so it's not a feature,
   but it's more reliable, as is memory management as well)
 * Made save meter more accurate
 * BLOCK COMMANDS! (in editor)
 * ZZT board import (not perfectly accurate, but...)
 * Bug fixed where games with the title screen title at maximum
   length would mess up the file list box
 * MOD (SB & speaker) support! (& SAM)
 * Explosion-meets-player bug fixed

>#MAIN.HLP:072:Table of Contents

3rd beta release: NEW:

 * Full mouse support (except in character editing)
 * No "pointer" mouse...
 * Scrolls and sensors
 * Robot code (memory management) mostly transparent to user
 * GLOBAL Info- Death & endgame options
 * GLOBAL Info- Removed "Health Only/Lives Only" options
 * CW/CCW support
 * Sound always the same speed
 * Bug fixes and optimizations
 * Status Info added

>#MAIN.HLP:072:Table of Contents

2nd beta release: NEW:

 * Cmd line options
 * Mouse support (not finished)
 * -Bios option
 * Hopefully fixed Tony's graphics bugs (try it with and
   without -bios)
 * Bug fixes
 * Tutorial.mzx has creatures/guns sections
 * Fixed/better/changed keyboard routines
 * Optimized code

>#NEWINVER.HLP:1st:NEW in MegaZeux!
>#2823CLOG.HLP:283:New in Versions 2.82 to 2.83
>#281CLOG.HLP:281:New in Versions 2.81 to 2.81h
>#280CLOG.HLP:280:New in Versions 2.80 to 2.80h
>#OLDERVER.HLP:099:New in versions 2.60 to 2.70
>#OLDESVER.HLP:100:New in versions 2.01 to 2.60
>#NEWIN200.HLP:1st:New in version 2.00
>#MAIN.HLP:072:Table of Contents
